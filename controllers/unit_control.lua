---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 2/15/2022 9:56 PM
---
require("__enemyracemanager__/global")
require("util")

local BaseBuildProcessor = require("__enemyracemanager__/lib/base_build_processor")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local UtilHelper = require("__enemyracemanager__/lib/helper/util_helper")
local AttackGroupProcessor = require("__enemyracemanager__/lib/attack_group_processor")
local AttackGroupBeaconConstants = require("__enemyracemanager__/lib/attack_group_beacon_constants")
local AttackGroupBeaconProcessor = require("__enemyracemanager__/lib/attack_group_beacon_processor")
local AttackGroupPathingProcessor = require("__enemyracemanager__/lib/attack_group_pathing_processor")
local AttackGroupHeatProcessor = require("__enemyracemanager__/lib/attack_group_heat_processor")
local InterplanetaryAttacks = require("__enemyracemanager__/lib/interplanetary_attacks")


local Config = require("__enemyracemanager__/lib/global_config")

local base_build_group = {}

local CHUNK_SIZE = 32
local BUILD_BASE_RETRY = 3

local on_biter_base_build = function(event)
    local entity = event.entity
    if entity and entity.valid then
        BaseBuildProcessor.exec(entity)
        AttackGroupBeaconProcessor.create_spawn_beacon(entity)
    end
end

local on_build_base_arrived = function(event)
    --if event.group then
    --    BaseBuildProcessor.exec(event.group.members[1])
    --    AttackGroupBeaconProcessor.create_spawn_beacon(event.group.members[1])
    --end
end

local on_unit_group_created = function(event)
    local group = event.group
    local force = group.force
    local force_name = force.name
    local is_group_tracker_group = storage.group_tracker and storage.group_tracker[force_name]
    local erm_group = storage.erm_unit_groups[group.unique_id]
    local race_settings = storage.race_settings[force_name]
    --if race_settings.is_primitive then
    --    return
    --end
    
    if ForceHelper.is_enemy_force(force) then
        local scout_unit_name
        if is_group_tracker_group then
            if storage.enemy_surfaces[group.surface.name] == nil or AttackGroupProcessor.FLYING_GROUPS[storage.group_tracker[force_name].group_type] then
                scout_unit_name = 2
            else
                scout_unit_name = 1
            end
        elseif erm_group then
            if storage.enemy_surfaces[group.surface.name] or erm_group.is_aerial then
                scout_unit_name = 2
            else
                scout_unit_name = 1
            end
        elseif TEST_MODE then
            scout_unit_name = 1
        elseif not race_settings.is_primitive and UtilHelper.can_spawn(75) then
            if storage.enemy_surfaces[group.surface.name] then
                scout_unit_name = 2
            else
                scout_unit_name = 1
            end
        end

        if scout_unit_name then
            storage.scout_unit_name[group.unique_id] = {
                entity = group,
                scout_type = scout_unit_name,
            }
        end
        
        --defines.events.on_object_destroyed
        local registration_number, useful_id, object_type
        registration_number, useful_id, object_type = script.register_on_object_destroyed(group)
        storage.registered_groups[useful_id] = {
            registration_number = registration_number,
            useful_id = useful_id,
            object_type = object_type,
            group = group,
            last_position = group.position,
            last_tick = game.tick
        }
    end
end

local scout_type = {
    AttackGroupBeaconConstants.LAND_SCOUT,
    AttackGroupBeaconConstants.AERIAL_SCOUT
}

local checking_state = {
    [defines.group_state.gathering] = true,
    [defines.group_state.wander_in_group] = true,
    [defines.group_state.finished] = true
}

local on_unit_group_finished_gathering = function(event)
    local group = event.group
    if not group.valid then
        return
    end
    
    local is_erm_group = AttackGroupProcessor.is_erm_unit_group(group.unique_id)
    if is_erm_group and storage.erm_unit_groups[group.unique_id].scout_id then
        return
    end

    local group_force = group.force
    local force_name = group_force.name
    local race_settings = storage.race_settings[force_name]
    --if race_settings.is_primitive then
    --    return
    --end

    if ForceHelper.is_enemy_force(group_force) and
        not is_erm_group and
        group.is_script_driven and
        group.command == nil and
        checking_state[group.state]
    then
        local target = AttackGroupHeatProcessor.pick_target(group_force.name)
        AttackGroupProcessor.process_attack_position({
            group = group,
            target_force = target,
        })

        storage.erm_unit_groups[group.unique_id] = {
            group = group,
            start_position = group.position,
            always_angry = false,
            nearby_retry = 0,
            attack_force = target,
            created = game.tick,
            is_aerial = false
        }
    end

    local scout_unit_name = storage.scout_unit_name[group.unique_id]
    if  ForceHelper.is_enemy_force(group_force) and
        (group.is_script_driven == false or is_erm_group) and
        scout_unit_name
    then
        local surface = group.surface
        local force_name = group_force.name
        storage.skip_quality_rolling = true
        local scout = surface.create_entity({
            position =  group.position,
            surface = surface,
            force = group_force,
            name = AttackGroupBeaconProcessor.get_scout_name(force_name, scout_type[scout_unit_name.scout_type], surface.name),
            count = 1
        })
        if scout then
            group.add_member(scout);
            if is_erm_group and not storage.erm_unit_groups[group.unique_id] then
                storage.erm_unit_groups[group.unique_id].scout_id = scout.unit_number
            end
        end
    end

    if Config.check_unit_group_for_mod_incompatibility(group) then
        return
    end
    
    if scout_unit_name then
        storage.scout_unit_name[group.unique_id] = nil
    end
end

--- handle scouts under ai complete
local handle_scouts = function(scout_unit_data)
    if scout_unit_data and
        scout_unit_data.can_repath and
        scout_unit_data.entity.valid
    then
        local tracker = storage.scout_tracker[scout_unit_data.force_name]
        if tracker then
            local entity = tracker.entity
            if util.distance(tracker.final_destination, entity.position) < CHUNK_SIZE then
                AttackGroupBeaconProcessor.create_attack_entity_beacon(entity)
                local target_beacon = AttackGroupBeaconProcessor.pick_attack_beacon(
                        entity.surface,
                        entity.force,
                        tracker.target_force,
                        true
                )

                if target_beacon then
                    if util.distance(tracker.final_destination, target_beacon.position) < CHUNK_SIZE then
                        scout_unit_data.can_repath = false
                        return
                    end

                    tracker["final_destination"] = target_beacon.position
                    tracker["update_tick"] = game.tick
                    scout_unit_data.entity.commandable.set_command({
                        type = defines.command.go_to_location,
                        destination = target_beacon.position,
                        radius = 16,
                        distraction = defines.distraction.none
                    })
                end
            end
        end
    end
end

local nearby_retry = 3
--- handle ERM groups under ai complete
local handle_erm_groups = function(unit_number, event_result, was_distracted)
    if AttackGroupProcessor.is_erm_unit_group(unit_number) then
        local erm_unit_group = storage.erm_unit_groups[unit_number]
        local group = erm_unit_group.group
        
        AttackGroupProcessor.destroy_invalid_group(erm_unit_group.group, erm_unit_group.start_position)

        if not group.valid then
            AttackGroupProcessor.storage_clean_up(unit_number)
            return
        end

        if event_result == defines.behavior_result.fail or
            erm_unit_group.nearby_retry >= nearby_retry
        then
            if erm_unit_group.always_angry and erm_unit_group.always_angry == true then
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    distraction = defines.distraction.by_anything,
                    target_force = erm_unit_group.attack_force,
                    new_beacon = true
                })
            else
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    target_force = erm_unit_group.attack_force,
                    new_beacon = true
                })
            end
            erm_unit_group.nearby_retry = 0
        elseif
            group.command == nil or
            group.state == defines.group_state.finished or
            event_result == defines.behavior_result.success
        then
            if erm_unit_group.always_angry and erm_unit_group.always_angry == true then
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    distraction = defines.distraction.by_anything,
                    target_force = erm_unit_group.attack_force,
                    find_nearby = true
                })
            else
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    target_force = erm_unit_group.attack_force,
                    find_nearby = true
                })
            end
            erm_unit_group.nearby_retry = erm_unit_group.nearby_retry + 1
        end

        if event_result == defines.behavior_result.success and was_distracted == false then
            erm_unit_group.has_completed_command_at = group.position
        end
    end
end

local on_ai_command_completed = function(event)
    local unit_number = event.unit_number
    local event_result = event.result
    
    -- Hmm... Unit group doesn"t call AI complete when all its units die.  its unit triggers behaviour fails tho.
    -- Can utilize register_on_object_destroyed
    handle_erm_groups(unit_number, event_result, event.was_distracted)

    local scout_unit_data = storage.scout_by_unit_number[unit_number]
    handle_scouts(scout_unit_data)
    
    
    --if DEBUG and storage.registered_groups[unit_number] then
    --    print('on_ai_completed')
    --    print(unit_number)
    --    print(DEBUG_BEHAVIOUR_RESULTS[event_result])
    --    local group = storage.registered_groups[unit_number].group
    --    if group.valid then
    --        print(DEBUG_GROUP_STATES[group.state])
    --        print(DEBUG_MOVING_STATES[group.moving_state])
    --        print(tostring(group.is_script_driven))
    --        print(serpent.block(group.command)) 
    --    end
    --end
end

--- @TODO 2.0 handle this with per planet statistic?
local function is_unit_spawner(event)
    return event.entity.type == "unit-spawner" and not ForceHelper.is_enemy_force(event.force)
end

local function handle_unit_spawner(event)
    local dead_spawner = event.entity
    AttackGroupHeatProcessor.calculate_heat(dead_spawner.force.name, dead_spawner.surface.index, event.force.index)
end

local function handle_unit_group_destroyed(event)
    local group_number = event.useful_id
    if event.type == defines.target_type.commandable and 
       storage.registered_groups[group_number] and
       storage.registered_groups[group_number].registration_number == event.registration_number
    then
        AttackGroupProcessor.storage_clean_up(group_number)
    end
end


local UnitControl = {}

UnitControl.events = {
    --- This event queue up to 10 units.
    [Config.custom_event_handlers[Config.EVENT_REQUEST_BASE_BUILD]] = function(event)
        local i = 0
        local limit = event.limit or 1
        if limit > 10 then
            limit = 10
        end
        repeat
            BaseBuildProcessor.build_formation(event.group)
            i = i + 1
        until #event.group.members == 0 or i == limit
    end,
    [Config.custom_event_handlers[Config.EVENT_INTERPLANETARY_ATTACK_EXEC]] = function(event)
        InterplanetaryAttacks.exec(event.force_name, event.target_force)
    end,
    [defines.events.on_entity_died] = function(event)
        if is_unit_spawner(event) then
            handle_unit_spawner(event)
        end
    end,
    --- Path finding
    [defines.events.on_script_path_request_finished] = function(event)
        AttackGroupPathingProcessor.on_script_path_request_finished(event.id, event.path, event.try_again_later)
    end,
    --- Init path finder
    [Config.custom_event_handlers[Config.EVENT_REQUEST_PATH]] = function(event)
        AttackGroupPathingProcessor.request_path(event.surface, event.source_force, event.start, event.goal, event.is_aerial, event.group_number)
    end,
    [defines.events.on_biter_base_built] = on_biter_base_build,
    [defines.events.on_build_base_arrived] = on_build_base_arrived,
    [defines.events.on_unit_group_created] = on_unit_group_created,
    [defines.events.on_unit_group_finished_gathering] = on_unit_group_finished_gathering,
    [defines.events.on_ai_command_completed] = on_ai_command_completed,
    [defines.events.on_object_destroyed] = handle_unit_group_destroyed
}

return UnitControl