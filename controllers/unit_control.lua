---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 2/15/2022 9:56 PM
---
require("__enemyracemanager__/global")
require("util")

local BaseBuildProcessor = require("__enemyracemanager__/lib/base_build_processor")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local UtilHelper = require("__enemyracemanager__/lib/helper/util_helper")
local AttackGroupProcessor = require("__enemyracemanager__/lib/attack_group_processor")
local AttackGroupBeaconProcessor = require("__enemyracemanager__/lib/attack_group_beacon_processor")
local AttackGroupPathingProcessor = require("__enemyracemanager__/lib/attack_group_pathing_processor")
local AttackGroupHeatProcessor = require("__enemyracemanager__/lib/attack_group_heat_processor")
local InterplanetaryAttacks = require("__enemyracemanager__/lib/interplanetary_attacks")


local Config = require("__enemyracemanager__/lib/global_config")

local DEBUG_BEHAVIOUR_RESULTS = {
    [defines.behavior_result.in_progress] = "defines.behavior_result.in_progress",
    [defines.behavior_result.fail] = "defines.behavior_result.fail",
    [defines.behavior_result.success] = "defines.behavior_result.success",
    [defines.behavior_result.deleted] = "defines.behavior_result.deleted"
}

local DEBUG_GROUP_STATES = {
    [defines.group_state.gathering] = "defines.group_state.gathering",
    [defines.group_state.moving] = "defines.group_state.moving",
    [defines.group_state.attacking_distraction] = "defines.group_state.attacking_distraction",
    [defines.group_state.attacking_target] = "defines.group_state.attacking_target",
    [defines.group_state.finished] = "defines.group_state.finished",
    [defines.group_state.pathfinding] = "defines.group_state.pathfinding",
    [defines.group_state.wander_in_group] = "defines.group_state.wander_in_group"
}

local DEBUG_MOVING_STATES = {
    [defines.moving_state.stale] = "defines.moving_state.stale",
    [defines.moving_state.moving] = "defines.moving_state.moving",
    [defines.moving_state.adaptive] = "defines.moving_state.adaptive",
    [defines.moving_state.stuck] = "defines.moving_state.stuck",
}

local DEBUG_COMMAND = {
    [defines.command.attack] = "defines.command.attack",
    [defines.command.go_to_location] = "defines.command.go_to_location",
    [defines.command.compound] = "defines.command.compound",
    [defines.command.group] = "defines.command.group",
    [defines.command.attack_area] = "defines.command.attack_area",
    [defines.command.wander] = "defines.command.wander",
    [defines.command.flee] = "defines.command.flee",
    [defines.command.stop] = "defines.command.stop",
    [defines.command.build_base] = "defines.command.build_base",
}

local base_build_group = {}

local CHUNK_SIZE = 32

local on_biter_base_build = function(event)
    local entity = event.entity
    if entity and entity.valid then
        BaseBuildProcessor.exec(entity)
        AttackGroupBeaconProcessor.create_spawn_beacon(entity)
    end
end

--- @TODO SPIDER AI ISSUE BYPASS, build base groups breaks.
--- Some group building base doesn't trigger on_biter_base_built nanithefuk?
local on_build_base_arrived = function(event)
    if event.group then
        BaseBuildProcessor.exec(event.group.members[1])
    end
end

local on_unit_group_created = function(event)
    local group = event.group
    local force = group.force
    local force_name = force.name
    local is_group_tracker_group = storage.group_tracker and storage.group_tracker[force_name]
    local erm_group = storage.erm_unit_groups[group.unique_id]
    
    if ForceHelper.is_enemy_force(force) then
        local scout_unit_name
        if is_group_tracker_group then
            if  group.surface.planet == nil or AttackGroupProcessor.FLYING_GROUPS[storage.group_tracker[force_name].group_type] then
                scout_unit_name = 2
            else
                scout_unit_name = 1
            end
        elseif erm_group then
            if  group.surface.planet == nil or erm_group.is_aerial then
                scout_unit_name = 2
            else
                scout_unit_name = 1
            end
        elseif TEST_MODE then
            scout_unit_name = 1
        elseif UtilHelper.can_spawn(75) then
            if group.surface.planet == nil then
                scout_unit_name = 2
            else
                scout_unit_name = 1
            end
        end

        if scout_unit_name then
            storage.scout_unit_name[group.unique_id] = {
                entity = group,
                scout_type = scout_unit_name,
                tick = game.tick
            }
        end
    end
end

local scout_type = {
    AttackGroupBeaconProcessor.LAND_SCOUT,
    AttackGroupBeaconProcessor.AERIAL_SCOUT
}

local checking_state = {
    [defines.group_state.gathering] = true,
    [defines.group_state.wander_in_group] = true,
    [defines.group_state.finished] = true
}

local on_unit_group_finished_gathering = function(event)
    --- @TODO SPIDER AI ISSUE BYPASS, build base groups breaks.
    if storage.on_unit_group_finished_gathering_build_base then
        storage.on_unit_group_finished_gathering_build_base = false    
        return
    end
    
    local group = event.group
    if not group.valid then
        return
    end

    local is_erm_group = AttackGroupProcessor.is_erm_unit_group(group.unique_id)
    if is_erm_group and storage.erm_unit_groups[group.unique_id].scout_id then
        return
    end

    local group_force = group.force

    if ForceHelper.is_enemy_force(group_force) and
        not is_erm_group and
        group.is_script_driven and
        group.command == nil and
        checking_state[group.state] and
        #group.members > 10
    then
        local target = AttackGroupHeatProcessor.pick_target(group_force.name)
        AttackGroupProcessor.process_attack_position({
            group = group,
            target_force = target,
        })

        storage.erm_unit_groups[group.unique_id] = {
            group = group,
            start_position = group.position,
            always_angry = false,
            nearby_retry = 0,
            attack_force = target,
            created = game.tick,
            is_aerial = false
        }
    end

    local scout_unit_name = storage.scout_unit_name[group.unique_id]
    if  ForceHelper.is_enemy_force(group_force) and
        (group.is_script_driven == false or is_erm_group) and
        scout_unit_name
    then
        local surface = group.surface
        local force_name = group_force.name
        storage.skip_quality_rolling = true
        local scout = surface.create_entity({
            position =  group.position,
            surface = surface,
            force = group_force,
            name = AttackGroupBeaconProcessor.get_scout_name(force_name, scout_type[scout_unit_name.scout_type], surface.name),
            count = 1
        })
        if scout then
            group.add_member(scout);
            if is_erm_group and not storage.erm_unit_groups[group.unique_id] then
                storage.erm_unit_groups[group.unique_id].scout_id = scout.unit_number
            end
        end
    end

    if scout_unit_name then
        storage.scout_unit_name[group.unique_id] = nil
    end

    --- @TODO SPIDER AI ISSUE BYPASS, build base groups breaks.
    --- er... build group always failed.  No idea the reason, probably relate to the AI bug.
    if event.group.command and event.group.command.type == defines.command.build_base and not storage.on_unit_group_finished_gathering_build_base then
        local group = event.group
        local surface = group.surface
        local force = group.force
        local command = group.command
        storage.skip_quality_rolling = true
        storage.on_unit_group_finished_gathering_build_base = true
        base_build_group[group.unique_id] = {group = group, command = command}
        --- Why does it need a tier 1 unit to make the group able to path??
        local has_level_1 = false
        for _, unit in pairs(group.members) do
            local name_token = ForceHelper.get_name_token(unit.name)
            if name_token and name_token[3] and tonumber(name_token[3]) == 1 then
                has_level_1 = true
                break
            end 
        end

        if not has_level_1 then
            local key, member = next(group.members)
            if member then
                local name_token = ForceHelper.get_name_token(member.name)
                if name_token then
                    local lvl1entity = surface.create_entity({name=name_token[1].."--"..name_token[2]..'--1',position=group.position, force=force})
                    group.add_member(lvl1entity)
                    member.destroy()
                end
            end                
        end
    end
end

--- handle scouts under ai complete
local handle_scouts = function(scout_unit_data)
    if scout_unit_data and
        scout_unit_data.can_repath and
        scout_unit_data.entity.valid
    then
        local tracker = storage.scout_tracker[scout_unit_data.force_name]
        if tracker then
            local entity = tracker.entity
            if util.distance(tracker.final_destination, entity.position) < CHUNK_SIZE then
                AttackGroupBeaconProcessor.create_attack_entity_beacon(entity)
                local target_beacon = AttackGroupBeaconProcessor.pick_attack_beacon(
                        entity.surface,
                        entity.force,
                        tracker.target_force,
                        true
                )

                if target_beacon then
                    if util.distance(tracker.final_destination, target_beacon.position) < CHUNK_SIZE then
                        scout_unit_data.can_repath = false
                        return
                    end

                    tracker["final_destination"] = target_beacon.position
                    tracker["update_tick"] = game.tick
                    scout_unit_data.entity.commandable.set_command({
                        type = defines.command.go_to_location,
                        destination = target_beacon.position,
                        radius = 16,
                        distraction = defines.distraction.none
                    })
                end
            end
        end
    end
end

--- @TODO SPIDER AI ISSUE BYPASS, break build building group
local handle_build_group = function(unit_number, event_result)
    if base_build_group == nil then
        return
    end
    
    local base_group_data = base_build_group[unit_number]
    if base_group_data then
        local group = base_group_data.group
        if group.valid and (group.moving_state  == defines.moving_state.stale or group.moving_state == defines.moving_state.stuck) then
            local surface = group.surface
            local new_group = surface.create_unit_group {position=group.position, force=group.force}
            for _, unit in pairs(group.members) do
                new_group.add_member(unit)
            end
            new_group.set_command(base_group_data.command)
            new_group.start_moving()
            base_build_group[unit_number] = nil
        end
    end
end

local nearby_retry = 3
--- handle ERM groups under ai complete
local handle_erm_groups = function(unit_number, event_result, was_distracted)
    if AttackGroupProcessor.is_erm_unit_group(unit_number) then
        local erm_unit_group = storage.erm_unit_groups[unit_number]
        local group = erm_unit_group.group
        
        AttackGroupProcessor.destroy_invalid_group(erm_unit_group.group, erm_unit_group.start_position)

        if group.valid == false then
            storage.erm_unit_groups[unit_number] = nil
            return
        end

        local moving_state_stale = (group.moving_state  == defines.moving_state.stale or group.moving_state == defines.moving_state.stuck)

        --- @TODO SPIDER AI ISSUE BYPASS, groups breaks.
        --- Reapply chain command if group moving has stale and command is wiped by spider AI.
        ---
        --- Rseding91 â€” 2024/10/28 at 4:02 PM
        --- The group members are not within the collection area of the unit group. so it makes new commands to pack them closer together.
        --- Those commands finish, which then marks the group command as done
        ---
        --- Issue tracking:
        --- https://forums.factorio.com/viewtopic.php?f=182&t=118082&p=626929#p626929
        ---
        --- and there goes some performance to copy group lol.
        if event_result ==  defines.behavior_result.fail and
                was_distracted == false and
                group.command == nil and
            (erm_unit_group.commands) and erm_unit_group.commands.type == defines.command.compound and
            moving_state_stale
        then
            local commands = erm_unit_group.commands
            local new_commands
            -- try go to last stop if the group stuck
            if group.moving_state == defines.moving_state.stuck then
                new_commands = commands.commands[table_size(commands)]
            else
                local remove_upto
                for index, command in pairs(commands.commands) do
                    if command.destination and util.distance(group.position, command.destination) < CHUNK_SIZE * 2 then
                        remove_upto = index
                        break
                    end
                end

                if remove_upto then
                    for index = remove_upto, 1, -1 do
                        table.remove(commands.commands,index)                    
                    end                        
                end

                new_commands = commands
            end

            if table_size(new_commands.commands) >= 1 then
                local new_group = group.surface.create_unit_group({ position = group.position, force = group.force })
                for _, member in pairs(group.members) do
                    new_group.add_member(member)
                end

                new_group.set_command(new_commands)
                storage.erm_unit_groups[new_group.unique_id] = util.table.deepcopy(erm_unit_group)
                storage.erm_unit_groups[new_group.unique_id].commands = new_commands
                storage.erm_unit_groups[new_group.unique_id].group = new_group
                storage.erm_unit_groups[group.unique_id] = nil
            end
        end
        --- End Bug workaround
        if event_result == defines.behavior_result.fail or
            erm_unit_group.nearby_retry >= nearby_retry
        then
            if erm_unit_group.always_angry and erm_unit_group.always_angry == true then
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    distraction = defines.distraction.by_anything,
                    target_force = erm_unit_group.attack_force,
                    new_beacon = true
                })
            else
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    target_force = erm_unit_group.attack_force,
                    new_beacon = true
                })
            end
            erm_unit_group.nearby_retry = 0
        elseif
            group.command == nil or
            group.state == defines.group_state.finished or
            event_result == defines.behavior_result.success
        then
            if erm_unit_group.always_angry and erm_unit_group.always_angry == true then
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    distraction = defines.distraction.by_anything,
                    target_force = erm_unit_group.attack_force,
                    find_nearby = true
                })
            else
                AttackGroupProcessor.process_attack_position({
                    group = group,
                    target_force = erm_unit_group.attack_force,
                    find_nearby = true
                })
            end
            erm_unit_group.nearby_retry = erm_unit_group.nearby_retry + 1
        end

        if event_result == defines.behavior_result.success and was_distracted == false then
            erm_unit_group.has_completed_command_at = group.position
        end
    end
end

local on_ai_completed = function(event)
    local unit_number = event.unit_number
    local event_result = event.result

    handle_build_group(unit_number, event_result)
    -- Hmm... Unit group doesn"t call AI complete when all its units die.  its unit triggers behaviour fails tho.
    -- Can utilize register_on_object_destroyed
    handle_erm_groups(unit_number, event_result, event.was_distracted)

    local scout_unit_data = storage.scout_by_unit_number[unit_number]
    handle_scouts(scout_unit_data)
end

--- @TODO 2.0 handle this with per planet statistic?
local function is_unit_spawner(event)
    return event.entity.type == "unit-spawner" and not ForceHelper.is_enemy_force(event.force)
end

local function handle_unit_spawner(event)
    local dead_spawner = event.entity
    AttackGroupHeatProcessor.calculate_heat(dead_spawner.force.name, dead_spawner.surface.index, event.force.index)
end


local UnitControl = {}

UnitControl.events = {
    --- This event queue up to 5 batch of units.
    [Config.custom_event_handlers[Config.EVENT_REQUEST_BASE_BUILD]] = function(event)
        local i = 0
        local limit = event.limit or 1
        if limit > 5 then
            limit = 5
        end
        repeat
            BaseBuildProcessor.build_formation(event.group)
            i = i + 1
        until #event.group.members == 0 or i == limit
    end,
    [Config.custom_event_handlers[Config.EVENT_INTERPLANETARY_ATTACK_EXEC]] = function(event)
        InterplanetaryAttacks.exec(event.force_name, event.target_force)
    end,
    [defines.events.on_entity_died] = function(event)
        if is_unit_spawner(event) then
            handle_unit_spawner(event)
        end
    end,
    --- Path finding
    [defines.events.on_script_path_request_finished] = function(event)
        AttackGroupPathingProcessor.on_script_path_request_finished(event.id, event.path, event.try_again_later)
    end,
    --- Init path finder
    [Config.custom_event_handlers[Config.EVENT_REQUEST_PATH]] = function(event)
        AttackGroupPathingProcessor.request_path(event.surface, event.source_force, event.start, event.goal, event.is_aerial, event.group_number)
    end,
    [defines.events.on_biter_base_built] = on_biter_base_build,
    [defines.events.on_build_base_arrived] = on_build_base_arrived,
    [defines.events.on_unit_group_created] = on_unit_group_created,
    [defines.events.on_unit_group_finished_gathering] = on_unit_group_finished_gathering,
    [defines.events.on_ai_command_completed] = on_ai_completed,
}

return UnitControl