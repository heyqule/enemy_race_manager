---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 2/15/2022 9:56 PM
---
local Event = require('__stdlib__/stdlib/event/event')
require('__stdlib__/stdlib/utils/defines/time')
require('__enemyracemanager__/global')

local ErmReplacementProcessor = require('lib/replacement_processor')
local ErmBaseBuildProcessor = require('lib/base_build_processor')
local ErmForceHelper = require('lib/helper/force_helper')
local ErmRaceSettingsHelper = require('lib/helper/race_settings_helper')
local ErmAttackGroupProcessor = require('lib/attack_group_processor')
local AttackGroupBeaconProcessor = require('lib/attack_group_beacon_processor')

local ErmConfig = require('lib/global_config')

local onBiterBaseBuilt = function(event)
    local entity = event.entity
    if entity and entity.valid then
        local race_name = ErmForceHelper.extract_race_name_from(entity.force.name)
        if ErmConfig.race_is_active(race_name) then
            local replaced_entity = ErmReplacementProcessor.replace_entity(entity.surface, entity, global.race_settings, entity.force.name)
            if replaced_entity and replaced_entity.valid then
                ErmBaseBuildProcessor.exec(replaced_entity)
            end
        end

        AttackGroupBeaconProcessor.create_spawn_beacon(entity)
    end
end

local onUnitGroupCreated = function(event)
    local group = event.group
    local force = group.force
    if ErmForceHelper.is_enemy_force(force) then
        local surface = group.surface
        local racename = ErmForceHelper.extract_race_name_from(force.name)
        local scout = surface.create_entity({
            position =  group.position,
            surface = surface,
            force = force,
            name = racename..AttackGroupBeaconProcessor.LAND_SCOUT,
            count = 1
        })
        group.add_member(scout);
    end
end

local onUnitFinishGathering = function(event)

end

---
--- Destroy group members and refund them as attack points.
---
local destroyMembers = function(group)
    local members = group.members
    local refundPoints = 0
    for _, member in pairs(members) do
        member.destroy()
        refundPoints = refundPoints + ErmAttackGroupProcessor.MIXED_UNIT_POINTS
    end

    local race_name = ErmForceHelper.extract_race_name_from(group.force.name)

    if ErmConfig.race_is_active(race_name) then
        ErmRaceSettingsHelper.add_to_attack_meter(race_name, refundPoints)
    end
    group.destroy()
end

---
--- Clean up cache table, destroy groups that has less than 5 units.
---
local ermGroupCacheTableCleanup = function(target_table)
    local tmp = {}
    for _, group_data in pairs(target_table) do
        if group_data and group_data.valid
                and group_data.group and group_data.group.valid
        then
            local group = group_data.group
            if #group.members >= 5 then
                tmp[group.group_number] = group_data
            else
                destroyMembers(group)
            end
        end
    end
    target_table = tmp

    return target_table
end

local isErmUnitGroup = function(unit_number)
    local erm_unit_groups = global.erm_unit_groups
    return erm_unit_groups[unit_number] and erm_unit_groups[unit_number].group and erm_unit_groups[unit_number].group.valid
end

---
--- Destroy group if the group doesn't have a valid path
---
local destroyInvalidGroup = function(group, start_position)
    if group.valid and
            group.is_script_driven and
            group.command == nil and
            (start_position.x == group.position.x and start_position.y == group.position.y) and
            ErmForceHelper.is_enemy_force(group.force)
    then
        destroyMembers(group)
    end
end

---
---1 = defines.behavior_result.in_progress
---2 = defines.behavior_result.fail
---3 = defines.behavior_result.success
---4 = defines.behavior_result.deleted
---
local onAiCompleted = function(event)
    local erm_unit_groups = global.erm_unit_groups
    local unit_number = event.unit_number
    if isErmUnitGroup(unit_number) then
        local group = erm_unit_groups[unit_number].group

        destroyInvalidGroup(group, erm_unit_groups[unit_number].start_position)

        if group.valid and
            (group.command == nil or
            group.state == defines.group_state.finished or
            event.result == defines.behavior_result.success)
        then
            if erm_unit_groups.always_angry and erm_unit_groups.always_angry == true then
                ErmAttackGroupProcessor.process_attack_position(group, defines.distraction.by_anything, true)
            else
                ErmAttackGroupProcessor.process_attack_position(group, nil, true)
            end
        end

        if (event.tick - global.tick >= ErmConfig.CONFIG_CACHE_LENGTH) then
            local group_count = table_size(erm_unit_groups)
            if group_count > ErmConfig.CONFIG_CACHE_SIZE then
                global.erm_unit_groups = ermGroupCacheTableCleanup(erm_unit_groups)
            end
        end
    end
end

--- Unit processing events
Event.register(defines.events.on_biter_base_built, onBiterBaseBuilt)

Event.register(defines.events.on_unit_group_created, onUnitGroupCreated)

Event.register(defines.events.on_unit_group_finished_gathering, onUnitFinishGathering)

Event.register(defines.events.on_ai_command_completed, onAiCompleted)