---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 1/13/2024 12:19 PM
---

local AttackGroupBeaconProcessor = require('__enemyracemanager__/lib/attack_group_beacon_processor')
local AttackGroupPathingProcessor = require('__enemyracemanager__/lib/attack_group_pathing_processor')
local AttackGroupProcessor = require('__enemyracemanager__/lib/attack_group_processor')
local TestShared = require('shared')

before_each(function()
    TestShared.prepare_the_factory()
end)

after_each(function()
    TestShared.reset_the_factory()
    TestShared.reset_lab_tile()
end)

local DEFAULT_DIMENSION  = 192
local RIVER_WIDTH  = 16
local GATE_WIDTH  = 64

local top_horizontal_river = function(surface, dimension, riverwidth, has_gate, gatewidth)
    local water_tiles = {}
    dimension = dimension or DEFAULT_DIMENSION
    riverwidth = riverwidth or RIVER_WIDTH
    gatewidth = gatewidth or GATE_WIDTH
    has_gate = has_gate or false
    surface = surface or game.surfaces[1]

    if has_gate then
        for y= (dimension * -1), (dimension - riverwidth) * -1, 1 do
            for x = (dimension * -1), (dimension * -1) + (dimension - gatewidth), 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end

        for y= (dimension * -1), (dimension - riverwidth) * -1, 1 do
            for x = (dimension) - (dimension - gatewidth), dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    else
        for y= (dimension * -1), (dimension - riverwidth) * -1, 1 do
            for x = dimension * -1, dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    end

    if next(water_tiles) then
        surface.set_tiles(water_tiles)
    end
end

local function bottom_horizontal_river(surface, dimension, riverwidth, has_gate, gatewidth)
    local water_tiles = {}
    dimension = dimension or DEFAULT_DIMENSION
    riverwidth = riverwidth or RIVER_WIDTH
    gatewidth = gatewidth or GATE_WIDTH
    has_gate = has_gate or false
    surface = surface or game.surfaces[1]

    if has_gate then
        for y = dimension - riverwidth, dimension, 1 do
            for x = (dimension * -1), (dimension * -1) + (dimension - gatewidth), 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end

        for y = dimension - riverwidth, dimension, 1 do
            for x= (dimension) - (dimension - gatewidth), dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    else
        for y = dimension - riverwidth, dimension, 1 do
            for x= dimension * -1, dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    end

    if next(water_tiles) then
        surface.set_tiles(water_tiles)
    end
end

local function left_vertical_river(surface, dimension, riverwidth, has_gate, gatewidth)
    local water_tiles = {}
    dimension = dimension or DEFAULT_DIMENSION
    riverwidth = riverwidth or RIVER_WIDTH
    gatewidth = gatewidth or GATE_WIDTH
    has_gate = has_gate or false
    surface = surface or game.surfaces[1]

    if has_gate then
        for y = (dimension * -1), (dimension * -1) + (dimension - gatewidth), 1 do
            for x=(dimension * -1), (dimension * -1) + riverwidth, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end

        for y = (dimension) - (dimension - gatewidth), dimension, 1 do
            for x=(dimension * -1), (dimension * -1 ) + riverwidth, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    else
        for y = (dimension * -1), dimension, 1 do
            for x=(dimension * -1), (dimension * -1 ) + riverwidth, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    end

    if next(water_tiles) then
        surface.set_tiles(water_tiles)
    end
end

local function right_vertical_river(surface, dimension, riverwidth, has_gate, gatewidth)
    local water_tiles = {}
    dimension = dimension or DEFAULT_DIMENSION
    riverwidth = riverwidth or RIVER_WIDTH
    gatewidth = gatewidth or GATE_WIDTH
    has_gate = has_gate or false
    surface = surface or game.surfaces[1]

    if has_gate then
        for y = (dimension * -1), (dimension * -1) + (dimension - gatewidth), 1 do
            for x=dimension - riverwidth, dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end

        for y = (dimension) - (dimension - gatewidth), dimension, 1 do
            for x=dimension - riverwidth, dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    else
        for y=(dimension * -1), dimension, 1 do
            for x=dimension - riverwidth, dimension, 1 do
                table.insert(water_tiles, {name = "water", position={x,y}})
            end
        end
    end

    if next(water_tiles) then
        surface.set_tiles(water_tiles)
    end
end

local function buildBaseNoOpen(options)
    options = options or {}
    local dimension = options["dimension"] or DEFAULT_DIMENSION
    local riverwidth = options["riverwidth"] or RIVER_WIDTH
    local gatewidth = options["gatewidth"] or GATE_WIDTH
    local surface = options["surface"] or game.surfaces[1]
    top_horizontal_river(surface, dimension, riverwidth, false, gatewidth)
    bottom_horizontal_river(surface, dimension, riverwidth, false, gatewidth)
    left_vertical_river(surface, dimension, riverwidth, false, gatewidth)
    right_vertical_river(surface, dimension, riverwidth, false, gatewidth)
end

local function buildBaseWithWestDefense(options)
    options = options or {}
    local dimension = options["dimension"] or DEFAULT_DIMENSION
    local riverwidth = options["riverwidth"] or RIVER_WIDTH
    local gatewidth = options["gatewidth"] or GATE_WIDTH
    local surface = options["surface"] or game.surfaces[1]

    -- (-) Top horizontal
    top_horizontal_river(surface, dimension, riverwidth, false, gatewidth)
    bottom_horizontal_river(surface, dimension, riverwidth, false, gatewidth)
    left_vertical_river(surface, dimension, riverwidth, true, gatewidth)
    right_vertical_river(surface, dimension, riverwidth, false, gatewidth)

    -- build walls
    for y = (dimension * -1) + (dimension - gatewidth), (dimension) - (dimension - gatewidth), 1 do
        for x=(dimension * -1), (dimension * -1) + 3, 1 do
            surface.create_entity({name="stone-wall",position={x,y},  force = 'player'})
        end

        if y%2 == 0 then
            surface.create_entity({name="laser-turret",position={(dimension * -1)+6,y}, force = 'player'})
        end
        if y%2 == 0 then
            surface.create_entity({name="gun-turret",position={(dimension * -1)+8,y}, force = 'player'})
        end
        if y%2 == 0 then
            local inserter = surface.create_entity({name="stack-inserter",position={(dimension * -1)+9,y}, force = 'player'})
            inserter.direction = defines.direction.east
        end
        if y%2 == 0 then
            local chest = surface.create_entity({name="infinity-chest",position={(dimension * -1)+10,y}, force = 'player'})
            chest.set_infinity_container_filter(1, {
                name = 'uranium-rounds-magazine',
                count = 100,
                mode = 'exactly'
            })
            chest.minable = false
            chest.rotatable = false
            chest.operable = false
        end

        if y%10 == 0 then
            surface.create_entity({name="substation",position={(dimension * -1)+12,y}, force = 'player'})
        end
        if y%10 == 0 then
            surface.create_entity({name="electric-energy-interface",position={(dimension * -1)+14,y}, force = 'player'})
        end
    end
end

local function buildBaseWithWestDefenseNorthOpen(options)
    options = options or {}
    local dimension = options["dimension"] or DEFAULT_DIMENSION
    local riverwidth = options["riverwidth"] or RIVER_WIDTH
    local gatewidth = options["gatewidth"] or GATE_WIDTH
    local surface = options["surface"] or game.surfaces[1]

    -- (-) Top horizontal
    top_horizontal_river(surface, dimension, riverwidth, true, gatewidth)
    bottom_horizontal_river(surface, dimension, riverwidth, false, gatewidth)
    left_vertical_river(surface, dimension, riverwidth, true, gatewidth)
    right_vertical_river(surface, dimension, riverwidth, false, gatewidth)

    -- build walls
    for y = (dimension * -1) + (dimension - gatewidth), (dimension) - (dimension - gatewidth), 1 do
        for x=(dimension * -1), (dimension * -1) + 3, 1 do
            surface.create_entity({name="stone-wall",position={x,y},  force = 'player'})
        end

        if y%2 == 0 then
            surface.create_entity({name="laser-turret",position={(dimension * -1)+6,y}, force = 'player'})
        end
        if y%2 == 0 then
            surface.create_entity({name="gun-turret",position={(dimension * -1)+8,y}, force = 'player'})
        end
        if y%2 == 0 then
            local inserter = surface.create_entity({name="stack-inserter",position={(dimension * -1)+9,y}, force = 'player'})
            inserter.direction = defines.direction.east
        end
        if y%2 == 0 then
            local chest = surface.create_entity({name="infinity-chest",position={(dimension * -1)+10,y}, force = 'player'})
            chest.set_infinity_container_filter(1, {
                name = 'uranium-rounds-magazine',
                count = 100,
                mode = 'exactly'
            })
            chest.minable = false
            chest.rotatable = false
            chest.operable = false
        end

        if y%10 == 0 then
            surface.create_entity({name="substation",position={(dimension * -1)+12,y}, force = 'player'})
        end
        if y%10 == 0 then
            surface.create_entity({name="electric-energy-interface",position={(dimension * -1)+14,y}, force = 'player'})
        end
    end
end

local function entity_is_damage(entity)
    return entity.valid == false or entity.get_health_ratio() < 1
end


describe.only("Attack Pathing", function()
    it("Can't avoid land Beacon, all enemies killed by turrets", function()
        async(7200)
        local surface = game.surfaces[1]
        local enemy = game.forces['enemy']
        local player = game.forces['player']

        -- Require generated chunks
        surface.request_to_generate_chunks({ 0, 0 }, 20)
        surface.force_generate_chunk_requests()

        buildBaseWithWestDefense()

        local rocket_launcher = surface.create_entity({ name = 'rocket-silo', force = 'player', position = { 0, 0 } })
        local success = AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, { { -20, -20 }, { 20, 20 } })

        surface.create_entity({name='erm_vanilla/biter-spawner/10', position={-500,0}})
        AttackGroupBeaconProcessor.init_index()

        local entity = surface.create_entity({ name = 'erm_vanilla/land_scout', force = 'enemy', position = { -200, -40 } })

        local entity = surface.create_entity({ name = 'erm_vanilla/land_scout', force = 'enemy', position = { -200, 40 } })

        after_ticks(300, function()
            AttackGroupProcessor.generate_group('erm_vanilla',game.forces['enemy'], 100, AttackGroupProcessor.GROUP_TYPE_MIXED)
        end)

        after_ticks(7200, function()
            assert(rocket_launcher.get_health_ratio() == 1, 'Enemy should not able to attack target')
            done()
        end)
    end)

    it("Aerial Attack", function()
        async(7200)
        local surface = game.surfaces[1]
        local enemy = game.forces['enemy']
        local player = game.forces['player']
        -- Require generated chunks
        surface.request_to_generate_chunks({ 0, 0 }, 20)
        surface.force_generate_chunk_requests()
        buildBaseNoOpen()

        local rocket_launcher = surface.create_entity({ name = 'rocket-silo', force = 'player', position = { 0, 0 } })
        local success = AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, { { -20, -20 }, { 20, 20 } })

        surface.create_entity({name='erm_vanilla/biter-spawner/10', position={-500,0}})
        AttackGroupBeaconProcessor.init_index()

        after_ticks(300, function()
            AttackGroupProcessor.generate_group('erm_vanilla',game.forces['enemy'], 50, AttackGroupProcessor.GROUP_TYPE_FLYING)
        end)

        after_ticks(7200, function()
            assert(entity_is_damage(rocket_launcher), 'Enemy can attack target')
            done()
        end)
    end)

    it.only("Avoid Defence Beacon (Ground Attack)", function()
        async(7200)
        local surface = game.surfaces[1]
        local enemy = game.forces['enemy']
        local player = game.forces['player']

        -- Require generated chunks
        surface.request_to_generate_chunks({ 0, 0 }, 20)
        surface.force_generate_chunk_requests()

        buildBaseWithWestDefenseNorthOpen()

        local rocket_launcher = surface.create_entity({ name = 'rocket-silo', force = 'player', position = { 0, 0 } })
        local success = AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, { { -20, -20 }, { 20, 20 } })

        surface.create_entity({name='erm_vanilla/biter-spawner/10', position={-500,0}})
        AttackGroupBeaconProcessor.init_index()

        local entity = surface.create_entity({ name = 'erm_vanilla/land_scout', force = 'enemy', position = { -200, -40 } })

        local entity = surface.create_entity({ name = 'erm_vanilla/land_scout', force = 'enemy', position = { -200, 40 } })

        after_ticks(300, function()
            AttackGroupProcessor.generate_group('erm_vanilla',game.forces['enemy'], 100, AttackGroupProcessor.GROUP_TYPE_MIXED)
        end)

        after_ticks(7200, function()
            assert(entity_is_damage(rocket_launcher), 'Able to attack target')
            done()
        end)
    end)

    it("Avoid Defence Beacon (Aerial Attack)", function()
        async(7200)
        local surface = game.surfaces[1]
        local enemy = game.forces['enemy']
        local player = game.forces['player']

        -- Require generated chunks
        surface.request_to_generate_chunks({ 0, 0 }, 20)
        surface.force_generate_chunk_requests()

        buildBaseWithWestDefense()

        local rocket_launcher = surface.create_entity({ name = 'rocket-silo', force = 'player', position = { 0, 0 } })
        local success = AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, { { -20, -20 }, { 20, 20 } })

        surface.create_entity({name='erm_vanilla/biter-spawner/10', position={-500,0}})
        AttackGroupBeaconProcessor.init_index()

        local entity = surface.create_entity({ name = 'erm_vanilla/aerial_scout', force = 'enemy', position = { -200, -40 } })

        local entity = surface.create_entity({ name = 'erm_vanilla/aerial_scout', force = 'enemy', position = { -200, 40 } })

        after_ticks(300, function()
            AttackGroupProcessor.generate_group('erm_vanilla',game.forces['enemy'], 100, AttackGroupProcessor.GROUP_TYPE_FLYING)
        end)

        after_ticks(7200, function()
            assert(entity_is_damage(rocket_launcher), 'Flyers are able to attack target')
            done()
        end)
    end)
end)