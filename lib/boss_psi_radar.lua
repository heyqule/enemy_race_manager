---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 4/22/2025 9:45 PM
---

local Direction = require("__erm_libs__/stdlib/direction")

local BossProcessor = require("__enemyracemanager__/lib/boss_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")
local Config = require("__enemyracemanager__/lib/global_config")
local UtilHelper = require("__enemyracemanager__/lib/helper/util_helper")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")

local chunksize = 32
local max_range = 35
local offset = 3
local max_side_range = max_range - offset
local boss_roll_start_range = 25
local BossPsiRadar = {}

function BossPsiRadar.register(radar)
    local boss_data = storage.boss
    if radar and radar.valid then
        if boss_data and boss_data.radar then
            local registered_radar = boss_data.radar
            if registered_radar.valid then
                local gps_msg = UtilHelper.get_gps_message(
                        registered_radar.position.x,
                        registered_radar.position.y,
                        registered_radar.surface.name
                )
                BossPsiRadar.reject('Boss radar already placed '..gps_msg, radar)
            else
                BossPsiRadar.reject('Deteched boss placement anomaly. Please try again.  If problem persist, please notify mod author.')
            end
            return
        end
        -- boss radar print
        boss_data.radar = radar
        boss_data.radar_position = radar.position
        storage.boss_radar_iteration = 1
        storage.boss_radar_side_iteration = 1
        Cron.add_15_sec_queue("BossPsiRadar.scan")
    end
end

function BossPsiRadar.scan()
    if not storage.boss or 
       not storage.boss.radar then
        return
    end
    
    local radar = storage.boss.radar
    if not radar.valid then
        return
    end
    local iteration = storage.boss_radar_iteration
    local side_iteration = storage.boss_radar_side_iteration
    local radar_position = storage.boss.radar.position

    local surface = radar.surface

    if radar.status ~= defines.entity_status.working then
        if storage.boss.entity == nil then
            Cron.add_15_sec_queue("BossPsiRadar.scan")
        end
        return
    end

    local name_tokens = ForceHelper.get_name_token(radar.name)
    local force_name = name_tokens[1]
    local area = Direction.which_area(radar_position)
    local multiplier = Direction.multipliers[area]

    local scan_positions
    if iteration < 30 then
        --- regular scan
        scan_positions = {
            {
                x = radar_position.x + multiplier[1] * chunksize * (iteration - offset),
                y = radar_position.y
            },
            {
                x = radar_position.x + multiplier[1] * chunksize * iteration,
                y = radar_position.y + multiplier[2] * chunksize * iteration
            },
            {
                x = radar_position.x,
                y = radar_position.y + multiplier[2] * chunksize * (iteration - offset)
            }
        }
    else
        --- far side scan
        if area == defines.direction.southwest or area == defines.direction.northeast then
            scan_positions = {
                {
                    x = radar_position.x + multiplier[1] * chunksize * (iteration - offset),
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x - multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * (iteration - offset)
                },
                {
                    x = radar_position.x + multiplier[1] * chunksize * 30,
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x - multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * 30
                }
            }
        else
            scan_positions = {
                {
                    x = radar_position.x + multiplier[1] * chunksize * (iteration - offset),
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x + multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * (iteration - offset)
                },
                {
                    x = radar_position.x + multiplier[1] * chunksize * 30,
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x + multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * 30
                },
            }
        end
    end

    local scan_area_size = chunksize * 2
    for _, scan_position in pairs(scan_positions) do
        if not surface.is_chunk_generated(scan_position) then
            local scan_area = {
                {x = scan_position.x - scan_area_size, y = scan_position.y - scan_area_size}, 
                {x = scan_position.x + scan_area_size, y = scan_position.y + scan_area_size}
            }
            radar.force.chart(surface, scan_area)
            if iteration >= boss_roll_start_range then
                local has_spawner = surface.find_entities_filtered({
                    name="erm_spawn_beacon", 
                    area=scan_area, 
                    force=force_name
                })
                if has_spawner[1] then
                    storage.boss.spawn_beacons[has_spawner[1].unit_number] = has_spawner[1]
                end
            end
        end
        storage.boss_final_scanned_position = scan_position
    end

    iteration = iteration + 1
    if iteration >= max_range then
        iteration = max_range
        if side_iteration <= max_range then
            side_iteration = side_iteration + 1
        end
    end
    storage.boss_radar_iteration = iteration
    storage.boss_radar_side_iteration = side_iteration

    local skip_cron = false
    if iteration >= max_range and side_iteration >= max_side_range then
        storage.boss_radar_iteration = 1
        storage.boss_radar_side_iteration = 1
        skip_cron = true
        BossPsiRadar.find_spawn_location(radar)
    end

    if not skip_cron then
        Cron.add_15_sec_queue("BossPsiRadar.scan")
    end
end

function BossPsiRadar.reject(message, radar)
    local radar = radar or storage.boss.radar
    if radar and radar.last_user then
        radar.last_user.insert { name = radar.name, count = 1 }
        radar.last_user.print(message)
        radar.destroy()
    else
        radar.surface.print(message)
        radar.destroy()
    end

    storage.boss = BossProcessor.get_init_boss_setting()
end

function BossPsiRadar.find_spawn_location(radar)
    local found = false
    for i = 1, 5, 1 do
        for _, beacon in pairs(storage.boss.spawn_beacons) do
            local can_spawn = UtilHelper.can_spawn(33)
            if can_spawn then
                if BossProcessor.exec(radar, beacon.position) then
                    found = true
                    break
                end
            end
        end

        if found then
            break
        end
    end

    if not found then
        BossPsiRadar.reject('Unable to locate boss.  Radar refund back to user inventory')
    end
end

return BossPsiRadar