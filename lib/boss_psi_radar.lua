---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 4/22/2025 9:45 PM
---

local Direction = require("__erm_libs__/stdlib/direction")

local BossProcessor = require("__enemyracemanager__/lib/boss_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")
local Config = require("__enemyracemanager__/lib/global_config")
local UtilHelper = require("__enemyracemanager__/lib/helper/util_helper")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")

local chunksize = 32
local max_range = 35
local offset = 3
local max_side_range = max_range - offset
local boss_roll_start_range = 25
local iteration = 1
local side_iteration = 1
local BossPsiRadar = {}

function BossPsiRadar.register(radar)
    local boss_data =  storage.boss
    if radar and radar.valid then
        if boss_data.radar then
            local registered_radar = boss_data.radar
            local gps_msg = UtilHelper.get_gps_message(
                    registered_radar.position.x,
                    registered_radar.position.y,
                    registered_radar.surface.name
            )
            BossPsiRadar.reject('Boss radar already existed '..gps_msg, radar)
            return
        end
        -- boss radar print
        print('Valid radar...')
        boss_data.radar = radar
        boss_data.radar_position = radar.position
        iteration = 1
        side_iteration = 1
        chunksize = 32
        Cron.add_15_sec_queue("BossPsiRadar.scan")
    end
end

function BossPsiRadar.scan()
    -- boss radar print
    print('PSI Radar scanning')
    local radar = storage.boss.radar
    local radar_position = storage.boss.radar.position
    if not radar and not radar.valid then
        return
    end

    local surface = radar.surface

    if not radar.status == defines.entity_status.working then
        if storage.boss.entity == nil then
            Cron.add_15_sec_queue("BossPsiRadar.scan")
        end
        return
    end

    local name_tokens = ForceHelper.get_name_token(radar.name)
    local force_name = name_tokens[1]
    local area = Direction.which_area(radar_position)
    local multiplier = Direction.multipliers[area]

    local scan_positions
    if iteration < 30 then
        --- regular scan
        scan_positions = {
            {
                x = radar_position.x + multiplier[1] * chunksize * (iteration - offset),
                y = radar_position.y
            },
            {
                x = radar_position.x + multiplier[1] * chunksize * iteration,
                y = radar_position.y + multiplier[2] * chunksize * iteration
            },
            {
                x = radar_position.x,
                y = radar_position.y + multiplier[2] * chunksize * (iteration - offset)
            }
        }
    else
        --- far side scan
        if area == defines.direction.southwest or area == defines.direction.northeast then
            scan_positions = {
                {
                    x = radar_position.x + multiplier[1] * chunksize * (iteration - offset),
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x - multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * (iteration - offset)
                },
                {
                    x = radar_position.x + multiplier[1] * chunksize * 30,
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x - multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * 30
                }
            }
        else
            scan_positions = {
                {
                    x = radar_position.x + multiplier[1] * chunksize * (iteration - offset),
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x + multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * (iteration - offset)
                },
                {
                    x = radar_position.x + multiplier[1] * chunksize * 30,
                    y = radar_position.y + multiplier[2] * chunksize * (side_iteration),
                },
                {
                    x = radar_position.x + multiplier[2] * chunksize * (side_iteration),
                    y = radar_position.y + multiplier[2] * chunksize * 30
                },
            }
        end
    end

    local scan_area_size = chunksize * 2
    for _, scan_position in pairs(scan_positions) do
        if not surface.is_chunk_generated(scan_position) then
            local scan_area = {
                {x = scan_position.x - scan_area_size, y = scan_position.y - scan_area_size}, 
                {x = scan_position.x + scan_area_size, y = scan_position.y + scan_area_size}
            }
            radar.force.chart(surface, scan_area)
            if iteration >= boss_roll_start_range then
                local has_spawner = surface.find_entities_filtered({
                    name="erm_spawn_beacon", 
                    area=scan_area, 
                    force=force_name
                })
                if has_spawner[1] then
                    storage.boss.spawn_beacons[has_spawner[1].unit_number] = has_spawner[1]
                end
            end
        end
    end

    iteration = iteration + 1
    if iteration >= max_range then
        iteration = max_range
        if side_iteration <= max_range then
            side_iteration = side_iteration + 1
        end
    end

    local skip_cron = false
    if iteration >= max_range and side_iteration >= max_side_range then
        skip_cron = true

        local found = false
        for i = 1, 3, 1 do
            for _, beacon in pairs(storage.boss.spawn_beacons) do
                local can_spawn = UtilHelper.can_spawn(33)
                if can_spawn then
                    BossProcessor.exec(radar, beacon.position)
                    found = true
                    break
                end
            end

            if found then
                break
            end
        end

        if not found then
            --- Show message.
            --- destroy radar
            --- unset boss data
            BossPsiRadar.reject('Unable to locate boss.  Radar refund back to your inventory')
        end
    end

    if not skip_cron then
        Cron.add_15_sec_queue("BossPsiRadar.scan")
    end
end

function BossPsiRadar.reject(message, radar)
    local radar = radar or storage.boss.radar
    if radar then
        radar.last_user.insert { name = radar.name, count = 1 }
        radar.last_user.print(message)
        radar.destroy()
    else
        radar.last_user.print(message)
        radar.destroy()
        storage.boss.radar = nil
        storage.boss.position = nil
        storage.boss.spawn_beacons = {}
    end
end

return BossPsiRadar