---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/16/2022 2:58 PM
---
require("util")


local Position = require("__erm_libs__/stdlib/position")
local GlobalConfig = require("__enemyracemanager__/lib/global_config")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local SurfaceProcessor = require("__enemyracemanager__/lib/surface_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")
local BossGroupProcessor = require("__enemyracemanager__/lib/boss_group_processor")
local BossAttackProcessor = require("__enemyracemanager__/lib/boss_attack_processor")
local BaseBuildProcessor = require("__enemyracemanager__/lib/base_build_processor")
local BossRewardProcessor = require("__enemyracemanager__/lib/boss_reward_processor")
local BossDespawnProcessor = require("__enemyracemanager__/lib/boss_despawn_processor")

local GuiContainer = require("__enemyracemanager__/gui/main")

local DebugHelper = require("__enemyracemanager__/lib/debug_helper")

local BossProcessor = {}

-- beam scan up to 100 chunks
local scanLength = GlobalConfig.BOSS_ARTILLERY_SCAN_RANGE
-- 7 chunks
local scanMinLength = 224
local scanRadius = 16

local chunkSize = 32
local spawnRadius = 64
local cleanChunkSize = 8
local maxRetry = 3

local INCLUDE_SPAWNS = true -- Only for debug

local enemy_entities = { "unit-spawner", "turret", "unit" }
local enemy_buildings = { "unit-spawner", "turret" }
local turrets = { "ammo-turret", "electric-turret", "fluid-turret" }
local indexable_turrets = { "ammo-turret", "fluid-turret" }
local beacon_name = "erm-boss-beacon"

local boss_setting_default = function()
    return {
        entity = nil,
        entity_name = "",
        entity_position = nil,
        target_position = { x = 0, y = 0 },
        target_direction = defines.direction.north,
        silo_position = { x = 0, y = 0 },
        surface = nil,
        surface_name = "",
        race_name = "",
        force = nil,
        force_name = "",
        boss_tier = 1,
        flying_only = false,
        spawned_tick = 0,
        despawn_at_tick = 0,
        pathing_entity = nil,
        pathing_entity_checks = 0,
        attack_last_hp = { 0, 0, 0, 0, 0, 0 },
        victory = false,
        high_level_enemy_list = nil, -- Track all high level enemies, they die when the base destroys.
        loading = false
    }
end

local boss_spawnable_index_default = function()
    return {
        chunks = {},
        size = 0,
        retry = 0
    }
end

local index_boss_spawnable_chunk = function(gunturret, area, usefirst)
    local surface = gunturret.surface
    local spawners = surface.find_entities_filtered { type = enemy_buildings, force = storage.boss.force, area = area, limit = 20 }

    local target_spawner
    local last = #spawners
    if gunturret.direction == defines.direction.east or
            gunturret.direction == defines.direction.north
    then
        target_spawner = spawners[1]
    else
        target_spawner = spawners[last]
    end

    if target_spawner then
        -- Skip if it"too close to any of the turrets
        local turret = surface.find_entities_filtered { position = target_spawner.position, radius = 192, type = turrets, limit = 1 }
        if turret[1] then
            return
        end
        local distance = util.distance(target_spawner.position, gunturret.position)
        table.insert(storage.boss_spawnable_index.chunks, {
            spawn_position = target_spawner.position,
            turret_position = gunturret.position,
            distance = distance
        })
        if storage.boss_spawnable_index.closest_distance > distance then
            storage.boss_spawnable_index.closest_distance = distance
        end
        storage.boss_spawnable_index.size = storage.boss_spawnable_index.size + 1
    end
end

local start_unit_spawn = function()
    Cron.add_15_sec_queue("BossProcessor.units_spawn")
    Cron.add_1_min_queue("BossProcessor.support_structures_spawn")
    Cron.add_15_sec_queue("BossGroupProcessor.process_attack_groups")
    if INCLUDE_SPAWNS then
        BossGroupProcessor.spawn_initial_group()
    end
end

local process_boss_queue = function(event)
    Cron.process_boss_queue()
end

local start_boss_event = function()
    script.on_nth_tick(GlobalConfig.BOSS_QUEUE_CRON, process_boss_queue)
end

local remove_boss_event = function()
    script.on_nth_tick(GlobalConfig.BOSS_QUEUE_CRON, nil)
    Cron.empty_boss_queue()
end

local get_scan_area = {
    [defines.direction.north] = function(x, y)
        return { left_top = { x - scanRadius, y - scanLength }, right_bottom = { x + scanRadius, y - scanMinLength } }
    end,
    [defines.direction.east] = function(x, y)
        return { left_top = { x + scanMinLength, y - scanRadius }, right_bottom = { x + scanLength, y + scanRadius } }
    end,
    [defines.direction.south] = function(x, y)
        return { left_top = { x - scanRadius, y + scanMinLength }, right_bottom = { x + scanRadius, y + scanLength } }
    end,
    [defines.direction.west] = function(x, y)
        return { left_top = { x - scanLength, y - scanRadius }, right_bottom = { x - scanMinLength, y + scanRadius } }
    end,
}

local get_target_direction = function(spawn_position, target_position)
    local diffThreshold = chunkSize * 3
    local direction = defines.direction.south
    if (spawn_position.x - target_position.x) > diffThreshold then
        direction = defines.direction.west
    elseif ((spawn_position.x - target_position.x) < (diffThreshold * -1)) then
        direction = defines.direction.east
    elseif ((spawn_position.y - target_position.y) > diffThreshold) then
        direction = defines.direction.north
    end

    if DEBUG_MODE then
        local directionText = { ["0"] = "North", ["2"] = "East", ["4"] = "South", ["6"] = "West" }
        DebugHelper.print("BossProcessor: Targeting Direction: " .. directionText[tostring(direction)])
        DebugHelper.print(serpent.block(spawn_position))
        DebugHelper.print(serpent.block(target_position))
    end

    return direction
end

local can_build_spawn_building = function()
    local boss_tier = storage.boss.boss_tier
    local nearby_buildings = storage.boss.surface.find_entities_filtered({
        position = storage.boss.entity_position,
        radius = spawnRadius,
        type = enemy_buildings,
        force = storage.boss.force
    })
    if #nearby_buildings >= GlobalConfig.BOSS_MAX_SUPPORT_STRUCTURES[boss_tier] then
        return false
    end

    return true
end

local spawn_building = function()
    if not can_build_spawn_building() then
        return
    end

    local boss = storage.boss
    local boss_tier = boss.boss_tier
    for i = 1, GlobalConfig.BOSS_SPAWN_SUPPORT_STRUCTURES[boss_tier] do
        local building_name
        if RaceSettingsHelper.can_spawn(7) then
            building_name = BaseBuildProcessor.getBuildingName(boss.race_name, "cc")
        elseif RaceSettingsHelper.can_spawn(45) then
            building_name = BaseBuildProcessor.getBuildingName(boss.race_name, "support")
        else
            building_name = BaseBuildProcessor.getBuildingName(boss.race_name, "turret")
        end

        BaseBuildProcessor.build(
                boss.surface,
                building_name,
                boss.force_name,
                boss.entity_position
        )
    end
end

local destroy_beacons = function()
    local beacons = storage.boss.surface.find_entities_filtered { name = beacon_name, type = "radar" }
    for i = 1, #beacons do
        beacons[i].destroy()
    end
end

local unset_boss_data = function()
    storage.boss = boss_setting_default()
    for _, spawn_data in pairs(storage.boss_attack_groups) do
        Cron.add_quick_queue("BossProcessor.remove_boss_groups", spawn_data)
    end

    Cron.add_quick_queue("BossProcessor.remove_boss_groups", storage.boss_group_spawn)

    storage.boss_attack_groups = {}
    storage.boss_group_spawn = BossGroupProcessor.get_default_data()
    storage.boss_spawnable_index = boss_spawnable_index_default()
    remove_boss_event()
end

local spawn_unit_attack = function()
    if INCLUDE_SPAWNS then
        BossGroupProcessor.spawn_defense_group()
    end
    return false, true
end

local spawn_base_attack = function()
    if INCLUDE_SPAWNS then
        spawn_building()
    end
    return false, true
end

local basic_attack = function()
    BossAttackProcessor.exec_basic()
    return true, false
end

local advanced_attack = function()
    BossAttackProcessor.exec_advanced()
    return true, false
end

local super_attack = function()
    BossAttackProcessor.exec_super()
    return true, false
end

local phase_change = function()
    return false, false
end

--- Phase change + 5 attacks
local attack_functions = {
    phase_change,
    super_attack,
    spawn_unit_attack,
    spawn_base_attack,
    advanced_attack,
    basic_attack
}

local draw_time = function(boss, current_tick)
    local datetime_str = GlobalConfig.format_daytime_string(current_tick, boss.despawn_at_tick)

    rendering.draw_text({
        text = { "description.boss-despawn-in", datetime_str },
        surface = boss.surface_name,
        target = boss.entity,
        target_offset = { -3.5, -8 },
        color = { r = 1, g = 0, b = 0 },
        time_to_live = GlobalConfig.TWO_SECONDS_CRON,
        scale = 2,
        only_in_alt_mode = true
    })
end

local initialize_result_log = function(race_name, difficulty, squad_size)
    local default_best_record = {
        tier = 1,
        time = -1,
    }
    if storage.boss_logs[race_name] == nil then
        storage.boss_logs[race_name] = {
            difficulty = difficulty,
            squad_size = squad_size,
            best_record = default_best_record,
            entries = {}
        }
    end

    if not storage.boss_logs[race_name].difficulty == difficulty or
            not storage.boss_logs[race_name].difficulty == squad_size then
        storage.boss_logs[race_name]["difficulty"] = difficulty
        storage.boss_logs[race_name]["squad_size"] = squad_size
        storage.boss_logs[race_name].best_record = default_best_record
    end
end

local has_better_record = function(current_best_record, record)
    local race_name = record.race
    return record.tier == current_best_record.tier and
            ((storage.boss_logs[race_name].best_record.time == -1) or
                    (record.last_tick - record.spawn_tick) < storage.boss_logs[race_name].best_record.time)
end

local update_best_time = function(record)
    local race_name = record.race
    local current_best_record = storage.boss_logs[race_name].best_record
    if record.victory and (record.tier > current_best_record.tier or has_better_record(current_best_record, record)) then
        storage.boss_logs[race_name].best_record.tier = record.tier
        storage.boss_logs[race_name].best_record.time = record.last_tick - record.spawn_tick
    end
end

local write_result_log = function(victory)
    local boss = storage.boss
    local difficulty = settings.startup["enemyracemanager-boss-difficulty"].value
    local squad_size = settings.startup["enemyracemanager-boss-unit-spawn-size"].value

    initialize_result_log(boss.race_name, difficulty, squad_size)

    local record = {
        race = boss.race_name,
        tier = boss.boss_tier,
        victory = victory,
        surface = boss.surface_name,
        location = boss.entity_position,
        difficulty = difficulty,
        squad_size = squad_size,
        spawn_tick = boss.spawned_tick,
        last_tick = game.tick
    }
    table.insert(storage.boss_logs[boss.race_name].entries, record)

    update_best_time(record)
end

function BossProcessor.init_globals()
    storage.boss = storage.boss or boss_setting_default()
    storage.boss_attack_groups = storage.boss_attack_groups or {}
    storage.boss_group_spawn = storage.boss_group_spawn or BossGroupProcessor.get_default_data()
    storage.boss_spawnable_index = storage.boss_spawnable_index or boss_spawnable_index_default()
    storage.boss_rewards = storage.boss_rewards or {}
    storage.boss_logs = storage.boss_logs or {}
end

--- Start the boss spawn flow
function BossProcessor.exec(rocket_silo, spawn_position)
    DebugHelper.print("BossProcessor: Check rocket_silo valid...")
    if rocket_silo and rocket_silo.valid and storage.boss.loading == false and
            (storage.boss.entity == nil or storage.boss.entity.valid == false) then
        storage.boss.loading = true
        local surface = rocket_silo.surface
        local race_name = SurfaceProcessor.get_enemy_on(rocket_silo.surface.name)

        if race_name == nil then
            return nil
        end

        if not RaceSettingsHelper.has_boss(race_name) then
            game.print("Unable to spawn boss on unsupported race: " .. race_name)
            return nil
        end

        local force = game.forces[ForceHelper.get_force_name_from(race_name)]
        DebugHelper.print("BossProcessor: Data setup...")
        storage.boss.race_name = race_name
        storage.boss.force = force
        storage.boss.force_name = force.name
        storage.boss.surface = surface
        storage.boss.surface_name = surface.name
        storage.boss.silo_position = rocket_silo.position
        storage.boss.spawned_tick = game.tick
        storage.boss.boss_tier = RaceSettingsHelper.boss_tier(storage.boss.race_name)
        storage.boss.despawn_at_tick = game.tick + (minute * GlobalConfig.BOSS_DESPAWN_TIMER[storage.boss.boss_tier])
        BossProcessor.index_turrets(surface)
        DebugHelper.print("BossProcessor: Indexed positions: " .. storage.boss_spawnable_index.size)

        if storage.boss_spawnable_index.size == 0 and spawn_position == nil then
            surface.print("Unable to find a boss spawner.  Please try again.")
            BossProcessor.unset()
            return
        end

        if not Position.is_position(spawn_position) then
            local target_chunk_data = storage.boss_spawnable_index.chunks[math.random(1, storage.boss_spawnable_index.size)]
            spawn_position = target_chunk_data.spawn_position
            storage.boss.target_position = target_chunk_data.turret_position
            storage.boss.target_direction = get_target_direction(spawn_position, target_chunk_data.turret_position)
        end

        local entities = surface.find_entities_filtered {
            type = enemy_entities,
            area = {
                top_left = { spawn_position.x - cleanChunkSize, spawn_position.y - cleanChunkSize },
                bottom_right = { spawn_position.x + cleanChunkSize, spawn_position.y + cleanChunkSize }
            }
        }
        DebugHelper.print("BossProcessor: To destroy entities: " .. #entities)
        for i = 1, #entities do
            entities[i].destroy()
        end

        DebugHelper.print("BossProcessor: Creating Boss Base...")
        DebugHelper.print(BossProcessor.get_boss_name(race_name))
        local boss_entity = surface.create_entity {
            name = BossProcessor.get_boss_name(race_name),
            position = spawn_position,
            force = force,
            spawn_decorations = true
        }

        for _, value in pairs(ForceHelper.get_player_forces()) do
            DebugHelper.print("BossProcessor: Add Beacon for " .. value)
            local boss_beacon_entity = surface.create_entity {
                name = beacon_name,
                position = spawn_position,
                force = value
            }
            boss_beacon_entity.destructible = false
        end

        DebugHelper.print("BossProcessor: Assign Entities...")
        storage.boss.entity = boss_entity
        storage.boss.attack_last_hp = {
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health
        }
        storage.boss.entity_name = boss_entity.name
        storage.boss.entity_position = boss_entity.position

        game.print({
            "description.boss-base-spawn-at",
            SurfaceProcessor.get_gps_message(
                    spawn_position.x,
                    spawn_position.y,
                    surface.name
            )
        })

        DebugHelper.print("BossProcessor: Create Pathing Unit...")
        local pathing_entity_name = BossProcessor.get_pathing_entity_name(race_name)
        local pathing_spawn_location = surface.find_non_colliding_position(pathing_entity_name, spawn_position, chunkSize, 2, true)
        local pathing_entity = surface.create_entity {
            name = pathing_entity_name,
            position = pathing_spawn_location,
            force = force
        }
        local command = {
            type = defines.command.attack,
            target = rocket_silo,
            distraction = defines.distraction.by_damage
        }
        pathing_entity.commandable.set_command(command)
        storage.boss.pathing_entity = pathing_entity
        Cron.add_2_sec_queue("BossProcessor.check_pathing")
        Cron.add_2_sec_queue("BossProcessor.heartbeat")
        start_boss_event()
    end
end

function BossProcessor.check_pathing()
    local boss = storage.boss

    if storage.boss.entity == nil then
        return
    end

    if boss.pathing_entity_checks == 5 then
        local pathing_entity = boss.pathing_entity
        DebugHelper.print("BossProcessor: Comparing path unit position")
        if pathing_entity and pathing_entity.valid then
            if pathing_entity.spawner then
                DebugHelper.print("BossProcessor: flying only [attached spawner]")
                storage.boss.flying_only = true
                start_unit_spawn()
                storage.boss.loading = false
                return
            end

            local boss_base = pathing_entity.surface.find_entities_filtered { name = boss.entity_name, position = pathing_entity.position, radius = chunkSize / 2 }
            if boss_base and boss_base[1] then
                DebugHelper.print("BossProcessor: flying only [unit proximity]")
                DebugHelper.print(#boss_base)
                DebugHelper.print(boss_base[1].name)
                storage.boss.flying_only = true
                start_unit_spawn()
                storage.boss.loading = false
                return
            end
        end
        DebugHelper.print("BossProcessor: Not a flying only boss ")
        start_unit_spawn()
        storage.boss.loading = false
        return
    end

    DebugHelper.print("BossProcessor: Waiting to check path unit")
    storage.boss.pathing_entity_checks = storage.boss.pathing_entity_checks + 1
    Cron.add_2_sec_queue("BossProcessor.check_pathing")
end

function BossProcessor.get_boss_name(race_name)
    if storage.race_settings[race_name].boss_building then
        return RaceSettingsHelper.get_race_entity_name(
                race_name,
                storage.race_settings[race_name].boss_building,
                GlobalConfig.BOSS_LEVELS[storage.boss.boss_tier]
        )
    end

    return nil
end

function BossProcessor.get_pathing_entity_name(race_name)
    return RaceSettingsHelper.get_race_entity_name(
            race_name,
            storage.race_settings[race_name].pathing_unit,
            storage.race_settings[race_name].level
    )
end

local display_victory_dialog = function(boss)
    if storage.race_settings[boss.race_name].boss_tier >= GlobalConfig.BOSS_MAX_TIERS then
        return
    end

    local targetPlayer = nil
    for _, player in pairs(game.players) do
        if player.valid and player.connected and player.surface == boss.surface then
            targetPlayer = player
            break
        end
    end

    if targetPlayer == nil then
        for _, player in pairs(game.players) do
            if player.valid and player.connected then
                targetPlayer = player
                break
            end
        end
    end

    if targetPlayer then
        GuiContainer.victory_dialog.show(targetPlayer, storage.race_settings[boss.race_name])
    end
end

function BossProcessor.heartbeat()
    local boss = storage.boss
    local current_tick = game.tick
    local max_attacks = GlobalConfig.BOSS_MAX_ATTACKS_PER_HEARTBEAT[boss.boss_tier]
    if boss.victory then
        -- start reward process
        storage.race_settings[boss.race_name].boss_kill_count = storage.race_settings[boss.race_name].boss_kill_count + 1
        write_result_log(true)
        display_victory_dialog(boss)
        BossRewardProcessor.exec()
        BossProcessor.unset()
        DebugHelper.print("BossProcessor: is victory")
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    if current_tick > boss.despawn_at_tick then
        -- start despawn process
        DebugHelper.print("BossProcessor: start despawn process")
        write_result_log(false)
        BossDespawnProcessor.exec()
        BossProcessor.unset()
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    if not RaceSettingsHelper.is_in_boss_mode() then
        destroy_beacons()
        unset_boss_data()
        DebugHelper.print("BossProcessor: No longer in boss mode")
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    local boss_direct_attack = false
    local performed_attacks = 0
    for index, last_hp in pairs(boss.attack_last_hp) do
        local direct_attack = false
        local spawn_attack = false
        if last_hp - boss.entity.health > GlobalConfig.BOSS_DEFENSE_ATTACKS[index] then
            storage.boss.attack_last_hp[index] = boss.entity.health
            DebugHelper.print("BossProcessor: Attack Index " .. index .. " @ " .. boss.entity.health)
            direct_attack, spawn_attack = attack_functions[index]()
            performed_attacks = performed_attacks + 1

            if direct_attack then
                boss_direct_attack = true
            end

            if max_attacks == performed_attacks then
                break
            end
        end
    end

    if boss_direct_attack then
        BossAttackProcessor.unset_attackable_entities_cache()
    end

    draw_time(boss, current_tick)
    Cron.add_2_sec_queue("BossProcessor.heartbeat")
end

function BossProcessor.index_turrets(surface)
    local gunturrets = surface.find_entities_filtered({ type = indexable_turrets })
    local totalturrets = #gunturrets;
    local turret_gap = math.max(4, math.floor(totalturrets / 64))
    local turret_gap_pick = math.max(2, math.random(2, math.floor(turret_gap / 2)))
    DebugHelper.print("BossProcessor: Total: " .. totalturrets)
    DebugHelper.print("BossProcessor: Gap: " .. turret_gap .. "/" .. turret_gap_pick)
    storage.boss_spawnable_index.closest_distance = 9999
    for i = 1, totalturrets do
        if i % turret_gap == turret_gap_pick then
            local gunturret = gunturrets[i]
            index_boss_spawnable_chunk(gunturret, get_scan_area[gunturret.direction](gunturret.position.x, gunturret.position.y))
            i = i + turret_gap - 2
        end
    end

    local newChunkList = {}
    for _, chunk in pairs(storage.boss_spawnable_index.chunks) do
        if chunk.distance <= storage.boss_spawnable_index.closest_distance * 2 then
            table.insert(newChunkList, chunk)
        end
    end
    storage.boss_spawnable_index.chunks = newChunkList
    storage.boss_spawnable_index.size = table_size(newChunkList)
end

--- Queue to spawn boss units
--- @see enemyracemanager/control.lua
function BossProcessor.units_spawn()
    if not RaceSettingsHelper.is_in_boss_mode() then
        DebugHelper.print("BossProcessor: units_spawn stops...")
        return
    end

    if INCLUDE_SPAWNS then
        BossGroupProcessor.spawn_regular_group()
        Cron.add_15_sec_queue("BossProcessor.units_spawn")
    end
end

--- Queue to build boss Spawner
--- @see enemyracemanager/control.lua
function BossProcessor.support_structures_spawn()
    if not RaceSettingsHelper.is_in_boss_mode() then
        DebugHelper.print("BossProcessor: support_structures_spawn stops...")
        return
    end

    if INCLUDE_SPAWNS then
        spawn_building()
        Cron.add_1_min_queue("BossProcessor.support_structures_spawn")
    end
end

function BossProcessor.unset()
    if RaceSettingsHelper.is_in_boss_mode() then
        storage.boss.entity.destroy()
        DebugHelper.print("BossProcessor: destroy boss base...")
    end
    destroy_beacons()
    unset_boss_data()
    DebugHelper.print("BossProcessor: unset...")
end

--- Build boss spawner
--- @see enemyracemanager/control.lua
function BossProcessor.build_spawner(surface, name, force, position)
    if not RaceSettingsHelper.is_in_boss_mode() or not can_build_spawn_building() then
        return
    end

    BaseBuildProcessor.build(surface, name, force, position)
end

function BossProcessor.remove_boss_groups(spawn_data)
    if spawn_data.group and spawn_data.group.valid then
        DebugHelper.print("BossProcessor: Removing boss attack groups...")
        for _, member in pairs(spawn_data.group.members) do
            if member.valid then
                member.destroy()
            end
        end
    end
end

return BossProcessor