---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/16/2022 2:58 PM
---
require("util")

local Position = require("__erm_libs__/stdlib/position")
local Territory = require("__erm_libs__/stdlib/territory")

local GlobalConfig = require("__enemyracemanager__/lib/global_config")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local SurfaceProcessor = require("__enemyracemanager__/lib/surface_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")
local BossAttackProcessor = require("__enemyracemanager__/lib/boss_attack_processor")
local EmotionConstants = require("__enemyracemanager__/lib/emotion_constants")
local EmotionProcessor = require("__enemyracemanager__/lib/emotion_processor")
local BossRewardProcessor = require("__enemyracemanager__/lib/boss_reward_processor")
local CustomAttacks = require("__enemyracemanager__/lib/helper/custom_attack_helper")
local BossVictoryDialog = require("__enemyracemanager__/gui/victory_dialog")
local BossRadar = require("__enemyracemanager__/gui/boss_radar")

local DebugHelper = require("__enemyracemanager__/lib/debug_helper")

local BossProcessor = {
    --- The ratio of HP deduct from Boss when an assisted spawner dies 
     ASSISTED_SPAWNER_DEATH_RATIO = 0.5
}


local chunkSize = 32
local spawnRadius = 64
local cleanChunkSize = 8

--- Wait between assist spawner spawn
local ASSISTED_SPAWNER_INTERVAL = 3600
local SEGMENTED_UNIT_CHECK_INTERVAL = 600

local SCAN_EXTRA_PADDING = 160

local enemy_entities = { "unit-spawner", "turret", "unit" }
local enemy_buildings = { "unit-spawner", "turret" }
local beacon_name = "erm-boss-beacon"

local qualities = {}
for name, item in pairs(prototypes.quality) do
    if string.find(name, 'erm-boss-', nil, true) then
        table.insert(qualities, item.name)
    end
end

local boss_setting_default = function()
    return {
        entity = nil,
        entity_name = "",
        entity_position = nil,
        target_position = { x = 0, y = 0 },
        target_direction = defines.direction.north,
        radar = nil,
        surface = nil,
        surface_name = "",
        force = nil,
        force_name = "",
        boss_tier = 1,
        flying_only = false,
        spawned_tick = 0,
        pathing_entity = nil,
        pathing_entity_checks = 0,
        attack_last_hp = { 0, 0, 0, 0, 0, 0 },
        attack_cache_force_refresh = false,
        victory = false,
        high_level_enemy_list = nil, -- Track all high level enemies, they die when the base destroys.
        loading = false,
        spawn_beacons = {},
        assisted_spawners = {},
        total_assisted_spawners = 0,
        assisted_spawner_check_time = game.tick,
        segmented_unit_check_time = game.tick,
        controlled_segment_unit = nil,
        --- Tracks the game tick of last attack, for idle attacks
        last_attack_tick = game.tick,
        --- Tracks the game tick of emotional attack
        last_emotional_attack_tick = game.tick
    }
end

local process_boss_queue = function(event)
    Cron.process_boss_queue()
end

local start_boss_event = function()
    script.on_nth_tick(GlobalConfig.BOSS_QUEUE_CRON, process_boss_queue)
end

local remove_boss_event = function()
    script.on_nth_tick(GlobalConfig.BOSS_QUEUE_CRON, nil)
    Cron.empty_boss_queue()
end


local get_scan_area = function(boss_position, radar_position, using_extra_padding)
    using_extra_padding = using_extra_padding or true
    local extra_padding = 0
    if using_extra_padding then
        extra_padding = SCAN_EXTRA_PADDING
    end
    if boss_position == nil then
        boss_position = storage.boss.entity_position
    end
    local x1 = math.min(boss_position.x, radar_position.x) - extra_padding
    local y1 = math.min(boss_position.y, radar_position.y) - extra_padding
    local x2 = math.max(boss_position.x, radar_position.x) + extra_padding
    local y2 = math.max(boss_position.y, radar_position.y) + extra_padding
    
    return { left_top = { x = x1, y = y1 }, right_bottom = { x = x2, y = y2 } }
end


local destroy_beacons = function()
    local beacons = storage.boss.surface.find_entities_filtered { name = beacon_name, type = "radar" }
    for i = 1, #beacons do
        beacons[i].destroy()
    end
end

local unset_boss_data = function()
    storage.boss = boss_setting_default()
    remove_boss_event()
end

local basic_attack = function()
    BossAttackProcessor.exec_basic()
end

local heavy_attack = function()
    BossAttackProcessor.exec_heavy()
end

local assist_attacks = function()
    BossAttackProcessor.exec_assist()
end

local special_attacks = function()
    BossAttackProcessor.exec_special()
end

local ultimate_attack = function()
    BossAttackProcessor.exec_ultimate()
end

local phase_change = function()
    BossAttackProcessor.exec_phase()
end

--- Phase change + 5 attacks
local attack_functions = {
    phase_change,
    ultimate_attack,
    special_attacks,
    assist_attacks,
    heavy_attack,
    basic_attack
}

local spawn_idle_attack = function()
    local boss_data = storage.boss
    if boss_data and 
       boss_data.entity.valid and 
       game.tick > boss_data.idle_attack_interval + boss_data.last_attack_tick 
    then
        if RaceSettingsHelper.can_spawn(66) then
            BossAttackProcessor.process_idle_attack()
        else                    
            basic_attack()
        end
        boss_data.last_attack_tick = game.tick
    end
end

local initialize_result_log = function(force_name)
    local default_best_record = {
        tier = 1,
        time = -1,
    }
    if storage.boss_logs[force_name] == nil then
        storage.boss_logs[force_name] = {
            best_record = default_best_record,
            entries = {}
        }
    end
end

local has_better_record = function(current_best_record, record)
    local force_name = record.race
    return record.tier == current_best_record.tier and
            ((storage.boss_logs[force_name].best_record.time == -1) or
                    (record.last_tick - record.spawn_tick) < storage.boss_logs[force_name].best_record.time)
end

local update_best_time = function(record)
    local force_name = record.race
    local current_best_record = storage.boss_logs[force_name].best_record
    if record.victory and (record.tier > current_best_record.tier or has_better_record(current_best_record, record)) then
        storage.boss_logs[force_name].best_record.tier = record.tier
        storage.boss_logs[force_name].best_record.time = record.last_tick - record.spawn_tick
    end
end

function BossProcessor.write_result_log(victory)
    local boss = storage.boss
    
    initialize_result_log(boss.force_name)

    local record = {
        race = boss.force_name,
        tier = boss.boss_tier,
        victory = victory,
        surface = boss.surface_name,
        location = boss.entity_position,
        spawn_tick = boss.spawned_tick,
        last_tick = game.tick,
        max_group_size = GlobalConfig.max_group_size(),
        unit_assist_size = settings.startup['enemyracemanager-attacks-unit-spawn-size'].value
    }

    if victory then
        record.radar_health = boss.radar.get_health_ratio() * 100
    elseif boss.entity and boss.entity.valid then
        record.boss_health = boss.entity.get_health_ratio() * 100
    end

    if boss.surrendered_method then
        record.surrendered_method = boss.surrendered_method
        record.surrendered_player = boss.surrendered_player
    end
    
    table.insert(storage.boss_logs[boss.force_name].entries, record)

    update_best_time(record)
end

function BossProcessor.init_globals()
    storage.boss = storage.boss or boss_setting_default()
    storage.boss_rewards = storage.boss_rewards or {}
    storage.boss_logs = storage.boss_logs or {}
    storage.boss.attack_cache_force_refresh = true
    
    storage.registered_boss_radars = {}
    for _, radar in pairs(prototypes.get_entity_filtered({{filter = "type", type = "radar"}})) do
        if radar.subgroup and radar.subgroup.name == 'boss_radar' then
            storage.registered_boss_radars[radar.name] = true
        end
    end
end

function BossProcessor.reset_globals()
    storage.boss = boss_setting_default()
    storage.boss_rewards =  {}
    storage.boss_logs = {}
    storage.boss.attack_cache_force_refresh = true
end

--- Start the boss spawn flow
function BossProcessor.exec(radar, spawn_position)
    if not Position.is_position(spawn_position) then
        DebugHelper.print("Missing spawn position...")
        return
    end        
    DebugHelper.print("BossProcessor: Check radar valid...")            
    if radar and radar.valid and storage.boss.loading == false and
            (storage.boss.entity == nil or storage.boss.entity.valid == false) then
        storage.boss.loading = true
        local surface = radar.surface
        local name_tokens = ForceHelper.get_name_token(radar.name)
        local force_name = name_tokens[1]

        if force_name == nil then
            DebugHelper.print("Force name not found")
            return nil
        end

        if not RaceSettingsHelper.has_boss(force_name) then
            game.print("Unable to spawn boss on unsupported race: " .. force_name)
            return nil
        end

        local force = game.forces[force_name]
        DebugHelper.print("BossProcessor: Data setup...")
        storage.boss.force = force
        storage.boss.force_name = force_name
        storage.boss.surface = surface
        storage.boss.surface_name = surface.name
        storage.boss.spawned_tick = game.tick
        local boss_tier = RaceSettingsHelper.boss_tier(force_name)
        storage.boss.boss_tier = boss_tier
        local boss_quality = nil
        if boss_tier > 1 then
            boss_quality = qualities[boss_tier - 1]
            storage.boss.quality = boss_quality
        end

        local boss_settings = RaceSettingsHelper.get_boss_settings(force_name)
        storage.boss.max_buildable_unit_spawner = boss_settings.max_buildable_unit_spawner[boss_tier]
        storage.boss.max_attack_per_heartbeat = boss_settings.max_attacks_per_heartbeat[boss_tier]
        storage.boss.defense_attacks = boss_settings.defense_attacks
        storage.boss.idle_attack_interval = boss_settings.idle_attack_interval[boss_tier]

        storage.boss.target_position = spawn_position
        storage.boss.target_direction = Position.complex_direction_to(spawn_position, radar.position, true)

        local entities = surface.find_entities_filtered {
            type = enemy_entities,
            area = {
                top_left = { spawn_position.x - cleanChunkSize, spawn_position.y - cleanChunkSize },
                bottom_right = { spawn_position.x + cleanChunkSize, spawn_position.y + cleanChunkSize }
            },
            
        }
        DebugHelper.print("BossProcessor: destroy entities: " .. #entities)
        for i = 1, #entities do
            entities[i].destroy()
        end

        force.set_evolution_factor(1, surface)
        local boss_name = BossProcessor.get_boss_name(force_name)
        DebugHelper.print("BossProcessor: Creating Boss Base...")
        DebugHelper.print(boss_name)
        local boss_spawn_location = surface.find_non_colliding_position(boss_name, spawn_position, chunkSize, 1, true)
        storage.skip_quality_rolling = true
        local boss_entity = surface.create_entity {
            name = boss_name,
            position = boss_spawn_location,
            force = force,
            spawn_decorations = true,
            quality = boss_quality
        }

        local entities = surface.find_entities_filtered {
            name = boss_name,
            limit = 1,
            
        }
        
        if not boss_entity then
            storage.boss = boss_setting_default()
            storage.boss.radar = radar
            return
        end

        for _, value in pairs(ForceHelper.get_player_forces()) do
            DebugHelper.print("BossProcessor: Add Beacon for " .. value)
            local boss_beacon_entity = surface.create_entity {
                name = beacon_name,
                position = spawn_position,
                force = value
            }
            boss_beacon_entity.destructible = false
        end

        DebugHelper.print("BossProcessor: Assign Entities...")
        storage.boss.entity = boss_entity
        storage.boss.attack_last_hp = {
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
        }
        storage.boss.entity_name = boss_entity.name
        storage.boss.entity_position = boss_entity.position

        storage.boss.scan_area = get_scan_area(storage.boss_final_scanned_position, radar.position)
        storage.boss.scan_area_wo_padding = get_scan_area(storage.boss_final_scanned_position, radar.position, false)

        if DEBUG_MODE then
            local indicator = rendering.draw_rectangle({
                color = { b = 0.3, a = 0.2 },
                left_top = storage.boss.scan_area.left_top,
                right_bottom = storage.boss.scan_area.right_bottom,
                surface = storage.boss.surface.index,
                forces = 'player',
                filled = true,
                draw_on_ground = true,
                width = 8,
                only_in_alt_mode = true,
                --time_to_live = 7200,
            })
        end

        --- replace tile
        local tile = surface.get_tile(boss_entity.position)
        local tiles = {}
        for x = (boss_entity.position.x - 64), boss_entity.position.x + 64, 1 do
            for y = (boss_entity.position.y - 64), boss_entity.position.y + 64, 1 do
                table.insert(tiles, { name = tile, position = { x, y } })
            end
        end
        surface.set_tiles(tiles, true, true, true, true)

        --- Kill cliff
        for k, entity in pairs(surface.find_entities_filtered{type = "cliff", area = {
            top_left = { boss_entity.position.x - 32, boss_entity.position.y - 32 },
            bottom_right = { boss_entity.position.x + 32, boss_entity.position.y + 32 }
        }}) do
            entity.destroy()
        end
        
        
        game.print({
            "description.boss-base-spawn-at",
            SurfaceProcessor.get_gps_message(
                    spawn_position.x,
                    spawn_position.y,
                    surface.name
            )
        })

        DebugHelper.print("BossProcessor: Create Pathing Unit...")
        local pathing_entity_name = BossProcessor.get_pathing_entity_name(force_name)
        DebugHelper.print(pathing_entity_name)
        local pathing_spawn_location = surface.find_non_colliding_position(pathing_entity_name, spawn_position, chunkSize, 1, true)
        DebugHelper.print(pathing_spawn_location)
        storage.skip_quality_rolling = true
        local pathing_entity = surface.create_entity {
            name = pathing_entity_name,
            position = pathing_spawn_location,
            force = force
        }
        DebugHelper.print(pathing_entity)
        local command = {
            type = defines.command.attack,
            target = radar,
            distraction = defines.distraction.by_damage
        }
        pathing_entity.commandable.set_command(command)
        storage.boss.pathing_entity = pathing_entity
        Cron.add_2_sec_queue("BossProcessor.check_pathing")
        Cron.add_2_sec_queue("BossProcessor.heartbeat")
        start_boss_event()
    end
end

function BossProcessor.check_pathing()
    local boss = storage.boss

    if storage.boss.entity == nil then
        return
    end

    if boss.pathing_entity_checks == 5 then
        local pathing_entity = boss.pathing_entity
        DebugHelper.print("BossProcessor: Comparing path unit position")
        if pathing_entity and pathing_entity.valid then
            if pathing_entity.commandable.spawner then
                DebugHelper.print("BossProcessor: flying only [attached spawner]")
                storage.boss.flying_only = true
                --start_unit_spawn()
                storage.boss.loading = false
                return
            end

            local boss_base = pathing_entity.surface.find_entities_filtered { name = boss.entity_name, position = pathing_entity.position, radius = chunkSize / 2 }
            if boss_base and boss_base[1] then
                DebugHelper.print("BossProcessor: flying only [unit proximity]")
                DebugHelper.print(#boss_base)
                DebugHelper.print(boss_base[1].name)
                storage.boss.flying_only = true
                storage.boss.loading = false
                return
            end
        end
        DebugHelper.print("BossProcessor: Not a flying only boss ")
        storage.boss.loading = false
        return
    end

    DebugHelper.print("BossProcessor: Waiting to check path unit")
    storage.boss.pathing_entity_checks = storage.boss.pathing_entity_checks + 1
    Cron.add_2_sec_queue("BossProcessor.check_pathing")
end

function BossProcessor.get_boss_name(force_name)
    if storage.race_settings[force_name].boss_building then
        return RaceSettingsHelper.get_race_entity_name(
                force_name,
                storage.race_settings[force_name].boss_building,
                math.min(5, storage.boss.boss_tier)
        )
    end

    return nil
end

function BossProcessor.get_pathing_entity_name(force_name)
    return RaceSettingsHelper.get_race_entity_name(
            force_name,
            storage.race_settings[force_name].pathing_unit,
            5
    )
end

local display_victory_dialog = function(boss)
    if storage.race_settings[boss.force_name].boss_tier >= GlobalConfig.BOSS_MAX_TIERS then
        return
    end

    local targetPlayer = nil
    for _, player in pairs(game.players) do
        if player.valid and player.connected and player.surface == boss.surface then
            targetPlayer = player
            break
        end
    end

    if targetPlayer == nil then
        for _, player in pairs(game.players) do
            if player.valid and player.connected then
                targetPlayer = player
                break
            end
        end
    end

    if targetPlayer then
        BossVictoryDialog.show(targetPlayer, storage.race_settings[boss.force_name])
    end
end

--- Spawn assist spawner when the total assist spawner isn't at max.
local spawn_assist_spawner = function(boss_data)
    if game.tick >= boss_data.assisted_spawner_check_time + ASSISTED_SPAWNER_INTERVAL and boss_data.total_assisted_spawners < boss_data.max_buildable_unit_spawner then
        local race_settings = storage.race_settings[boss_data.force_name]
        local offsets = {
            {x = 16, y = 16},
            {x = 16, y = -16},
            {x = -16, y = 16},
            {x = -16, y = -16}
        }
        local offset_size = 4

        local assisted_spawner_name = race_settings.boss_assisted_spawner
        local event_obj = {
            surface_index = boss_data.surface.index,
            source_entity = boss_data.entity
        }
        if boss_data.total_assisted_spawners / boss_data.max_buildable_unit_spawner <= 0.5 then
            -- spawn an assist
            local offset = offsets[math.random(1, offset_size)]
            CustomAttacks.boss_build(event_obj, boss_data.force_name, assisted_spawner_name,
                    {x = boss_data.entity_position.x + offset.x, y = boss_data.entity_position.y + offset.y})
        end
        
        local offset = offsets[math.random(1, offset_size)]
        CustomAttacks.boss_build(event_obj, boss_data.force_name, assisted_spawner_name,
                {x = boss_data.entity_position.x + offset.x, y = boss_data.entity_position.y + offset.y})
        
        storage.boss.assisted_spawner_check_time = game.tick
    end
end

--- When a segmented unit is too close to the boss, the boss changes that segmented unit's territory to include radar.
--- Check once every 15 seconds. (ง •̀_•́)ง
local redirect_segment_unit = function(boss_data)
    if game.tick >= boss_data.segmented_unit_check_time + SEGMENTED_UNIT_CHECK_INTERVAL and
       not boss_data.controlled_segment_unit
    then
        local surface = boss_data.surface
        local seg_units = surface.find_entities_filtered {
            type = "segmented-unit",
            force = boss_data.force_name,
            position = boss_data.entity_position,
            radius = spawnRadius * 2,
        }
        local seg_unit = seg_units[1]
        if seg_unit and seg_unit.segmented_unit then
            boss_data.controlled_segment_unit = {
                entity = seg_unit,
                unit_number = seg_unit.unit_number
            }
            local territory = seg_unit.segmented_unit.territory
            local new_territory_chunks = Territory.compute_territory_path(seg_unit.position, boss_data.radar_position)
            if territory then
                surface.set_territory_for_chunks(
                        new_territory_chunks,
                        territory
                )
            else
               seg_unit.territory = surface.create_territory({chunks=new_territory_chunks})
            end
            seg_unit.segmented_unit.set_ai_state({
                type = defines.segmented_unit_ai_state.investigating,
                destination = boss_data.radar.position
            })
            surface.print('Boss Radar: Detected territory anomalies.')
        end
        boss_data.segmented_unit_check_time = game.tick
    end
end

function BossProcessor.heartbeat()
    local boss = storage.boss
    local current_tick = game.tick
    local max_attacks = boss.max_attacks_per_heartbeat
    if boss.victory then
        -- start reward process
        storage.race_settings[boss.force_name].boss_kill_count = storage.race_settings[boss.force_name].boss_kill_count + 1
        BossProcessor.write_result_log(true)
        display_victory_dialog(boss)
        BossRewardProcessor.exec()
        BossProcessor.unset()
        DebugHelper.print("BossProcessor: is victory")
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    if not boss.radar or not boss.radar.valid then
        -- start despawn process when radar no longer valid / dead
        DebugHelper.print("BossProcessor: Defeated, start despawn process")
        BossProcessor.write_result_log(false)
        BossAttackProcessor.process_despawn_attack()
        BossProcessor.unset()
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    if not RaceSettingsHelper.is_in_boss_mode() then
        destroy_beacons()
        unset_boss_data()
        DebugHelper.print("BossProcessor: No longer in boss mode")
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    spawn_assist_spawner(boss)
    
    redirect_segment_unit(boss)
    
    spawn_idle_attack(boss)
    
    local performed_attacks = 1
    for index, last_hp in pairs(boss.attack_last_hp) do
        if last_hp - boss.entity.health > boss.defense_attacks[index] then
            DebugHelper.print("BossProcessor: Attack Index " .. index .. " @ " .. boss.entity.health)
            attack_functions[index]()
            storage.boss.attack_last_hp[index] = boss.entity.health
            performed_attacks = performed_attacks + 1
            storage.boss.last_attack_tick = game.tick
            if max_attacks == performed_attacks then
                break
            end
        end
    end
    
    BossAttackProcessor.unset_close_range_entities_cache()
    
    Cron.add_2_sec_queue("BossProcessor.heartbeat")
end


function BossProcessor.get_boss_quality()
    return storage.boss.quality
end

function BossProcessor.unset()
    local boss_data = storage.boss
    if RaceSettingsHelper.is_in_boss_mode() then
        boss_data.entity.destroy()
        DebugHelper.print("BossProcessor: destroy boss base...")
    end

    if boss_data.radar.valid then
        boss_data.radar.destroy()
    end


    if boss_data.assisted_spawners then
        DebugHelper.print("BossProcessor: destroy assisted_spawners...")
        for _, assist in pairs(boss_data.assisted_spawners) do
            if assist.entity.valid then
                assist.entity.destroy()
            end
        end
    end
    
    local switch_data = {
        surface = boss_data.surface,
        force = boss_data.force,
        current_emo = EmotionConstants.EMO_PEACEFUL,
    }
    EmotionProcessor.switch(switch_data)
    EmotionProcessor.run(switch_data)
    
    DebugHelper.print("BossProcessor: Destroy Beacons...")
    destroy_beacons()

    unset_boss_data()
    for _, player in pairs(game.players) do
        if player.valid then
            BossRadar.hide(player)
        end
    end
    DebugHelper.print("BossProcessor: unset...")
end


function BossProcessor.assisted_spawner_spawns(event)
    local spawner_entity = event.source_entity
    if spawner_entity then
        local boss_data = storage.boss
        if boss_data.total_assisted_spawners >= boss_data.max_buildable_unit_spawner then
            spawner_entity.destroy()
            return
        end
        boss_data.assisted_spawners[spawner_entity.unit_number] = {
            entity = spawner_entity,
            last_health = spawner_entity.get_health_ratio()
        }

        boss_data.total_assisted_spawners = boss_data.total_assisted_spawners + 1 
    end 
end

--- Deduct boss health when assist spawner dies.
function BossProcessor.assisted_spawner_dies(event)
    local spawner_entity = event.source_entity
    local boss_entity = storage.boss.entity
    if not spawner_entity or not spawner_entity.valid or not boss_entity or not boss_entity.valid then
        return
    end
    
    boss_entity.health = boss_entity.health - (spawner_entity.max_health * BossProcessor.ASSISTED_SPAWNER_DEATH_RATIO)
    storage.boss.assisted_spawners[spawner_entity.unit_number] = nil
    storage.boss.total_assisted_spawners = math.max(storage.boss.total_assisted_spawners - 1, 0)
    storage.boss.assisted_spawner_check_time = game.tick
end

function BossProcessor.controlled_segmented_unit_dies(event)
    local segmented_entity = event.source_entity
    local boss_data = storage.boss
    if boss_data.controlled_segment_unit and
        boss_data.controlled_segment_unit.unit_number == segmented_entity.unit_number
    then
        storage.boss.controlled_segment_unit = nil
    end 
end

return BossProcessor