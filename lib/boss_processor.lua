---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/16/2022 2:58 PM
---
require("util")

local Position = require("__erm_libs__/stdlib/position")
local GlobalConfig = require("__enemyracemanager__/lib/global_config")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local SurfaceProcessor = require("__enemyracemanager__/lib/surface_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")
local BossGroupProcessor = require("__enemyracemanager__/lib/boss_group_processor")
local BossAttackProcessor = require("__enemyracemanager__/lib/boss_attack_processor")
local BaseBuildProcessor = require("__enemyracemanager__/lib/base_build_processor")
local BossRewardProcessor = require("__enemyracemanager__/lib/boss_reward_processor")
local BossDespawnProcessor = require("__enemyracemanager__/lib/boss_despawn_processor")

local GuiContainer = require("__enemyracemanager__/gui/main")

local DebugHelper = require("__enemyracemanager__/lib/debug_helper")

local BossProcessor = {}

-- beam scan up to 100 chunks
local scanLength = GlobalConfig.BOSS_ARTILLERY_SCAN_RANGE
-- 7 chunks
local scanMinLength = 224
local scanRadius = 16

local chunkSize = 32
local spawnRadius = 64
local cleanChunkSize = 8

local INCLUDE_SPAWNS = true -- Only for debug

--- The ratio of HP deduct from Boss when an assisted spawner dies 
local ASSISTED_SPAWNER_DEATH_RATIO = 0.33

local enemy_entities = { "unit-spawner", "turret", "unit" }
local enemy_buildings = { "unit-spawner", "turret" }
local beacon_name = "erm-boss-beacon"

local qualities = {}
for name, item in pairs(prototypes.quality) do
    if string.find(name, 'erm-boss-', nil, true) then
        table.insert(qualities, item.name)
    end
end

local boss_setting_default = function()
    return {
        entity = nil,
        entity_name = "",
        entity_position = nil,
        target_position = { x = 0, y = 0 },
        target_direction = defines.direction.north,
        radar = nil,
        surface = nil,
        surface_name = "",
        force = nil,
        force_name = "",
        boss_tier = 1,
        flying_only = false,
        spawned_tick = 0,
        pathing_entity = nil,
        pathing_entity_checks = 0,
        attack_last_hp = { 0, 0, 0, 0, 0, 0 },
        victory = false,
        high_level_enemy_list = nil, -- Track all high level enemies, they die when the base destroys.
        loading = false,
        spawn_beacons = {},
        assisted_spawners = {},
        total_assisted_spawners = 0
    }
end

local boss_spawnable_index_default = function()
    return {
        chunks = {},
        size = 0,
        retry = 0
    }
end



local start_unit_spawn = function()
    Cron.add_15_sec_queue("BossProcessor.units_spawn")
    Cron.add_15_sec_queue("BossGroupProcessor.process_attack_groups")
    if INCLUDE_SPAWNS then
        BossGroupProcessor.spawn_initial_group()
    end
end

local process_boss_queue = function(event)
    Cron.process_boss_queue()
end

local start_boss_event = function()
    script.on_nth_tick(GlobalConfig.BOSS_QUEUE_CRON, process_boss_queue)
end

local remove_boss_event = function()
    script.on_nth_tick(GlobalConfig.BOSS_QUEUE_CRON, nil)
    Cron.empty_boss_queue()
end

local get_scan_area = {
    [defines.direction.north] = function(x, y)
        return { left_top = { x - scanRadius, y - scanLength }, right_bottom = { x + scanRadius, y - scanMinLength } }
    end,
    [defines.direction.east] = function(x, y)
        return { left_top = { x + scanMinLength, y - scanRadius }, right_bottom = { x + scanLength, y + scanRadius } }
    end,
    [defines.direction.south] = function(x, y)
        return { left_top = { x - scanRadius, y + scanMinLength }, right_bottom = { x + scanRadius, y + scanLength } }
    end,
    [defines.direction.west] = function(x, y)
        return { left_top = { x - scanLength, y - scanRadius }, right_bottom = { x - scanMinLength, y + scanRadius } }
    end,
}

local get_target_direction = function(spawn_position, target_position)
    local diffThreshold = chunkSize * 3
    local direction = defines.direction.south
    if (spawn_position.x - target_position.x) > diffThreshold then
        direction = defines.direction.west
    elseif ((spawn_position.x - target_position.x) < (diffThreshold * -1)) then
        direction = defines.direction.east
    elseif ((spawn_position.y - target_position.y) > diffThreshold) then
        direction = defines.direction.north
    end

    if DEBUG_MODE then
        local directionText = { ["0"] = "North", ["2"] = "East", ["4"] = "South", ["6"] = "West" }
        DebugHelper.print("BossProcessor: Targeting Direction: " .. directionText[tostring(direction)])
        DebugHelper.print(serpent.block(spawn_position))
        DebugHelper.print(serpent.block(target_position))
    end

    return direction
end

local can_build_spawn_building = function()
    local boss_tier = storage.boss.boss_tier
    local nearby_buildings = storage.boss.surface.find_entities_filtered({
        position = storage.boss.entity_position,
        radius = spawnRadius,
        type = enemy_buildings,
        force = storage.boss.force
    })
    if #nearby_buildings >= GlobalConfig.BOSS_MAX_SUPPORT_STRUCTURES[boss_tier] then
        return false
    end

    return true
end

local spawn_building = function()
    return nil
    
    --if true or not can_build_spawn_building() then
    --    return
    --end

    --local boss = storage.boss
    --local boss_tier = boss.boss_tier
    --for i = 1, GlobalConfig.BOSS_SPAWN_SUPPORT_STRUCTURES[boss_tier] do
    --    local building_name
    --    if RaceSettingsHelper.can_spawn(7) then
    --        building_name = BaseBuildProcessor.getBuildingName(boss.force_name, "cc")
    --    elseif RaceSettingsHelper.can_spawn(45) then
    --        building_name = BaseBuildProcessor.getBuildingName(boss.force_name, "support")
    --    else
    --        building_name = BaseBuildProcessor.getBuildingName(boss.force_name, "turret")
    --    end
    --
    --    BaseBuildProcessor.build(
    --            boss.surface,
    --            building_name,
    --            boss.force_name,
    --            boss.entity_position
    --    )
    --end
end

local destroy_beacons = function()
    local beacons = storage.boss.surface.find_entities_filtered { name = beacon_name, type = "radar" }
    for i = 1, #beacons do
        beacons[i].destroy()
    end
end

local unset_boss_data = function()
    storage.boss = boss_setting_default()
    for _, spawn_data in pairs(storage.boss_attack_groups) do
        Cron.add_quick_queue("BossProcessor.remove_boss_groups", spawn_data)
    end

    Cron.add_quick_queue("BossProcessor.remove_boss_groups", storage.boss_group_spawn)

    storage.boss_attack_groups = {}
    storage.boss_group_spawn = BossGroupProcessor.get_default_data()
    storage.boss_spawnable_index = boss_spawnable_index_default()
    remove_boss_event()
end

local spawn_unit_attack = function()
    if INCLUDE_SPAWNS then
        BossGroupProcessor.spawn_defense_group()
    end
    return false, true
end

local spawn_base_attack = function()
    if INCLUDE_SPAWNS then
        spawn_building()
    end
    return false, true
end

local basic_attack = function()
    BossAttackProcessor.exec_basic()
    return true, false
end

local advanced_attack = function()
    BossAttackProcessor.exec_advanced()
    return true, false
end

local super_attack = function()
    BossAttackProcessor.exec_super()
    return true, false
end

local phase_change = function()
    return false, false
end

--- Phase change + 5 attacks
local attack_functions = {
    phase_change,
    super_attack,
    spawn_unit_attack,
    spawn_base_attack,
    advanced_attack,
    basic_attack
}

local initialize_result_log = function(force_name)
    local default_best_record = {
        tier = 1,
        time = -1,
    }
    if storage.boss_logs[force_name] == nil then
        storage.boss_logs[force_name] = {
            best_record = default_best_record,
            entries = {}
        }
    end
end

local has_better_record = function(current_best_record, record)
    local force_name = record.race
    return record.tier == current_best_record.tier and
            ((storage.boss_logs[force_name].best_record.time == -1) or
                    (record.last_tick - record.spawn_tick) < storage.boss_logs[force_name].best_record.time)
end

local update_best_time = function(record)
    local force_name = record.race
    local current_best_record = storage.boss_logs[force_name].best_record
    if record.victory and (record.tier > current_best_record.tier or has_better_record(current_best_record, record)) then
        storage.boss_logs[force_name].best_record.tier = record.tier
        storage.boss_logs[force_name].best_record.time = record.last_tick - record.spawn_tick
    end
end

local write_result_log = function(victory)
    local boss = storage.boss
    
    initialize_result_log(boss.force_name)

    local record = {
        race = boss.force_name,
        tier = boss.boss_tier,
        victory = victory,
        surface = boss.surface_name,
        location = boss.entity_position,
        spawn_tick = boss.spawned_tick,
        last_tick = game.tick
    }
    table.insert(storage.boss_logs[boss.force_name].entries, record)

    update_best_time(record)
end

function BossProcessor.init_globals()
    storage.boss = storage.boss or boss_setting_default()
    storage.boss_attack_groups = storage.boss_attack_groups or {}
    storage.boss_group_spawn = storage.boss_group_spawn or BossGroupProcessor.get_default_data()
    storage.boss_spawnable_index = storage.boss_spawnable_index or boss_spawnable_index_default()
    storage.boss_rewards = storage.boss_rewards or {}
    storage.boss_logs = storage.boss_logs or {}
end

--- Start the boss spawn flow
function BossProcessor.exec(radar, spawn_position)
    DebugHelper.print("BossProcessor: Check radar valid...")
    if radar and radar.valid and storage.boss.loading == false and
            (storage.boss.entity == nil or storage.boss.entity.valid == false) then
        storage.boss.loading = true
        local surface = radar.surface
        local name_tokens = ForceHelper.get_name_token(radar.name)
        local force_name = name_tokens[1]

        if force_name == nil then
            DebugHelper.print("Force name not found")
            return nil
        end

        if not RaceSettingsHelper.has_boss(force_name) then
            game.print("Unable to spawn boss on unsupported race: " .. force_name)
            return nil
        end

        local force = game.forces[force_name]
        DebugHelper.print("BossProcessor: Data setup...")
        storage.boss.force = force
        storage.boss.force_name = force.name
        storage.boss.surface = surface
        storage.boss.surface_name = surface.name
        storage.boss.spawned_tick = game.tick
        local boss_tier = RaceSettingsHelper.boss_tier(storage.boss.force_name)
        storage.boss.boss_tier = boss_tier
        local boss_quality = nil
        if boss_tier > 1 then
            boss_quality = qualities[boss_tier - 1]
            storage.boss.quality = boss_quality
        end

        if storage.boss_spawnable_index.size == 0 and spawn_position == nil then
            surface.print("Unable to find a boss spawner.  Please try again.")
            BossProcessor.unset()
            return
        end

        if not Position.is_position(spawn_position) then
            spawn_position = radar.position
            storage.boss.target_position = spawn_position
            storage.boss.target_direction = get_target_direction(spawn_position, radar.position)
        end

        local entities = surface.find_entities_filtered {
            type = enemy_entities,
            area = {
                top_left = { spawn_position.x - cleanChunkSize, spawn_position.y - cleanChunkSize },
                bottom_right = { spawn_position.x + cleanChunkSize, spawn_position.y + cleanChunkSize }
            }
        }
        DebugHelper.print("BossProcessor: destroy entities: " .. #entities)
        for i = 1, #entities do
            entities[i].destroy()
        end

        force.set_evolution_factor(1, surface)
        local boss_name = BossProcessor.get_boss_name(force_name)
        DebugHelper.print("BossProcessor: Creating Boss Base...")
        DebugHelper.print(boss_name)
        local boss_spawn_location = surface.find_non_colliding_position(boss_name, spawn_position, chunkSize, 1, true)
        storage.skip_quality_rolling = true
        local boss_entity = surface.create_entity {
            name = boss_name,
            position = boss_spawn_location,
            force = force,
            spawn_decorations = true,
            quality = boss_quality
        }
        
        print(serpent.block(spawn_position))
        print(serpent.block(boss_spawn_location))
        print(serpent.block(boss_entity))

        local entities = surface.find_entities_filtered {
            name = boss_name,
            limit = 1
        }
        print(serpent.block(entities))
        
        if not boss_entity then
            storage.boss = boss_setting_default()
            storage.boss.radar = radar
            return
        end

        for _, value in pairs(ForceHelper.get_player_forces()) do
            DebugHelper.print("BossProcessor: Add Beacon for " .. value)
            local boss_beacon_entity = surface.create_entity {
                name = beacon_name,
                position = spawn_position,
                force = value
            }
            boss_beacon_entity.destructible = false
        end

        DebugHelper.print("BossProcessor: Assign Entities...")
        storage.boss.entity = boss_entity
        storage.boss.attack_last_hp = {
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health,
            boss_entity.health
        }
        storage.boss.entity_name = boss_entity.name
        storage.boss.entity_position = boss_entity.position

        game.print({
            "description.boss-base-spawn-at",
            SurfaceProcessor.get_gps_message(
                    spawn_position.x,
                    spawn_position.y,
                    surface.name
            )
        })

        DebugHelper.print("BossProcessor: Create Pathing Unit...")
        local pathing_entity_name = BossProcessor.get_pathing_entity_name(force_name)
        DebugHelper.print(pathing_entity_name)
        local pathing_spawn_location = surface.find_non_colliding_position(pathing_entity_name, spawn_position, chunkSize, 1, true)
        DebugHelper.print(pathing_spawn_location)
        storage.skip_quality_rolling = true
        local pathing_entity = surface.create_entity {
            name = pathing_entity_name,
            position = pathing_spawn_location,
            force = force
        }
        DebugHelper.print(pathing_entity)
        local command = {
            type = defines.command.attack,
            target = radar,
            distraction = defines.distraction.by_damage
        }
        pathing_entity.commandable.set_command(command)
        storage.boss.pathing_entity = pathing_entity
        Cron.add_2_sec_queue("BossProcessor.check_pathing")
        Cron.add_2_sec_queue("BossProcessor.heartbeat")
        start_boss_event()
    end
end

function BossProcessor.check_pathing()
    local boss = storage.boss

    if storage.boss.entity == nil then
        return
    end

    if boss.pathing_entity_checks == 5 then
        local pathing_entity = boss.pathing_entity
        DebugHelper.print("BossProcessor: Comparing path unit position")
        if pathing_entity and pathing_entity.valid then
            if pathing_entity.commandable.spawner then
                DebugHelper.print("BossProcessor: flying only [attached spawner]")
                storage.boss.flying_only = true
                --start_unit_spawn()
                storage.boss.loading = false
                return
            end

            local boss_base = pathing_entity.surface.find_entities_filtered { name = boss.entity_name, position = pathing_entity.position, radius = chunkSize / 2 }
            if boss_base and boss_base[1] then
                DebugHelper.print("BossProcessor: flying only [unit proximity]")
                DebugHelper.print(#boss_base)
                DebugHelper.print(boss_base[1].name)
                storage.boss.flying_only = true
                --start_unit_spawn()
                storage.boss.loading = false
                return
            end
        end
        DebugHelper.print("BossProcessor: Not a flying only boss ")
        --start_unit_spawn()
        storage.boss.loading = false
        return
    end

    DebugHelper.print("BossProcessor: Waiting to check path unit")
    storage.boss.pathing_entity_checks = storage.boss.pathing_entity_checks + 1
    Cron.add_2_sec_queue("BossProcessor.check_pathing")
end

function BossProcessor.get_boss_name(force_name)
    if storage.race_settings[force_name].boss_building then
        return RaceSettingsHelper.get_race_entity_name(
                force_name,
                storage.race_settings[force_name].boss_building,
                math.min(5, storage.boss.boss_tier)
        )
    end

    return nil
end

function BossProcessor.get_pathing_entity_name(force_name)
    return RaceSettingsHelper.get_race_entity_name(
            force_name,
            storage.race_settings[force_name].pathing_unit,
            5
    )
end

local display_victory_dialog = function(boss)
    if storage.race_settings[boss.force_name].boss_tier >= GlobalConfig.BOSS_MAX_TIERS then
        return
    end

    local targetPlayer = nil
    for _, player in pairs(game.players) do
        if player.valid and player.connected and player.surface == boss.surface then
            targetPlayer = player
            break
        end
    end

    if targetPlayer == nil then
        for _, player in pairs(game.players) do
            if player.valid and player.connected then
                targetPlayer = player
                break
            end
        end
    end

    if targetPlayer then
        GuiContainer.victory_dialog.show(targetPlayer, storage.race_settings[boss.force_name])
    end
end

function BossProcessor.heartbeat()
    local boss = storage.boss
    local current_tick = game.tick
    local max_attacks = GlobalConfig.BOSS_MAX_ATTACKS_PER_HEARTBEAT[boss.boss_tier]
    if boss.victory then
        -- start reward process
        storage.race_settings[boss.force_name].boss_kill_count = storage.race_settings[boss.force_name].boss_kill_count + 1
        write_result_log(true)
        display_victory_dialog(boss)
        BossRewardProcessor.exec()
        BossProcessor.unset()
        DebugHelper.print("BossProcessor: is victory")
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    if not boss.radar and not boss.radar.valid then
        -- start despawn process
        DebugHelper.print("BossProcessor: Defeated, start despawn process")
        write_result_log(false)
        BossDespawnProcessor.exec()
        BossProcessor.unset()
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    if not RaceSettingsHelper.is_in_boss_mode() then
        destroy_beacons()
        unset_boss_data()
        DebugHelper.print("BossProcessor: No longer in boss mode")
        DebugHelper.print("BossProcessor: Heartbeat stops")
        return
    end

    local boss_direct_attack = false
    local performed_attacks = 0
    for index, last_hp in pairs(boss.attack_last_hp) do
        local direct_attack = false
        local spawn_attack = false
        if last_hp - boss.entity.health > GlobalConfig.BOSS_DEFENSE_ATTACKS[index] then
            storage.boss.attack_last_hp[index] = boss.entity.health
            DebugHelper.print("BossProcessor: Attack Index " .. index .. " @ " .. boss.entity.health)
            direct_attack, spawn_attack = attack_functions[index]()
            performed_attacks = performed_attacks + 1

            if direct_attack then
                boss_direct_attack = true
            end

            if max_attacks == performed_attacks then
                break
            end
        end
    end

    if boss_direct_attack then
        BossAttackProcessor.unset_attackable_entities_cache()
    end
    
    Cron.add_2_sec_queue("BossProcessor.heartbeat")
end


--- Queue to spawn boss units
--- @see enemyracemanager/control.lua
function BossProcessor.units_spawn()
    if not RaceSettingsHelper.is_in_boss_mode() then
        DebugHelper.print("BossProcessor: units_spawn stops...")
        return
    end

    if INCLUDE_SPAWNS then
        BossGroupProcessor.spawn_regular_group()
        Cron.add_15_sec_queue("BossProcessor.units_spawn")
    end
end

function BossProcessor.get_boss_quality()
    return storage.boss.quality
end

function BossProcessor.unset()
    if RaceSettingsHelper.is_in_boss_mode() then
        storage.boss.entity.destroy()
        DebugHelper.print("BossProcessor: destroy boss base...")
    end
    destroy_beacons()
    unset_boss_data()
    DebugHelper.print("BossProcessor: unset...")
end

--- Build boss spawner
--- @see enemyracemanager/control.lua
function BossProcessor.build_spawner(surface, name, force, position)
    if not RaceSettingsHelper.is_in_boss_mode() or not can_build_spawn_building() then
        return
    end

    BaseBuildProcessor.build(surface, name, force, position)
end

function BossProcessor.remove_boss_groups(spawn_data)
    if spawn_data.group and spawn_data.group.valid then
        DebugHelper.print("BossProcessor: Removing boss attack groups...")
        for _, member in pairs(spawn_data.group.members) do
            if member.valid then
                member.destroy()
            end
        end
    end
end

function BossProcessor.assisted_spawner_spawns(event)
    local spawner_entity = event.source_entity
    if spawner_entity then
        storage.boss.assisted_spawners[spawner_entity.unit_number] = {
            entity = spawner_entity,
            last_health = spawner_entity.get_health_ratio()
        }
        storage.boss.total_assisted_spawners = storage.boss.total_assisted_spawners + 1 
    end 
end

--- Deduct boss health when assist spawner dies.
function BossProcessor.assisted_spawner_dies(event)
    local spawner_entity = event.source_entity
    local boss_entity = storage.boss.entity
    if not boss_entity or not spawner_entity  then
        return
    end
    
    boss_entity.health = boss_entity.health - (spawner_entity.max_health * ASSISTED_SPAWNER_DEATH_RATIO)
    storage.boss.assisted_spawners[spawner_entity.unit_number] = nil
    storage.boss.total_assisted_spawners = math.max(storage.boss.total_assisted_spawners - 1, 0)
end

return BossProcessor