---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 1/5/2024 9:03 PM
---
local Position = require("__erm_libs__/stdlib/position")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local AttackGroupBeaconProcessor = require("__enemyracemanager__/lib/attack_group_beacon_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")
local DebugHelper =  require("__enemyracemanager__/lib/debug_helper")

local can_spawn = RaceSettingsHelper.can_spawn

local AttackGroupPathingProcessor = {}

local BEACON_RADIUS = 64
local CHUNK_SIZE = 32
local TRANSLATE_RANGE = CHUNK_SIZE * 10
local GC_TICK = 25000 * 4

--- lowest defense beacon score
AttackGroupPathingProcessor.STRATEGY_BF = 1
--- left side
AttackGroupPathingProcessor.STRATEGY_LT = 2
--- right side
AttackGroupPathingProcessor.STRATEGY_RT = 3

--- {strategy_id, spawn_chance}
AttackGroupPathingProcessor.CUSTOM_STRATEGIES = {
    {AttackGroupPathingProcessor.STRATEGY_LT, 20},
    {AttackGroupPathingProcessor.STRATEGY_RT, 20}
}

-- Lowest health first
local function get_sorted_beacons(entities)
    table.sort(entities, function(a, b)
        return a.health < b.health
    end)

    return entities
end

local function get_command_chain()
    return {
        type = defines.command.compound,
        structure_type = defines.compound_command.return_last,
        commands = {}
    }
end

local BUFFER_MULTIPLIER = 2
local compute_beacon_buffer_position = {
    [defines.direction.north] = function(x, y)
        return {x=x,y=y + CHUNK_SIZE * BUFFER_MULTIPLIER}
    end,
    [defines.direction.east] = function(x, y)
        return {x=x - CHUNK_SIZE * BUFFER_MULTIPLIER,y=y}
    end,
    [defines.direction.south] = function(x, y)
        return {x=x, y=y - CHUNK_SIZE * BUFFER_MULTIPLIER}
    end,
    [defines.direction.west] = function(x, y)
        return {x=x + CHUNK_SIZE * BUFFER_MULTIPLIER, y=y}
    end,
}



function AttackGroupPathingProcessor.init_globals()
    storage.request_path = storage.request_path or {}
    storage.request_path_link = storage.request_path_link or {}
end

function AttackGroupPathingProcessor.reset_globals()
    storage.request_path = {}
    storage.request_path_link = {}
end

function AttackGroupPathingProcessor.request_path(surface, source_force, start, goal, is_aerial, group_number)

    local bounding_box, collision_mask
    local race_name = ForceHelper.extract_race_name_from(source_force.name)
    collision_mask = {layers={},not_colliding_with_itself=true}

    local scout_name
    if is_aerial then
        scout_name = AttackGroupBeaconProcessor.get_scout_name(race_name,AttackGroupBeaconProcessor.AERIAL_SCOUT)
    else
        scout_name = AttackGroupBeaconProcessor.get_scout_name(race_name,AttackGroupBeaconProcessor.LAND_SCOUT)
    end

    local data_table = prototypes.get_entity_filtered({{
           filter = "name",
           name = scout_name
       }})

    bounding_box = data_table[scout_name].collision_box

    local request_id = surface.request_path({
        bounding_box = bounding_box,
        collision_mask = collision_mask,
        start = start,
        goal = goal,
        force = source_force,
        path_resolution_modifier = -6 ---64 tiles resolution
    })

    if request_id then
        AttackGroupPathingProcessor.remove_node(surface.index,group_number)

        storage.request_path[request_id] = {
            surface = surface,
            source_force = source_force,
            start = start,
            goal = goal,
            is_aerial = is_aerial,
            tick = game.tick,
            commands = {}
        }


        storage.request_path_link[group_number] = request_id
    end
end

--- How does this work?
--- Once request path is valid, pick the closest beacon in the path.
--- If it"flier group, flier beacons get priority
--- Try alt path A using that beacon, save to cache,
--- Try alt path B using that beacon, save to cache,
--- Then try using beacon with lower health.
--- Once all options have tried and failed, unleash additional strategies or repeat existing strategies :)
function AttackGroupPathingProcessor.on_script_path_request_finished(path_id, path_nodes, tryagainlater)
    if storage.request_path[path_id] == nil or path_nodes == nil then
        return nil
    end

    local request_path_data = storage.request_path[path_id];

    if path_nodes then

        local source_force = request_path_data.source_force
        local surface = request_path_data.surface
        for key, path_node in pairs(path_nodes) do

            local search_beacons = {AttackGroupBeaconProcessor.LAND_BEACON, AttackGroupBeaconProcessor.AERIAL_BEACON}
            local beacons = surface.find_entities_filtered {
                name = search_beacons,
                force = source_force,
                radius = BEACON_RADIUS,
                position = path_node.position,
                limit = 1
            }
            local beacon_idx, beacon = next(beacons)
            if beacon then
                local enemy = surface.find_nearest_enemy({
                    position = beacon.position,
                    max_distance = BEACON_RADIUS,
                    force = source_force
                })

                if enemy then
                    Cron.add_quick_queue("AttackGroupPathingProcessor.construct_brutal_force_commands",
                            path_id, beacon, enemy.position, search_beacons)

                    Cron.add_quick_queue("AttackGroupPathingProcessor.construct_side_attack_commands",
                            path_id, path_node, enemy.position, search_beacons)

                    Cron.add_quick_queue("AttackGroupPathingProcessor.construct_side_attack_commands",
                            path_id, path_node, enemy.position, search_beacons, true)
                else
                    if beacon.name == AttackGroupBeaconProcessor.LAND_BEACON then
                        storage[AttackGroupBeaconProcessor.LAND_BEACON][beacon.surface.index][beacon.force.name][beacon.unit_number] = nil
                    else
                        storage[AttackGroupBeaconProcessor.AERIAL_BEACON][beacon.surface.index][beacon.force.name][beacon.unit_number] = nil
                    end
                    beacon.destroy()
                end
                break
            end
        end

    end
end

--- Brutal Force attack using defense beacon data
function AttackGroupPathingProcessor.construct_brutal_force_commands(
        path_id, path_node, enemy_position, search_beacons
)

    local request_path_data = storage.request_path[path_id]

    if request_path_data == nil then
        return
    end

    local direction = Position.complex_direction_to(path_node.position, enemy_position)

    local left_top = {}
    local bottom_right = {}

    if direction == defines.direction.west or
        direction ==  defines.direction.east then
        left_top = {path_node.position.x - CHUNK_SIZE, path_node.position.y - TRANSLATE_RANGE}
        bottom_right = {path_node.position.x + CHUNK_SIZE, path_node.position.y + TRANSLATE_RANGE}
    else
        left_top = {path_node.position.x  - TRANSLATE_RANGE, path_node.position.y - CHUNK_SIZE}
        bottom_right = {path_node.position.x + TRANSLATE_RANGE, path_node.position.y + CHUNK_SIZE}
    end

    local beacons = request_path_data.surface.find_entities_filtered {
        name = search_beacons,
        force = request_path_data.source_force,
        area = {left_top, bottom_right}
    }

    if table_size(beacons) > 1 then
        beacons = get_sorted_beacons(beacons)
    end

    local scout_beacon = beacons[1]
    local buffer_zone = compute_beacon_buffer_position[direction](scout_beacon.position.x,scout_beacon.position.y)

    if scout_beacon then
        local commands_chain = get_command_chain()
        table.insert(commands_chain.commands, {
            type = defines.command.go_to_location,
            destination = buffer_zone,
            radius = CHUNK_SIZE
        })

        table.insert(commands_chain.commands, {
            type = defines.command.attack_area,
            destination = request_path_data.goal,
            radius = CHUNK_SIZE;
        })

        storage.request_path[path_id].commands[AttackGroupPathingProcessor.STRATEGY_BF] = commands_chain
    end
end

--- Side attacks to avoid defense
function AttackGroupPathingProcessor.construct_side_attack_commands(
    path_id, path_node, enemy_position, search_beacons, is_right_side
)
    is_right_side = is_right_side or false

    local request_path_data = storage.request_path[path_id]

    if request_path_data == nil then
        return
    end

    local direction = Position.complex_direction_to(path_node.position, enemy_position)


    local target_direction, side_key
    if is_right_side then
        target_direction = math.abs(direction + 20 % 16)
        side_key = AttackGroupPathingProcessor.STRATEGY_RT
    else
        target_direction = math.abs(direction - 20 % 16)    
        side_key = AttackGroupPathingProcessor.STRATEGY_LT 
    end
    local new_position = Position.translate(
            path_node.position,
            target_direction,
            math.random(TRANSLATE_RANGE-CHUNK_SIZE, TRANSLATE_RANGE+CHUNK_SIZE)
    )

    if DEBUG_MODE then
        DebugHelper.drawline(request_path_data.surface.index, "enemy to new pos", {r=0,g=0,b=1,a=0.5}, new_position, enemy_position)
        DebugHelper.drawline(request_path_data.surface.index, "path node to new pos", {r=1,g=0,b=0,a=0.5}, path_node.position, new_position)
    end

    local area = request_path_data.surface.count_entities_filtered {
        name = search_beacons,
        force = request_path_data.source_force,
        radius = BEACON_RADIUS,
        position = {new_position.x, new_position.y},
        limit = 1
    }


    if area == 0 then
        local commands_chain = get_command_chain()

        table.insert(commands_chain.commands, {
            type = defines.command.go_to_location,
            destination = {new_position.x, new_position.y},
            radius = CHUNK_SIZE
        })

        table.insert(commands_chain.commands, {
            type = defines.command.attack_area,
            destination = request_path_data.goal,
            radius = CHUNK_SIZE;
        })

        if DEBUG_MODE then
            DebugHelper.drawline(request_path_data.surface.index, "new pos to destination", {r=1,g=0,b=1,a=0.5}, new_position, request_path_data.goal)
        end            

        storage.request_path[path_id].commands[side_key] = commands_chain
    end
end

local can_reroll = function(strategy, chance)
    return strategy == AttackGroupPathingProcessor.STRATEGY_BF and can_spawn(chance)
end

--- Get command based on coordinate and strategy
function AttackGroupPathingProcessor.get_command(group_number, strategy)
    strategy = strategy or AttackGroupPathingProcessor.STRATEGY_BF

    if storage.override_attack_strategy then
        strategy = storage.override_attack_strategy
        storage.override_attack_strategy = nil
    else
        for _, data in pairs(AttackGroupPathingProcessor.CUSTOM_STRATEGIES) do
            if can_reroll(strategy, data[2]) then
                strategy = data[1]
                break
            end
        end
    end

    local request_id = storage.request_path_link[group_number]

    if request_id then
        local request_path_data = storage.request_path[request_id]
        if request_path_data and
           request_path_data.commands[strategy]
        then
            local rc_command = request_path_data.commands[strategy]
            AttackGroupPathingProcessor.remove_node(group_number)

            return rc_command
        end
    end

    return nil
end

function AttackGroupPathingProcessor.relink_request(old_group_number, new_group_number)
    local request_id = storage.request_path_link[old_group_number]

    if request_id then
        storage.request_path_link[new_group_number] = request_id
        storage.request_path_link[old_group_number] = nil
    end
end

--- Remove node based on coorindate
function AttackGroupPathingProcessor.remove_node(group_number)

    local request_id = storage.request_path_link[group_number]

    if request_id then
        storage.request_path[request_id] = nil
        storage.request_path_link[group_number] = nil
    end
end


function AttackGroupPathingProcessor.remove_old_nodes()
    for id, _ in pairs(storage.request_path_link) do
        local request_id = storage.request_path_link[id]
        if request_id and
            game.tick > storage.request_path[request_id].tick + GC_TICK
        then
            storage.request_path[request_id] = nil
            storage.request_path_link[id] = nil
        end
    end
end


return AttackGroupPathingProcessor