---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 12/12/2023 11:02 PM
---
require("util")

local ForceHelper = require("helper/force_helper")
local RaceSettingsHelper = require("helper/race_settings_helper")
local Configs = require("global_config")
local Cron = require("__enemyracemanager__/lib/cron_processor")

local Position = require("__erm_libs__/stdlib/position")

local AttackGroupBeaconProcessor = {}

--- Beacon radius for defense, resource and attack entity beacons
local BEACON_RADIUS = 64
--- Beacon Radius for spawner beacon
local SPAWNER_BEACON_RADIUS = 160
local ATTACK_ENTITIES_SCAN_RADIUS = BEACON_RADIUS * 2

local RESOURCE_SCAN_RADIUS = BEACON_RADIUS * 2
local PREVENT_RESOURCE_SCAN_RADIUS = RESOURCE_SCAN_RADIUS * 2

local BEACON_HEALTH_LIMIT = 200
--- Beacon Names
local AERIAL_BEACON = "erm_aerial_beacon"
local LAND_BEACON = "erm_land_beacon"
local SPAWN_BEACON = "erm_spawn_beacon"
local ATTACK_ENTITIES_BEACON = "erm_attackable_entity_beacon"
local ATTACK_ENTITIES_SPAWN_BEACON = "erm_ae_spawn_beacon"
local RESOURCE_BEACON = "erm_resource_beacon"
local BEACON_TYPE = "simple-entity-with-owner"
local RESOURCE_BEACON_ACCEPTANCE_LIMIT = 50
local LAND_SCOUT = "--land_scout--"
local AERIAL_SCOUT = "--aerial_scout--"
local ALL_BEACONS = { SPAWN_BEACON, LAND_BEACON, AERIAL_BEACON, ATTACK_ENTITIES_BEACON, RESOURCE_BEACON }
local ATTACKABLE_ENTITY_TYPES = {
    "mining-drill",
    "furnace",
    "rocket-silo",
    "artillery-turret",
    "lab",
    "agricultural-tower",
}
local INDEXABLE_ATTACKABLE_ENTITY_TYPES = {
    "rocket-silo",
    "artillery-turret",
}

local CONTROL_DATA = "cdata"
local ATTACK_ENTITIES_CURRENT_KEY = "aeck"
local ATTACK_ENTITIES_SELECTED_KEY = "aesk"
local ATTACK_ENTITIES_TARGET_FORCE = "aetf"

local SPAWN_BEACON_SCAN_DIRECTION = "sbsd"
local SPAWN_BEACON_SCAN_TIER = "sbst"
local INIT_SPAWN_BEACON_SCAN_DIRECTION = "isbsd"
local SCOUT_SPAWN_KEY = "ssk"

local NEUTRAL_FORCE = "neutral"

local RETRY = 5
local BYPASS_RETRY = 350000 -- two nauvis week. (1.5hr RLT)
if TEST_MODE then
    BYPASS_RETRY = 120
end
local REMOVE_ATTACK_ENTITY_BEACON_COUNTS = 0
local SCOUT_KEEP_ALIVE = 1800 -- Keep alive 30s when idle
local LAST_RESORT_RADIUS = 384 -- 12 chunks

--- Scan up to 5KM from each side. Min distance 5 chunks, 6 tiers to scan.
local SCAN_DISTANCE = { { 160, 700 }, { 700, 1300 }, { 1300, 2100 }, { 2100, 2900 }, { 2900, 3800 }, { 3800, 5000 }}
local MAX_TIERS = #SCAN_DISTANCE
local SCAN_HALF_WIDTH = 256
local TOTAL_DIRECTIONS = 4


local bounding_box_calc = {
    [defines.direction.north] = function(target_position, range)
        return {
            { target_position.x - SCAN_HALF_WIDTH, target_position.y - range[2] },
            { target_position.x + SCAN_HALF_WIDTH, target_position.y - range[1] },
        }
    end,
    [defines.direction.east] = function(target_position, range)
        return {
            { target_position.x + range[1], target_position.y - SCAN_HALF_WIDTH },
            { target_position.x + range[2], target_position.y + SCAN_HALF_WIDTH },
        }
    end,
    [defines.direction.south] = function(target_position, range)
        return {
            { target_position.x - SCAN_HALF_WIDTH, target_position.y + range[1] },
            { target_position.x + SCAN_HALF_WIDTH, target_position.y + range[2] },
        }
    end,
    [defines.direction.west] = function(target_position, range)
        return {
            { target_position.x - range[2], target_position.y - SCAN_HALF_WIDTH },
            { target_position.x - range[1], target_position.y + SCAN_HALF_WIDTH },
        }
    end
}

local function get_cache_block()
    return {
        --- For refreshing cache, probably once every hour.
        updated = game.tick,
        --- Cache closest beacon in each directions {beacon=nil, skip=false}
        cached_beacon_matrix = {},
        --- Cache searched spawners in each directions.
        cached_spawner_matrix = {},
        --- last resort spawner matrix, if this fails, attack beacon removes itself.
        last_resort_spawner = nil,
        --- Tier only changes when all directions can"t match a spawner.
        tier = 1,
        direction = 0,
        initial_direction = 0,
    }
end

local function count_attackable_entities(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        type = ATTACKABLE_ENTITY_TYPES,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local function count_resource_entities(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        position = entity.position,
        type = "resource",
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local function count_military_entities(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        is_military_target = true,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local function get_an_attackable_entity(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        type = ATTACKABLE_ENTITY_TYPES,
        radius = radius,
        limit = 1,
    }
    local entities = entity.surface.find_entities_filtered(query)
    return entities[1]
end

local function get_next_attack_area(position)
    local distance = BEACON_RADIUS * 2
    local area = {
        { position.x - distance, position.y - distance },
        { position.x + distance, position.y + distance }
    }
    return area
end

local function get_attackable_entity(surface, area)
    local entities = surface.find_entities_filtered({
        area = area,
        type = ATTACKABLE_ENTITY_TYPES,
        limit = 1
    })

    if next(entities) == nil and next(storage.attack_group_attackable_entity_names) then
        entities = surface.find_entities_filtered({
            area = area,
            name = storage.attack_group_attackable_entity_names,
            limit = 1
        })
    end

    return entities
end

local function get_bounding_box_by_direction(target_position, tier, direction)
    local range = SCAN_DISTANCE[tier]
    if bounding_box_calc[direction] then
        return bounding_box_calc[direction](target_position, range)
    end
    return nil
end




local function get_sorted_distance(entities, target_position, desc)
    desc = desc or false
    local distances = {}
    local has_invalid_entity
    for _, entity in pairs(entities) do
        if entity.valid then
            table.insert(distances, {
                entity = entity,
                position = entity.position,
                distance = Position.manhattan_distance(entity.position, target_position)
            })
        else
            has_invalid_entity = true
        end
    end

    if desc then
        table.sort(distances, function(a, b)
            return a.distance > b.distance
        end)
    else
        table.sort(distances, function(a, b)
            return a.distance < b.distance
        end)
    end

    return distances, has_invalid_entity
end


local function get_spawn_area(position)
    local distance = SPAWNER_BEACON_RADIUS / 2
    local area = {
        { position.x - distance, position.y - distance },
        { position.x + distance, position.y + distance }
    }
    return area
end

local function has_nearby_beacon(names, entity, radius, override_force)
    local force = override_force or entity.force.name
    if entity.surface.count_entities_filtered({
        name = names,
        position = entity.position,
        radius = radius,
        force = force,
        limit = 1,
    }) > 0 then
        return true
    end

    return false
end

local function has_nearby_attack_entity_beacon(entity, radius)
    radius = radius or BEACON_RADIUS
    return has_nearby_beacon({ ATTACK_ENTITIES_BEACON }, entity, radius)
end

local function has_nearby_defense_beacon(entity, radius)
    radius = radius or BEACON_RADIUS
    return has_nearby_beacon({ LAND_BEACON, AERIAL_BEACON }, entity, radius)
end

local function has_nearby_resource_beacon(entity, radius)
    radius = radius or BEACON_RADIUS
    return has_nearby_beacon({ RESOURCE_BEACON }, entity, radius, NEUTRAL_FORCE)
end

local function has_nearby_spawn_entity_beacon(entity, radius)
    radius = radius or SPAWNER_BEACON_RADIUS
    return has_nearby_beacon({ SPAWN_BEACON }, entity, radius)
end

local function get_nearby_resource_beacon(entity, radius)
    local entities =  entity.surface.find_entities_filtered {
        name = RESOURCE_BEACON,
        type = BEACON_TYPE,
        position = entity.position,
        radius = radius,
        force = NEUTRAL_FORCE,
        limit = 1,
    }
    local key, node = next(entities)
    if key then
        return node
    end
end

local function is_valid_beacon(beacon)
    return beacon and beacon.valid
end


local function init_beacon_struct(beacon, surface_name, force_name)
    if type(storage[beacon][surface_name]) == "nil" then
        storage[beacon][surface_name] = {}
    end
    if type(storage[beacon][surface_name][force_name]) == "nil" then
        storage[beacon][surface_name][force_name] = {}
    end
end

local function init_beacon_data(beacon, userdata)
    local data = {
        beacon = beacon,
        position = beacon.position,
        created = game.tick,
        updated = game.tick
    }
    if type(userdata) == "table" then
        for k, v in pairs(userdata) do
            data[k] = v
        end
    end
    return data
end

local function update_beacon_data(beacon, userdata)
    if is_valid_beacon(beacon) then
        local surface_index = beacon.surface.index;
        local beacon_name = beacon.name;
        local beacon_number = beacon.unit_number
        local force_name = beacon.force.name
        local beacon = storage[beacon_name][surface_index][force_name][beacon_number]
        beacon.updated = game.tick
        if type(userdata) == "table" then
            for k, v in pairs(userdata) do
                beacon[k] = v
            end
        end
        storage[beacon_name][surface_index][force_name][beacon_number] = beacon;
    end
end

local function create_attack_entity_beacon_from_spawn(surface)
    local beacon_count = 0
    for _, force_name in pairs(ForceHelper.get_player_forces()) do
        local force = game.forces[force_name]
        local position = force.get_spawn_position(surface)

        local beacons = surface.count_entities_filtered({
            name = ATTACK_ENTITIES_BEACON,
            position = { position.x, position.y },
            force = force.name,
            radius = BEACON_RADIUS
        })

        if beacons == 0 then
            beacon_count = beacon_count + 1
            local beacon = surface.create_entity({
                name = ATTACK_ENTITIES_BEACON,
                position = { position.x, position.y },
                force = force.name
            })
            beacon.destructible = false;
            beacon.health = 1;

            init_beacon_struct(ATTACK_ENTITIES_BEACON, surface.index, force.name)
            local beacon_data = init_beacon_data(beacon)
            beacon_data.is_spawn = true
            beacon_data.cache = { }
            storage[ATTACK_ENTITIES_BEACON][surface.index][force.name][beacon.unit_number] = beacon_data

            init_beacon_struct(ATTACK_ENTITIES_SPAWN_BEACON, surface.index, force.name)
            storage[ATTACK_ENTITIES_SPAWN_BEACON][surface.index][force.name] = beacon_data
        end
    end

    return beacon_count
end

local function reindex_surface(surface)
    local spawn_chunk = 0
    local attack_chunk = 0
    local resource_chunk = 0

    local need_spawn_beacon_index = false;
    if storage[SPAWN_BEACON] then
        if storage[SPAWN_BEACON][surface.index] then
            for _, force in pairs(ForceHelper.get_enemy_forces()) do
                if storage[SPAWN_BEACON][surface.index][force] == nil or
                        next(storage[SPAWN_BEACON][surface.index][force]) == nil
                then
                    need_spawn_beacon_index = true;
                    break ;
                end
            end
        else
            need_spawn_beacon_index = true
        end
    end

    local need_attack_entity_beacon_index = false;
    if storage[ATTACK_ENTITIES_BEACON] then
        if storage[ATTACK_ENTITIES_BEACON][surface.index] then
            for _, force in pairs(ForceHelper.get_player_forces()) do
                if storage[ATTACK_ENTITIES_BEACON][surface.index][force] == nil or
                        next(storage[ATTACK_ENTITIES_BEACON][surface.index][force]) == nil
                then
                    need_attack_entity_beacon_index = true;
                    break ;
                end
            end
        else
            need_attack_entity_beacon_index = true
        end
    end

    attack_chunk = attack_chunk + create_attack_entity_beacon_from_spawn(surface)

    for chunk in surface.get_chunks() do
        if need_spawn_beacon_index and AttackGroupBeaconProcessor.create_spawn_beacon_from_trunk(surface, chunk.area) then
            spawn_chunk = spawn_chunk + 1
        end

        if need_attack_entity_beacon_index and AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, chunk.area) then
            attack_chunk = attack_chunk + 1
        end

        if AttackGroupBeaconProcessor.create_resource_beacon_from_trunk(surface, chunk.area) then
            resource_chunk = resource_chunk + 1
        end
    end

    return spawn_chunk, attack_chunk, resource_chunk
end


local get_beacon_node = function(beacon_data, control_key)
    local new_key, node
    if control_key and beacon_data[control_key] then
        new_key, node = next(beacon_data, control_key)
    else
        -- Reset key to a random position
        local table_size = table_size(beacon_data)
        if table_size > 5 then
            local random_position = math.floor(math.random(2,table_size-2))
            local start_pos = 1
            for key, value in pairs(beacon_data) do
                if start_pos == random_position then
                    new_key = key
                    node = value
                    break
                else
                    start_pos = start_pos + 1
                end
            end
        else
            new_key, node = next(beacon_data)
        end
    end

    return new_key, node
end

AttackGroupBeaconProcessor.LAND_BEACON = LAND_BEACON
AttackGroupBeaconProcessor.AERIAL_BEACON = AERIAL_BEACON
AttackGroupBeaconProcessor.ATTACK_ENTITIES_BEACON = ATTACK_ENTITIES_BEACON
AttackGroupBeaconProcessor.SPAWN_BEACON = SPAWN_BEACON
AttackGroupBeaconProcessor.RESOURCE_BEACON = RESOURCE_BEACON
AttackGroupBeaconProcessor.ATTACKABLE_ENTITY_TYPES = ATTACKABLE_ENTITY_TYPES

AttackGroupBeaconProcessor.LAND_SCOUT = LAND_SCOUT
AttackGroupBeaconProcessor.AERIAL_SCOUT = AERIAL_SCOUT

--- Set beacon tracker and control data by force
AttackGroupBeaconProcessor.add_new_force = function(force)
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) and ForceHelper.is_enemy_force(force) then
            for _, beacon in pairs(ALL_BEACONS) do
                init_beacon_struct(beacon, surface.index, force.name)
            end

            if storage[CONTROL_DATA] then
                storage[CONTROL_DATA][surface.index] = storage[CONTROL_DATA][surface.index] or {}
                storage[CONTROL_DATA][surface.index][force.name] = storage[CONTROL_DATA][surface.index][force.name] or {}
            end
        end
    end
end

AttackGroupBeaconProcessor.can_attack = function(surface)
    if storage[SPAWN_BEACON][surface.index] ~= nil and storage[ATTACK_ENTITIES_BEACON][surface.index] ~= nil then
        return true
    end
    return false
end

AttackGroupBeaconProcessor.create_attack_entity_beacon = function(source_entity)
    local surface = source_entity.surface
    local attackable_entity = get_an_attackable_entity(source_entity, ATTACK_ENTITIES_SCAN_RADIUS)

    if attackable_entity and
            attackable_entity.valid and
            has_nearby_attack_entity_beacon(attackable_entity) == false
    then
        --- 128 tile scan radius
        local attackable_entities = count_attackable_entities(attackable_entity, ATTACK_ENTITIES_SCAN_RADIUS)
        if attackable_entities > 0 then
            local beacon = surface.create_entity({
                name = ATTACK_ENTITIES_BEACON,
                position = { attackable_entity.position.x, attackable_entity.position.y },
                force = attackable_entity.force
            })
            beacon.destructible = false;
            beacon.health = attackable_entities;

            init_beacon_struct(ATTACK_ENTITIES_BEACON, surface.index, attackable_entity.force.name)
            local beacon_data = init_beacon_data(beacon)
            beacon_data.cache = {}
            storage[ATTACK_ENTITIES_BEACON][surface.index][attackable_entity.force.name][beacon.unit_number] = beacon_data

            return true
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        local types = INDEXABLE_ATTACKABLE_ENTITY_TYPES
        if storage.attack_beacon_index_all then
            types = ATTACKABLE_ENTITY_TYPES
        end

        for _, force in pairs(ForceHelper.get_player_forces()) do
            local attackable_entities = surface.find_entities_filtered({
                type = types,
                force = force,
                area = area,
                limit = 1,
            })
            local entity_key, entity = next(attackable_entities)
            if entity_key then
                return AttackGroupBeaconProcessor.create_attack_entity_beacon(entity)
            end
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_defense_beacon = function(source_entity, beacon_name)
    if source_entity and source_entity.valid then
        if has_nearby_defense_beacon(source_entity) == false then
            local military_entities = count_military_entities(source_entity)
            if military_entities > 0 then
                local surface = source_entity.surface
                local beacon = surface.create_entity({
                    name = beacon_name,
                    position = { source_entity.position.x, source_entity.position.y },
                    force = source_entity.force
                })
                beacon.destructible = false;
                beacon.health = military_entities;

                init_beacon_struct(beacon_name, surface.index, source_entity.force.name)
                storage[beacon_name][surface.index][source_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
                return true
            end
        else
            -- Update or destroy beacon
            local surface = source_entity.surface
            local beacons = surface.find_entities_filtered({
                name = {LAND_BEACON, AERIAL_BEACON},
                type = BEACON_TYPE,
                position = { source_entity.position.x, source_entity.position.y },
                force = source_entity.force,
                radius = BEACON_RADIUS,
                limit = 1
            })
            if next(beacons) then
                local beacon = beacons[1]
                local military_entities = count_military_entities(source_entity)
                if military_entities == 0 then
                    if beacon.name == LAND_BEACON then
                        storage[LAND_BEACON][surface.index][source_entity.force.name][beacon.unit_number] = nil
                    else
                        storage[AERIAL_BEACON][surface.index][source_entity.force.name][beacon.unit_number] = nil
                    end
                    beacon.destroy()
                else
                    beacon.health = military_entities
                    update_beacon_data(beacon)
                end
            end
        end

        return false
    end
end

AttackGroupBeaconProcessor.create_resource_beacon = function(source_entity)
    if source_entity and source_entity.valid then
        if has_nearby_resource_beacon(source_entity) == false then
            local resource_entities = count_resource_entities(source_entity)
            if source_entity.prototype.infinite_resource or resource_entities > RESOURCE_BEACON_ACCEPTANCE_LIMIT then
                local surface = source_entity.surface
                local beacon = surface.create_entity({
                    name = RESOURCE_BEACON,
                    position = { source_entity.position.x, source_entity.position.y },
                    force = NEUTRAL_FORCE
                })
                beacon.destructible = false;
                beacon.health = resource_entities;

                init_beacon_struct(RESOURCE_BEACON, surface.index, source_entity.force.name)
                storage[RESOURCE_BEACON][surface.index][source_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)

                return true
            end
        end

        return false
    end
end

AttackGroupBeaconProcessor.create_resource_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        local resource_entities = surface.find_entities_filtered({
            type = "resource",
            area = area,
            limit = 1,
        })
        local entity_key = next(resource_entities)
        if entity_key then
            return AttackGroupBeaconProcessor.create_resource_beacon(resource_entities[entity_key])
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_spawn_beacon = function(entity)
    if entity and entity.valid and has_nearby_spawn_entity_beacon(entity) == false then
        local surface_index = entity.surface.index
        local beacon = entity.surface.create_entity({
            name = SPAWN_BEACON,
            position = entity.position,
            force = entity.force
        })
        beacon.destructible = false;

        init_beacon_struct(SPAWN_BEACON, surface_index, entity.force.name)
        storage[SPAWN_BEACON][surface_index][entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
        return true
    end

    return false
end

AttackGroupBeaconProcessor.create_spawn_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
            local spawners = surface.find_entities_filtered({
                type = "unit-spawner",
                force = force_name,
                area = area,
                limit = 1,
            })
            local spawner_key = next(spawners)
            if spawner_key then
                AttackGroupBeaconProcessor.create_spawn_beacon(spawners[spawner_key])
                return true
            end
        end
    end

    return false
end

AttackGroupBeaconProcessor.get_selected_attack_beacon = function(surface, source_force, target_force)
    local selected_key = storage[CONTROL_DATA][surface.index][source_force.name][ATTACK_ENTITIES_SELECTED_KEY]
    local attack_beacons = storage[ATTACK_ENTITIES_BEACON][surface.index][target_force.name]
    if not selected_key or attack_beacons[selected_key] == nil then
        return nil
    end

    return attack_beacons[selected_key];
end

AttackGroupBeaconProcessor.get_control_data = function(surface_index, force_name)
    if force_name then
        return storage[CONTROL_DATA][surface_index][force_name]
    end
    return storage[CONTROL_DATA][surface_index]
end

AttackGroupBeaconProcessor.get_beacon_data = function(beacon_type, surface_index, force_name)
    if force_name then
        return storage[beacon_type][surface_index][force_name]
    end
    return storage[beacon_type][surface_index]
end

AttackGroupBeaconProcessor.get_max_tiers = function()
    return MAX_TIERS
end

AttackGroupBeaconProcessor.init_globals = function()
    for _, beacon in pairs(ALL_BEACONS) do
        storage[beacon] = storage[beacon] or {}
    end
    storage[ATTACK_ENTITIES_SPAWN_BEACON] = storage[ATTACK_ENTITIES_SPAWN_BEACON] or {}
    storage.attack_group_attackable_entity_names = storage.attack_group_attackable_entity_names or {}
    storage[CONTROL_DATA] = storage[CONTROL_DATA] or {}
end

--- This is run in ERM post processor.
AttackGroupBeaconProcessor.init_control_globals = function()
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) then
            storage[CONTROL_DATA][surface.index] = storage[CONTROL_DATA][surface.index] or {}
            for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
                storage[CONTROL_DATA][surface.index][force_name] = storage[CONTROL_DATA][surface.index][force_name] or {}
            end
            for _, force_name in pairs(ForceHelper.get_player_forces()) do
                storage[CONTROL_DATA][surface.index][force_name] = storage[CONTROL_DATA][surface.index][force_name] or {}
            end
        end
    end
end

--- init globals when new surface is made
AttackGroupBeaconProcessor.init_globals_on_surface = function(surface)
    if surface and surface.valid and ForceHelper.can_have_enemy_on(surface) then
        for _, beacon in pairs(ALL_BEACONS) do
            storage[beacon][surface.index] = {}
        end

        if ForceHelper.can_have_enemy_on(surface) then
            storage[CONTROL_DATA][surface.index] = storage[CONTROL_DATA][surface.index] or {}
            for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
                storage[CONTROL_DATA][surface.index][force_name] = storage[CONTROL_DATA][surface.index][force_name] or {}
            end
        end
    end
end

AttackGroupBeaconProcessor.init_index = function()
    local profiler = game.create_profiler()
    local spawn_beacons = 0
    local attack_entity_beacons = 0
    local resource_beacons = 0
    local total_surfaces = 0
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) then
            local current_spawn_beacons, current_attack_beacons, current_resource_beacons = reindex_surface(surface)
            spawn_beacons = spawn_beacons + current_spawn_beacons
            attack_entity_beacons = attack_entity_beacons + current_attack_beacons
            resource_beacons = resource_beacons + current_resource_beacons
            total_surfaces = total_surfaces + 1
        end
    end

    storage.attack_beacon_index_all = nil

    profiler.stop()
    print("[ERM] Total Processed Surfaces: " .. tostring(total_surfaces))
    print("[ERM] Total New Spawnable Beacons: " .. tostring(spawn_beacons))
    print("[ERM] Total New Attackable Beacons: " .. tostring(attack_entity_beacons))
    print("[ERM] Total New Resource Beacons: " .. tostring(resource_beacons))
    game.print({ "", "[ERM] Attack Group Beacons Re-indexed: ", profiler })
end

AttackGroupBeaconProcessor.pick_attack_beacon = function(surface, source_force, target_force, new_beacon)
    local target_beacon
    if new_beacon then
        target_beacon = AttackGroupBeaconProcessor.pick_new_attack_beacon(surface, source_force, target_force)
    else
        target_beacon = AttackGroupBeaconProcessor.get_selected_attack_beacon(surface, source_force, target_force) or
                AttackGroupBeaconProcessor.pick_new_attack_beacon(surface, source_force, target_force)
    end

    return target_beacon
end

---
--- Pick spawn location, based on spawn beacons
---
--- Starts from north with tier 1 distance.
--- If something found, return the position.
--- When no position found, move to next direction (N,E,S,W)
--- Once all sides are found and no position found, move to next tier.
--- When tier and direction reach max.  Removed target_beacon since nothing matches.
---
AttackGroupBeaconProcessor.pick_spawn_location = function(surface, source_force, target_beacon_data, from_cron, use_fallback)
    local target_beacon = target_beacon_data.beacon

    if use_fallback == nil then
        use_fallback = true
    end
    from_cron = from_cron or false

    if target_beacon_data.cache[source_force.name] == nil then
        target_beacon_data.cache[source_force.name] = get_cache_block()
    end

    local cache = target_beacon_data.cache[source_force.name];

    if (cache.bypass or cache.bypass_scanner) and
        game.tick >= cache.updated + BYPASS_RETRY
    then
        cache.bypass = nil
        cache.bypass_scanner = nil
    end

    if cache.bypass then
        return nil, false
    end

    local scan_direction = cache.direction or 0
    if from_cron == false then
        cache.initial_direction = scan_direction
    end
    local tier = cache.tier or 1
    local rc_entity
    local halt_cron = false
    local bounding_box = get_bounding_box_by_direction(target_beacon.position, tier, scan_direction)

    if target_beacon and cache.bypass_scanner == nil then
        --- @TODO comment out for production
        if DEBUG_MODE then
            local force_name = source_force.name
            local color = settings.startup[force_name.."-map-color"].value
            color.a = 0.1
            rendering.draw_rectangle({
                force="player",
                left_top=bounding_box[1],
                right_bottom=bounding_box[2],
                surface=target_beacon.surface,
                filled=true,
                time_to_live=900,
                draw_on_ground=true,
                color=color
            })
        end
        local beacons = cache.cached_beacon_matrix[scan_direction]
        if beacons == nil or beacons.skip == nil
        then
            beacons = surface.find_entities_filtered({
                name = SPAWN_BEACON,
                type = BEACON_TYPE,
                area = bounding_box,
                force = source_force,
                limit = 3,
            })
            cache.updated = game.tick
            if next(beacons) then
                cache.cached_beacon_matrix[scan_direction] = beacons
            else
                cache.cached_beacon_matrix[scan_direction] = { skip = true }
            end
        end

        if beacons and
            beacons.skip == nil and
            next(beacons)
        then
            local distances, has_invalid_beacon = get_sorted_distance(beacons, target_beacon.position)
            if has_invalid_beacon then
                cache.cached_beacon_matrix[scan_direction] = nil
            end

            local spawners = cache.cached_spawner_matrix[scan_direction]
            if spawners == nil then
                spawners = surface.find_entities_filtered({
                    area = get_spawn_area(distances[1].position),
                    force = source_force,
                    type = "unit-spawner",
                    limit = 3
                })
            end

            if next(spawners) then
                if cache.cached_spawner_matrix[scan_direction] == nil then
                    cache.cached_spawner_matrix[scan_direction] = spawners
                end

                repeat
                    local spawners_size = #spawners
                    local index = nil
                    if spawners_size > 1 then
                        index = math.random(1, spawners_size)
                        rc_entity = spawners[index]
                    else
                        index, rc_entity = next(spawners)
                    end

                    if index and (rc_entity == nil or rc_entity.valid == false) then
                        spawners[index] = nil
                    end
                until next(spawners) == nil or (rc_entity and rc_entity.valid)
            else
                -- Destroy spawn beacon if spawner is not found within it.
                storage[SPAWN_BEACON][surface.index][source_force.name][distances[1].entity.unit_number] = nil
                distances[1].entity.destructible = true
                distances[1].entity.destroy()
            end
        end

        scan_direction = ((scan_direction + 4) % 16)

        if rc_entity then
            storage[ATTACK_ENTITIES_BEACON][surface.index][target_beacon.force.name][target_beacon.unit_number] = target_beacon_data
            cache.initial_direction = scan_direction
        else
            local skip_count = 0
            for _, cache_data in pairs(cache.cached_beacon_matrix) do
                if cache_data.skip then
                    skip_count = skip_count + 1
                end
            end

            if skip_count == TOTAL_DIRECTIONS
            then
                tier = tier + 1
                scan_direction = 0
                cache.cached_beacon_matrix = {}
                cache.cached_spawner_matrix = {}
                cache.last_resort_spawner = nil
            end

            if tier > MAX_TIERS then
                tier = 1
                scan_direction = 0
                halt_cron = true
            end
        end

        cache.tier = tier
        cache.direction = scan_direction
    else
        halt_cron = true
    end

    -- Last resort
    if rc_entity == nil and use_fallback == true and halt_cron == true then
        rc_entity = cache.last_resort_spawner
        if rc_entity == nil or rc_entity.valid == false then
            cache.bypass_scanner = true
            local spawners = surface.find_entities_filtered({
                position = target_beacon.position,
                radius = LAST_RESORT_RADIUS,
                force = source_force,
                type = "unit-spawner",
                limit = 1
            })

            local _, spawner = next(spawners)
            if spawner and spawner.valid then
                rc_entity = spawner
                cache.last_resort_spawner = rc_entity
            else
                cache.bypass = true
            end
        end
        cache.updated = game.tick
    end

    return rc_entity, halt_cron
end

AttackGroupBeaconProcessor.pick_current_selected_attack_beacon = function(surface, source_force, clean_selected_key)
    clean_selected_key = clean_selected_key or false

    local control_data = storage[CONTROL_DATA][surface.index][source_force.name]
    local target_force_name = control_data[ATTACK_ENTITIES_TARGET_FORCE]
    local force
    if target_force_name then
        force = game.forces[target_force_name]
    end

    if force == nil then
        return nil
    end

    if control_data[ATTACK_ENTITIES_SELECTED_KEY] == nil then
        AttackGroupBeaconProcessor.pick_attack_beacon(surface, source_force, force)
    end

    local selected_key = control_data[ATTACK_ENTITIES_SELECTED_KEY]
    if selected_key then
        local entity_data = storage[ATTACK_ENTITIES_BEACON][surface.index][force.name][selected_key]
        if entity_data then
            if clean_selected_key then
                control_data[ATTACK_ENTITIES_SELECTED_KEY] = nil
            end
            return entity_data
        end
    end

    return nil
end

AttackGroupBeaconProcessor.pick_new_attack_beacon = function(surface, source_force, target_force)
    local surface_data = storage[ATTACK_ENTITIES_BEACON][surface.index]
    if surface_data == nil or
        surface_data[target_force.name] == nil
    then
        return nil
    end

    local control_data = storage[CONTROL_DATA][surface.index][source_force.name]
    local beacon_data = surface_data[target_force.name]

    local entity_data
    local key, value = get_beacon_node(beacon_data, control_data[ATTACK_ENTITIES_CURRENT_KEY])
    local i = 0
    while i < RETRY and entity_data == nil do
        if value and
                is_valid_beacon(value.beacon)
        then
            if value.beacon.health > REMOVE_ATTACK_ENTITY_BEACON_COUNTS then
                control_data[ATTACK_ENTITIES_TARGET_FORCE] = target_force.name
                control_data[ATTACK_ENTITIES_CURRENT_KEY] = key
                control_data[ATTACK_ENTITIES_SELECTED_KEY] = key

                --- update beacon health when picked.
                local attackable_entities = count_attackable_entities(value.beacon, ATTACK_ENTITIES_SCAN_RADIUS)
                value.beacon.health = attackable_entities

                entity_data = value

                break
            elseif value.beacon.health == REMOVE_ATTACK_ENTITY_BEACON_COUNTS and
                    value.is_spawn == false
            then
                value.beacon.destructible = true
                value.beacon.destroy()
                beacon_data[key] = nil
            end
        elseif value then
            beacon_data[key] = nil
        end
        i = i + 1
        key, value = get_beacon_node(beacon_data, key)
    end

    if entity_data then
        return entity_data
    end

    control_data[ATTACK_ENTITIES_TARGET_FORCE] = nil
    control_data[ATTACK_ENTITIES_SELECTED_KEY] = nil
    control_data[ATTACK_ENTITIES_CURRENT_KEY] = nil
    return nil
end

AttackGroupBeaconProcessor.pick_nearby_attack_location = function(surface, init_position)
    local entities = get_attackable_entity(surface, get_next_attack_area(init_position))

    local next_index = next(entities)
    if next_index then
        local entity = entities[next_index]
        return entity
    end
end

AttackGroupBeaconProcessor.pick_resource_location = function(surface, init_position, direction, distance)
    distance = distance or 960
    local target_range = { 0, distance }
    local bounding_box = bounding_box_calc[direction](init_position, target_range)

    local entities = surface.find_entities_filtered({
        name = RESOURCE_BEACON,
        type = BEACON_TYPE,
        area = bounding_box,
        limit = 10,
    })

    local distances = get_sorted_distance(entities, init_position, true)
    local rc_position

    for _, entity in pairs(entities) do
        if distances[1].position.x == entity.position.x and
                distances[1].position.y == entity.position.y  then
            rc_position = entity.position
            break
        end
    end

    return rc_position
end

--- Reset all beacon data globals
AttackGroupBeaconProcessor.reset_globals = function()
    for _, beacon in pairs(ALL_BEACONS) do
        storage[beacon] = {}
    end

    storage[CONTROL_DATA] = {}
    AttackGroupBeaconProcessor.init_control_globals()
end

--- Remove beacon data on a surface
AttackGroupBeaconProcessor.remove_beacons_on_surface = function(surface_index)
    for _, beacon in pairs(ALL_BEACONS) do
        storage[beacon][surface_index] = nil
    end
    storage[ATTACK_ENTITIES_SPAWN_BEACON][surface_index] = nil
    storage[CONTROL_DATA][surface_index] = nil
end

--- Remove beacon tracker and control data by force
AttackGroupBeaconProcessor.remove_merged_force = function(force_name)
    for _, surface in pairs(game.surfaces) do
        for _, beacon in pairs(ALL_BEACONS) do
            if storage[beacon][surface.index] then
                storage[beacon][surface.index][force_name] = nil
            end
        end

        if storage[CONTROL_DATA][surface.index] then
            storage[CONTROL_DATA][surface.index][force_name] = nil
        end
    end

    AttackGroupBeaconProcessor.init_index()
end

AttackGroupBeaconProcessor.has_attack_entity_beacon = function(surface)
    local surface_data = storage[ATTACK_ENTITIES_BEACON][surface.index]
    if surface_data then
        for _, data in pairs(surface_data) do
            if type(data) == "table" and next(data) then
                return true
            end
        end
    end
    return false
end

AttackGroupBeaconProcessor.get_attackable_spawn_beacon = function(surface, force)
    local surface = storage[ATTACK_ENTITIES_SPAWN_BEACON][surface.index]
    if surface then
        local beacon = surface[force.name]
        if beacon then
            return beacon
        end
    end

    return nil
end

AttackGroupBeaconProcessor.get_spawn_beacon = function(surface, force)
    local beacon_surface = storage[SPAWN_BEACON][surface.index]
    if beacon_surface == nil or
        beacon_surface[force.name] == nil
    then
        return nil
    end

    local i = 0
    local new_key, node
    local control_data = storage[CONTROL_DATA][surface.index][force.name]
    local beacon_data = beacon_surface[force.name]
    repeat
        local control_key = control_data[SCOUT_SPAWN_KEY] or nil
        new_key, node = get_beacon_node(beacon_data, control_key)
        i = i + 1
        if control_key and
            node ~= nil and
            (node.beacon == nil or node.beacon.valid == false)
        then
            -- Wipe data node if beacon is no longer exists
            beacon_data[control_key] = nil
            node = nil
        else
            control_data[SCOUT_SPAWN_KEY] = new_key
        end
    until node ~= nil or i < RETRY

    if node ~= nil then
        return node.beacon
    end
end

AttackGroupBeaconProcessor.start_scout_scan = function()
    local should_repeat = false
    for force_name, entity_data in pairs(storage.scout_tracker) do
        if entity_data.entity.valid then
            should_repeat = true
            Cron.add_quick_queue("AttackGroupBeaconProcessor.scout_scan", force_name, entity_data)
        else
            storage.scout_tracker[force_name] = nil
            storage.scout_by_unit_number[entity_data.unit_number] = nil
        end
    end

    if should_repeat and
            storage.scout_scanner and
            next(storage.scout_tracker) then
        Cron.add_15_sec_queue("AttackGroupBeaconProcessor.start_scout_scan")
    else
        storage.scout_scanner = false
    end
end

AttackGroupBeaconProcessor.scout_scan = function(force_name, entity_data)
    local entity = entity_data.entity
    if entity.valid then
        AttackGroupBeaconProcessor.create_attack_entity_beacon(entity)

        local tracker = storage.scout_tracker[force_name]
        if tracker == nil then
            return
        end

        --- @TODO comment out for production
        if DEBUG_MODE then
            local color = settings.startup[force_name.."-map-color"].value
            color.a = 0.25
            rendering.draw_circle({
                force="player",
                radius=1,
                target=entity.position,
                surface=entity.surface,
                filled=true,
                time_to_live=3600*5,
                color=color,
                draw_on_ground=true
            })
        end

        local commandable = entity.commandable
        local command = commandable.command
        if game.tick > tracker.update_tick + SCOUT_KEEP_ALIVE and
            (command.type == defines.command.wander or
            command.type == defines.command.stop)
        then
            entity.die("neutral")
            storage.scout_by_unit_number[tracker.unit_number] = nil
            storage.scout_tracker[force_name] = nil
        elseif commandable.command.type == defines.command.go_to_location then
            tracker.position = entity.position
            tracker.update_tick = game.tick
        end


        if entity.valid and
            tracker.last_resource_position == nil and
            has_nearby_resource_beacon(entity, RESOURCE_SCAN_RADIUS)
        then
            --- Switch to resource path only if it"heading to final_destination
            if command and command.type == defines.command.go_to_location and
                command.destination.x == tracker.final_destination.x and
                command.destination.y == tracker.final_destination.y
            then
                local beacon = get_nearby_resource_beacon(entity, RESOURCE_SCAN_RADIUS)
                local last_resource_distance = 0
                if tracker.last_resource_position then
                    last_resource_distance = util.distance(beacon.position, tracker.last_resource_position)
                end

                if tracker.last_resource_position == nil or
                    last_resource_distance >= PREVENT_RESOURCE_SCAN_RADIUS
                then
                    commandable.set_command({
                        type = defines.command.go_to_location,
                        destination = beacon.position,
                        radius = 16,
                        distraction = defines.distraction.none
                    })

                    tracker.last_resource_position = beacon.position
                end
            end
        elseif entity.valid and
            command.type == defines.command.wander
        then
            local final_distance = util.distance(tracker.final_destination, entity.position)
            if final_distance > (BEACON_RADIUS / 2) then
                commandable.set_command({
                    type = defines.command.go_to_location,
                    destination = tracker.final_destination,
                    radius = 16,
                    distraction = defines.distraction.none
                })
            end
        end
    else
        storage.scout_by_unit_number[entity_data.unit_number] = nil
        storage.scout_tracker[force_name] = nil
    end
end

AttackGroupBeaconProcessor.get_scout_name = function(force_name, type)
    return force_name..type..RaceSettingsHelper.get_level(force_name)
end

AttackGroupBeaconProcessor.get_max_tiers = function()
    return MAX_TIERS
end

return AttackGroupBeaconProcessor