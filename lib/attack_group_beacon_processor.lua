---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 12/12/2023 11:02 PM
---
require('util')

local Config = require('lib/global_config')
local ForceHelper = require('lib/helper/force_helper')

local AttackGroupBeaconProcessor = {}

local ATTACKABLE_ENTITY_BEACON_WIDTH = 64
local DEFENSE_BEACON_WIDTH = 96
local SPAWNER_BEACON_WIDTH = 320
local RESOURCE_BEACON_WIDTH = 96
local BEACON_HEALTH_LIMIT = 100
local AERIAL_BEACON = 'erm_aerial_beacon'
local LAND_BEACON = 'erm_land_beacon'
local SPAWN_BEACON = 'erm_spawn_beacon'
local ATTACK_ENTITIES_BEACON = 'erm_attackable_entity_beacon'
local RESOURCE_BEACON = 'erm_resource_beacon'
local RESOURCE_BEACON_ACCEPTANCE_LIMIT = 50
local LAND_SCOUT = '/land_scout'
local AERIAL_SCOUT = '/aerial_scout'
local ALL_BEACONS = {SPAWN_BEACON, LAND_BEACON, AERIAL_BEACON, ATTACK_ENTITIES_BEACON, RESOURCE_BEACON}
local ATTACKABLE_ENTITY_TYPES = {
    'mining-drill',
    'rocket-silo',
    'artillery-turret',
}
local ATTACKABLE_ENTITY_NAMES = {

}
local INDEXABLE_ATTACKABLE_ENTITY_TYPES = {
    'rocket-silo',
}
local INDEXABLE_ATTACKABLE_ENTITY_NAMES = {
}

local PICK_DATA = 'pick_data'
local CURRENT_KEY = 'current'

local NEUTRAL_FORCE = 'neutral'

--- Scan up to 5KM from each side. Min distance 10 chunk
local SCAN_DISTANCE = {{320,1600},{1600,3200},{3200,5000}}

local has_nearby_defense_beacon = function(entity, radius)
    radius = radius or DEFENSE_BEACON_WIDTH
    local query = {
        name = {LAND_BEACON, AERIAL_BEACON},
        position = entity.position,
        radius = radius,
        force = entity.force,
        limit = BEACON_HEALTH_LIMIT,
    }

    if entity.surface.count_entities_filtered(query) > 0 then
        return true
    end

    return false
end

local has_nearby_attack_entity_beacon = function(entity, radius)
    radius = radius or ATTACKABLE_ENTITY_BEACON_WIDTH
    if entity.surface.count_entities_filtered({
        name = ATTACK_ENTITIES_BEACON,
        position = entity.position,
        radius = radius,
        force = entity.force,
        limit = BEACON_HEALTH_LIMIT,
    }) > 0 then
        return true
    end

    return false
end

local has_nearby_spawn_entity_beacon = function(entity, radius)
    radius = radius or SPAWNER_BEACON_WIDTH
    if entity.surface.count_entities_filtered({
        name = SPAWN_BEACON,
        position = entity.position,
        force = ForceHelper.get_player_forces(),
        radius = radius,
        force = entity.force,
        limit = BEACON_HEALTH_LIMIT,
    }) > 0 then
        return true
    end

    return false
end

local has_nearby_resource_beacon = function(entity, radius)
    radius = radius or RESOURCE_BEACON_WIDTH
    if entity.surface.count_entities_filtered({
        name = RESOURCE_BEACON,
        position = entity.position,
        force = NEUTRAL_FORCE,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }) > 0 then
        return true
    end

    return false
end

local count_military_entities = function(entity, radius)
    radius = radius or DEFENSE_BEACON_WIDTH
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        is_military_target = true,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local count_attackable_entities = function(entity, radius)
    radius = radius or DEFENSE_BEACON_WIDTH
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        type = ATTACKABLE_ENTITY_TYPES,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local count_resource_entities = function(entity, radius)
    radius = radius or RESOURCE_BEACON_WIDTH
    local query = {
        position = entity.position,
        type = 'resource',
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local init_beacon_struct = function(beacon, surface_name, force_name)
    if type(global[beacon][surface_name]) == 'nil' then
        global[beacon][surface_name] = {}
    end
    if type(global[beacon][surface_name][force_name]) == 'nil' then
        global[beacon][surface_name][force_name] = {}
    end
end

local init_beacon_data = function(beacon, userdata)
    local data = {
        beacon = beacon,
        position = beacon.position,
        created = game.tick,
        updated = game.tick
    }
    if type(userdata) == 'table' then
        for k, v in pairs(userdata) do
            data[k] = v
        end
    end
    return data
end

local update_beacon_data = function(beacon, userdata)
    if beacon and beacon.valid and type(userdata) == 'table' then
        local surface_name = beacon.surface.name;
        local beacon_name = beacon.name;
        local beacon_number = beacon.unit_number
        local force_name = beacon.force.name
        local beacon = global[beacon_name][surface_name][force_name][beacon_number]
        beacon.updated = game.tick
        for k, v in pairs(userdata) do
            beacon[k] = v
        end
        global[beacon_name][surface_name][force_name][beacon_number] = beacon;
    end
end

local create_attack_entity_beacon_from_spawn = function(surface)
    local beacon_count = 0
    for _, force_name in pairs(ForceHelper.get_player_forces()) do
        local force = game.forces[force_name]
        local position = force.get_spawn_position(surface)
        if position then
            beacon_count = beacon_count + 1
            local beacon = surface.create_entity({
                name = ATTACK_ENTITIES_BEACON,
                position = {position.x,position.y + 5},
                force = force.name
            })
            beacon.destructible = false;
            beacon.health = 1;

            init_beacon_struct(ATTACK_ENTITIES_BEACON, surface.name, force.name)
            global[ATTACK_ENTITIES_BEACON][surface.name][force.name][beacon.unit_number] = init_beacon_data(beacon)
            --print('[create_attack_entity_beacon_from_spawn] Created Respawn Attackable ' .. ATTACK_ENTITIES_BEACON .. '@' .. surface.name .. ' / ' .. serpent.block(position) )
        end
    end

    return beacon_count
end

local reindex_surface = function(surface)
    local spawn_chunk = 0
    local attack_chunk = 0
    local resource_chunk = 0

    local need_spawn_beacon_index = false;
    if global[SPAWN_BEACON] then
        if global[SPAWN_BEACON][surface.name] then
            for _, force in pairs(ForceHelper.get_enemy_forces()) do
                if next(global[SPAWN_BEACON][surface.name][force]) == nil then
                    need_spawn_beacon_index = true;
                    break;
                end
            end
        else
            need_spawn_beacon_index = true
        end
    end

    local need_attack_entity_beacon_index = false;
    if global[SPAWN_BEACON] then
        if global[SPAWN_BEACON][surface.name] then
            for _, force in pairs(ForceHelper.get_player_forces()) do
                if next(global[ATTACK_ENTITIES_BEACON][surface.name][force]) == nil then
                    need_attack_entity_beacon_index = true;
                    break;
                end
            end
        else
            need_attack_entity_beacon_index = true
        end
    end

    for chunk in surface.get_chunks() do
        if need_spawn_beacon_index and AttackGroupBeaconProcessor.create_spawn_beacon_from_trunk(surface, chunk.area) then
            spawn_chunk = spawn_chunk + 1
        end

        if need_attack_entity_beacon_index and AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, chunk.area) then
            attack_chunk = attack_chunk + 1
        end

        if AttackGroupBeaconProcessor.create_resource_beacon_from_trunk(surface, chunk.area) then
            resource_chunk = resource_chunk + 1
        end
    end

    attack_chunk = attack_chunk + create_attack_entity_beacon_from_spawn(surface)


    return spawn_chunk, attack_chunk, resource_chunk
end

AttackGroupBeaconProcessor.LAND_BEACON = LAND_BEACON
AttackGroupBeaconProcessor.AERIAL_BEACON = AERIAL_BEACON
AttackGroupBeaconProcessor.ATTACK_ENTITIES_BEACON = ATTACK_ENTITIES_BEACON
AttackGroupBeaconProcessor.SPAWN_BEACON = SPAWN_BEACON
AttackGroupBeaconProcessor.RESOURCE_BEACON = RESOURCE_BEACON

AttackGroupBeaconProcessor.LAND_SCOUT = LAND_SCOUT
AttackGroupBeaconProcessor.AERIAL_SCOUT = AERIAL_SCOUT

AttackGroupBeaconProcessor.init_globals = function()
    global[PICK_DATA] = global[PICK_DATA] or {}

    for _, beacon in pairs(ALL_BEACONS) do
        global[beacon] = global[beacon] or {}
        global[PICK_DATA][beacon] = global[PICK_DATA][beacon] or {
            CURRENT_KEY = nil
        }
    end
end



AttackGroupBeaconProcessor.create_defense_beacon = function(source_entity, beacon_name)
    if source_entity and source_entity.valid then
        if has_nearby_defense_beacon(source_entity) == false then
            local military_entities = count_military_entities(source_entity)
            if military_entities > 1 then
                local surface = source_entity.surface
                local beacon = surface.create_entity({
                    name = beacon_name,
                    position = {source_entity.position.x,source_entity.position.y - 5},
                    force = source_entity.force
                })
                beacon.destructible = false;
                beacon.health = military_entities;

                init_beacon_struct(beacon_name, surface.name, source_entity.force.name)
                global[beacon_name][surface.name][source_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
                --print('[createBeacon] Created Defense ' .. beacon_name .. '@' .. surface.name .. ' / ' .. serpent.block(source_entity.position) )

                return true
            end
        end

        return false
    end
end

AttackGroupBeaconProcessor.create_resource_beacon = function(source_entity)
    if source_entity and source_entity.valid then
        if has_nearby_resource_beacon(source_entity) == false then
            local resource_entities = count_resource_entities(source_entity)
            if resource_entities > RESOURCE_BEACON_ACCEPTANCE_LIMIT then
                local surface = source_entity.surface
                local beacon = surface.create_entity({
                    name = RESOURCE_BEACON,
                    position = {source_entity.position.x,source_entity.position.y - 5},
                    force = 'neutral'
                })
                beacon.destructible = false;
                beacon.health = resource_entities;

                --print('[createBeacon] Created  ' .. RESOURCE_BEACON .. '@' .. surface.name .. ' / ' .. serpent.block(source_entity.position) )

                return true
            end
        end

        return false
    end
end


AttackGroupBeaconProcessor.create_attack_entity_beacon = function(source_entity)
    if has_nearby_attack_entity_beacon(source_entity) == false then
        local attackable_entities = count_attackable_entities(source_entity)
        if attackable_entities > 1 then
            local surface = source_entity.surface
            local beacon = surface.create_entity({
                name = ATTACK_ENTITIES_BEACON,
                position = {source_entity.position.x,source_entity.position.y + 5},
                force = source_entity.force
            })
            beacon.destructible = false;
            beacon.health = attackable_entities;

            init_beacon_struct(ATTACK_ENTITIES_BEACON, surface.name, source_entity.force.name)
            global[ATTACK_ENTITIES_BEACON][surface.name][source_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
            --print('[create_attack_entity_beacon] Created Attackable ' .. ATTACK_ENTITIES_BEACON .. '@' .. surface.name .. ' / ' .. serpent.block(source_entity.position) )

            return true
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_spawn_beacon = function(entity)
    if entity and entity.valid and has_nearby_spawn_entity_beacon(entity) == false then
        local surface_name = entity.surface.name
        local beacon = entity.surface.create_entity({
            name = SPAWN_BEACON,
            position = entity.position,
            force = entity.force
        })
        beacon.destructible = false;

        init_beacon_struct(SPAWN_BEACON, surface_name, entity.force.name)
        global[SPAWN_BEACON][surface_name][entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
        --print('[create_spawn_beacon] Created ' .. SPAWN_BEACON .. '@' .. surface_name .. ' / ' .. serpent.block(entity.position))

        return true
    end

    return false
end

AttackGroupBeaconProcessor.create_spawn_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
            local spawners = surface.find_entities_filtered({
                type = 'unit-spawner',
                force = force_name,
                area = area,
                limit = 1,
            })
            local spawner_key = next(spawners)
            if spawner_key and has_nearby_spawn_entity_beacon(spawners[1]) == false then
                local beacon = surface.create_entity({
                    name = SPAWN_BEACON,
                    position = spawners[1].position,
                    force = force_name
                })
                beacon.destructible = false;

                init_beacon_struct(SPAWN_BEACON, surface.name, force_name)
                global[SPAWN_BEACON][surface.name][force_name][beacon.unit_number] = init_beacon_data(beacon)
                --print('[create_spawn_beacon_from_trunk] Created ' .. SPAWN_BEACON .. '@' .. surface.name .. ' / '.. serpent.block(spawners[1].position))

                return true
            end
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        local surface_name = surface.name
        for _, force in pairs(ForceHelper.get_player_forces()) do
            local attackable_entities = surface.find_entities_filtered({
                type = INDEXABLE_ATTACKABLE_ENTITY_TYPES,
                force = force,
                area = area,
                limit = 1,
            })
            local entity_key = next(attackable_entities)
            if entity_key and has_nearby_attack_entity_beacon(attackable_entities[entity_key]) == false then
                local beacon = surface.create_entity({
                    name = ATTACK_ENTITIES_BEACON,
                    position = attackable_entities[entity_key].position,
                    force = force
                })
                beacon.destructible = false;

                init_beacon_struct(ATTACK_ENTITIES_BEACON, surface_name, force)
                global[ATTACK_ENTITIES_BEACON][surface_name][force][beacon.unit_number] = init_beacon_data(beacon)
                --print('[create_attack_entity_beacon] Created ' .. ATTACK_ENTITIES_BEACON .. '@' .. surface_name .. ' / '.. serpent.block(attackable_entities[entity_key].position))

                return true
            end
        end
    end

    return false
end


AttackGroupBeaconProcessor.create_resource_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        local surface_name = surface.name
        local resource_entities = surface.find_entities_filtered({
            type = 'resource',
            area = area,
            limit = 1,
        })
        local entity_key = next(resource_entities)
        if entity_key and has_nearby_resource_beacon(resource_entities[entity_key]) == false then
            local beacon = surface.create_entity({
                name = RESOURCE_BEACON,
                position = resource_entities[entity_key].position,
                force = NEUTRAL_FORCE
            })
            beacon.destructible = false;

           -- print('[create_resource_beacon_from_trunk] Created ' .. RESOURCE_BEACON .. '@' .. surface_name .. ' / '.. serpent.block(resource_entities[entity_key].position))

            return true
        end
    end

    return false
end



---
--- To DO get scout path
---
AttackGroupBeaconProcessor.get_scout_path = function(source_entity)
    if source_entity and source_entity.valid then
        source_entity.set_command({
            type = defines.command.go_to_location,
            destination = {0, 0},
        })
    end
end

AttackGroupBeaconProcessor.remove_beacon_on_surface = function(surface)
    if surface and surface.valid then
        local surface_name = surface.name
        for _, beacon in pairs(ALL_BEACONS) do
            global[beacon][surface_name] = nil
        end
        print('[remove_beacon_on_surface] Removed beacon data on surface ..'..surface_name)
    end
end

AttackGroupBeaconProcessor.init_index = function()
    local profiler = game.create_profiler()
    local spawn_beacons = 0
    local attack_entity_beacons = 0
    local resource_beacons = 0
    local total_surfaces = 0
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) then
            local current_spawn_beacons, current_attack_beacons, current_resource_beacons = reindex_surface(surface)
            spawn_beacons = spawn_beacons + current_spawn_beacons
            attack_entity_beacons = attack_entity_beacons + current_attack_beacons
            resource_beacons = resource_beacons + current_resource_beacons
            total_surfaces = total_surfaces + 1
        end
    end

    profiler.stop()
    print('[ERM] Total Processed Surfaces: ' .. tostring(total_surfaces))
    print('[ERM] Total New Spawnable Beacons: ' .. tostring(spawn_beacons))
    print('[ERM] Total New Attackable Beacons: ' .. tostring(attack_entity_beacons))
    print('[ERM] Total New Resource Beacons: ' .. tostring(resource_beacons))
    game.print({ '', '[ERM] Attack Group Beacons Re-indexed: ', profiler })
end

AttackGroupBeaconProcessor.init_globals_on_surface = function(surface)
    if surface and surface.valid and ForceHelper.can_have_enemy_on(surface) then
        for _, beacon in pairs(ALL_BEACONS) do
            global[beacon][surface.name] = {}
        end
    end
end

AttackGroupBeaconProcessor.change_surface_name = function(old_surface, new_surface)
    if ForceHelper.can_have_enemy_on(game.surfaces[new_surface]) then
        for _, force in pairs(ForceHelper.get_enemy_forces()) do
            for _, beacon in pairs(ALL_BEACONS) do
                global[beacon][new_surface] = util.table.deepcopy(global[beacon][old_surface])
                global[beacon][old_surface] = nil
            end
        end
    end
end

AttackGroupBeaconProcessor.add_new_force = function(force)
    for _, beacon in pairs(ALL_BEACONS) do
        for _, surface in pairs(game.surfaces) do
            if ForceHelper.can_have_enemy_on(surface) then
                init_beacon_struct(beacon, surface.name, force.name)
            end
        end
    end
end

AttackGroupBeaconProcessor.remove_merged_force = function(force_name)
    for _, beacon in pairs(ALL_BEACONS) do
        for _, surface in pairs(game.surfaces) do
            if global[beacon][surface.name] then
                global[beacon][surface.name] = nil
            end
        end
    end

    AttackGroupBeaconProcessor.init_index()
end

AttackGroupBeaconProcessor.can_attack = function(surface)
    return true
end

AttackGroupBeaconProcessor.pick_spawn_location = function(surface, source_force, tier, target_force)
    local tier = tier or 1
    local target_force = target_force or game.forces['player']
    local target_area = AttackGroupBeaconProcessor.pick_attack_location(surface, target_force)



end

AttackGroupBeaconProcessor.pick_attack_location = function(surface, force)
    local entity_data = nil
    local key, value = next(global[ATTACK_ENTITIES_BEACON][surface.name][force.name], global[PICK_DATA][ATTACK_ENTITIES_BEACON][CURRENT_KEY])
    local i = 0
    while key or i < 10 do
        i = i + 1
        if value and value.beacon.valid and value.beacon.health > 10 then
            entity_data = value
            global[PICK_DATA][ATTACK_ENTITIES_BEACON][CURRENT_KEY] = key
            break
        end
        key, value = next(global[ATTACK_ENTITIES_BEACON][surface.name][force.name], key)
    end

    if entity_data then
        return entity_data
    end

    global[PICK_DATA][ATTACK_ENTITIES_BEACON][CURRENT_KEY] = nil
    return nil
end

AttackGroupBeaconProcessor.pick_nearby_attack_location = function(surface, init_position)

end

AttackGroupBeaconProcessor.pick_resource_location = function(surface)

end


return AttackGroupBeaconProcessor