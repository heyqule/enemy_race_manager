---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 12/12/2023 11:02 PM
---
require('util')

local ForceHelper = require('helper/force_helper')
local Configs = require('global_config')
local Cron = require('__enemyracemanager__/lib/cron_processor')

local Position = require('__stdlib__/stdlib/area/position')
local Event = require('__stdlib__/stdlib/event/event')

local AttackGroupBeaconProcessor = {}

--- Beacon radius for defense, resource and attack entity beacons
local BEACON_RADIUS = 64
--- Beacon Radius for spawner beacon
local SPAWNER_BEACON_RADIUS = 160
local ATTACK_ENTITIES_SCAN_RADIUS = BEACON_RADIUS * 2

local RESOURCE_SCAN_RADIUS = BEACON_RADIUS * 2
local PREVENT_RESOURCE_SCAN_RADIUS = RESOURCE_SCAN_RADIUS * 2

local BEACON_HEALTH_LIMIT = 200
--- Beacon Names
local AERIAL_BEACON = 'erm_aerial_beacon'
local LAND_BEACON = 'erm_land_beacon'
local SPAWN_BEACON = 'erm_spawn_beacon'
local ATTACK_ENTITIES_BEACON = 'erm_attackable_entity_beacon'
local ATTACK_ENTITIES_SPAWN_BEACON = 'erm_ae_spawn_beacon'
local RESOURCE_BEACON = 'erm_resource_beacon'
local RESOURCE_BEACON_ACCEPTANCE_LIMIT = 50
local LAND_SCOUT = '/land_scout'
local AERIAL_SCOUT = '/aerial_scout'
local ALL_BEACONS = { SPAWN_BEACON, LAND_BEACON, AERIAL_BEACON, ATTACK_ENTITIES_BEACON, RESOURCE_BEACON }
local ATTACKABLE_ENTITY_TYPES = {
    'mining-drill',
    'furnace',
    'rocket-silo',
    'artillery-turret',
    'lab'
}
local INDEXABLE_ATTACKABLE_ENTITY_TYPES = {
    'rocket-silo',
    'artillery-turret',
}

local CONTROL_DATA = 'cdata'
local ATTACK_ENTITIES_CURRENT_KEY = 'aeck'
local ATTACK_ENTITIES_SELECTED_KEY = 'aesk'
local ATTACK_ENTITIES_TARGET_FORCE = 'aetf'

local SPAWN_BEACON_SCAN_DIRECTION = 'sbsd'
local SPAWN_BEACON_SCAN_TIER = 'sbst'
local INIT_SPAWN_BEACON_SCAN_DIRECTION = 'isbsd'
local SCOUT_SPAWN_KEY = 'ssk'

local NEUTRAL_FORCE = 'neutral'

local RETRY = 5
local REMOVE_ATTACK_ENTITY_BEACON_COUNTS = 0
local SCOUT_KEEP_ALIVE = 3600 -- Keep 15 seconds when idle
local LAST_RESORT_RADIUS = 1024

--- Scan up to 5KM from each side. Min distance 5 chunk
local SCAN_DISTANCE = { { 160, 800 }, { 800, 1600 }, { 1600, 2400 }, { 2400, 3200 }, { 3200, 4000 }, { 4000, 5000 } }
local MAX_TIERS = #SCAN_DISTANCE
local SCAN_HALF_WIDTH = 320


local bounding_box_calc = {
    [defines.direction.north] = function(target_position, range)
        return {
            { target_position.x - SCAN_HALF_WIDTH, target_position.y - range[2] },
            { target_position.x + SCAN_HALF_WIDTH, target_position.y - range[1] },
        }
    end,
    [defines.direction.east] = function(target_position, range)
        return {
            { target_position.x + range[1], target_position.y - SCAN_HALF_WIDTH },
            { target_position.x + range[2], target_position.y + SCAN_HALF_WIDTH },
        }
    end,
    [defines.direction.south] = function(target_position, range)
        return {
            { target_position.x - SCAN_HALF_WIDTH, target_position.y + range[1] },
            { target_position.x + SCAN_HALF_WIDTH, target_position.y + range[2] },
        }
    end,
    [defines.direction.west] = function(target_position, range)
        return {
            { target_position.x - range[2], target_position.y - SCAN_HALF_WIDTH },
            { target_position.x - range[1], target_position.y + SCAN_HALF_WIDTH },
        }
    end
}

local function count_attackable_entities(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        type = ATTACKABLE_ENTITY_TYPES,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local function count_resource_entities(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        position = entity.position,
        type = 'resource',
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local function count_military_entities(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        is_military_target = true,
        radius = radius,
        limit = BEACON_HEALTH_LIMIT,
    }
    return entity.surface.count_entities_filtered(query);
end

local function get_an_attackable_entity(entity, radius)
    radius = radius or BEACON_RADIUS
    local query = {
        force = ForceHelper.get_player_forces(),
        position = entity.position,
        type = ATTACKABLE_ENTITY_TYPES,
        radius = radius,
        limit = 1,
    }
    local entities = entity.surface.find_entities_filtered(query)
    return entities[1]
end

local function get_next_attack_area(position)
    local distance = BEACON_RADIUS * 2
    local area = {
        { position.x - distance, position.y - distance },
        { position.x + distance, position.y + distance }
    }
    return area
end

local function get_attackable_entity(surface, area)
    local entities = surface.find_entities_filtered({
        area = area,
        type = ATTACKABLE_ENTITY_TYPES,
        limit = 1
    })

    if next(entities) == nil and next(global.attack_group_attackable_entity_names) then
        entities = surface.find_entities_filtered({
            area = area,
            name = global.attack_group_attackable_entity_names,
            limit = 1
        })
    end

    return entities
end

local function get_bounding_box_by_direction(target_position, tier, direction)
    local range = SCAN_DISTANCE[tier]
    if bounding_box_calc[direction] then
        return bounding_box_calc[direction](target_position, range)
    end
    return nil
end




local function get_sorted_distance(entities, target_position, desc)
    desc = desc or false
    local distances = {}
    for _, entity in pairs(entities) do
        if entity.valid then
            table.insert(distances, {
                entity = entity,
                position = entity.position,
                distance = Position.manhattan_distance(entity.position, target_position)
            })
        end
    end

    if desc then
        table.sort(distances, function(a, b)
            return a.distance > b.distance
        end)
    else
        table.sort(distances, function(a, b)
            return a.distance < b.distance
        end)
    end

    return distances
end


local function get_spawn_area(position)
    local distance = SPAWNER_BEACON_RADIUS / 2
    local area = {
        { position.x - distance, position.y - distance },
        { position.x + distance, position.y + distance }
    }
    return area
end

local function has_nearby_beacon(names, entity, radius, override_force)
    local force = override_force or entity.force.name
    if entity.surface.count_entities_filtered({
        name = names,
        position = entity.position,
        radius = radius,
        force = force,
        limit = 1,
    }) > 0 then
        return true
    end

    return false
end

local function has_nearby_attack_entity_beacon(entity, radius)
    radius = radius or BEACON_RADIUS
    return has_nearby_beacon({ ATTACK_ENTITIES_BEACON }, entity, radius)
end

local function has_nearby_defense_beacon(entity, radius)
    radius = radius or BEACON_RADIUS
    return has_nearby_beacon({ LAND_BEACON, AERIAL_BEACON }, entity, radius)
end

local function has_nearby_resource_beacon(entity, radius)
    radius = radius or BEACON_RADIUS
    return has_nearby_beacon({ RESOURCE_BEACON }, entity, radius, NEUTRAL_FORCE)
end

local function has_nearby_spawn_entity_beacon(entity, radius)
    radius = radius or SPAWNER_BEACON_RADIUS
    return has_nearby_beacon({ SPAWN_BEACON }, entity, radius)
end

local function get_nearby_resource_beacon(entity, radius)
    local entities =  entity.surface.find_entities_filtered {
        name = RESOURCE_BEACON,
        position = entity.position,
        radius = radius,
        force = NEUTRAL_FORCE,
        limit = 1,
    }
    local key, node = next(entities)
    if key then
        return node
    end
end

local function is_valid_beacon(beacon)
    return beacon and beacon.valid
end


local function init_beacon_struct(beacon, surface_name, force_name)
    if type(global[beacon][surface_name]) == 'nil' then
        global[beacon][surface_name] = {}
    end
    if type(global[beacon][surface_name][force_name]) == 'nil' then
        global[beacon][surface_name][force_name] = {}
    end
end

local function init_beacon_data(beacon, userdata)
    local data = {
        beacon = beacon,
        position = beacon.position,
        created = game.tick,
        updated = game.tick
    }
    if type(userdata) == 'table' then
        for k, v in pairs(userdata) do
            data[k] = v
        end
    end
    return data
end

local function update_beacon_data(beacon, userdata)
    if is_valid_beacon(beacon) then
        local surface_index = beacon.surface.index;
        local beacon_name = beacon.name;
        local beacon_number = beacon.unit_number
        local force_name = beacon.force.name
        local beacon = global[beacon_name][surface_index][force_name][beacon_number]
        beacon.updated = game.tick
        if type(userdata) == 'table' then
            for k, v in pairs(userdata) do
                beacon[k] = v
            end
        end
        global[beacon_name][surface_index][force_name][beacon_number] = beacon;
    end
end

local function create_attack_entity_beacon_from_spawn(surface)
    local beacon_count = 0
    for _, force_name in pairs(ForceHelper.get_player_forces()) do
        local force = game.forces[force_name]
        local position = force.get_spawn_position(surface)
        local beacons = surface.count_entities_filtered({
            name = ATTACK_ENTITIES_BEACON,
            position = { position.x, position.y },
            force = force.name,
            radius = BEACON_RADIUS
        })

        if beacons == 0 then
            beacon_count = beacon_count + 1
            local beacon = surface.create_entity({
                name = ATTACK_ENTITIES_BEACON,
                position = { position.x, position.y },
                force = force.name
            })
            beacon.destructible = false;
            beacon.health = 1;

            init_beacon_struct(ATTACK_ENTITIES_BEACON, surface.index, force.name)
            global[ATTACK_ENTITIES_BEACON][surface.index][force.name][beacon.unit_number] = init_beacon_data(beacon)
            global[ATTACK_ENTITIES_BEACON][surface.index][force.name][beacon.unit_number]['is_spawn'] = true

            init_beacon_struct(ATTACK_ENTITIES_SPAWN_BEACON, surface.index, force.name)
            global[ATTACK_ENTITIES_SPAWN_BEACON][surface.index][force.name] = init_beacon_data(beacon)
        end
    end

    return beacon_count
end

local function reindex_surface(surface)
    local spawn_chunk = 0
    local attack_chunk = 0
    local resource_chunk = 0

    local need_spawn_beacon_index = false;
    if global[SPAWN_BEACON] then
        if global[SPAWN_BEACON][surface.index] then
            for _, force in pairs(ForceHelper.get_enemy_forces()) do
                if global[SPAWN_BEACON][surface.index][force] == nil or
                        next(global[SPAWN_BEACON][surface.index][force]) == nil
                then
                    need_spawn_beacon_index = true;
                    break ;
                end
            end
        else
            need_spawn_beacon_index = true
        end
    end

    local need_attack_entity_beacon_index = false;
    if global[ATTACK_ENTITIES_BEACON] then
        if global[ATTACK_ENTITIES_BEACON][surface.index] then
            for _, force in pairs(ForceHelper.get_player_forces()) do
                if global[ATTACK_ENTITIES_BEACON][surface.index][force] == nil or
                        next(global[ATTACK_ENTITIES_BEACON][surface.index][force]) == nil
                then
                    need_attack_entity_beacon_index = true;
                    break ;
                end
            end
        else
            need_attack_entity_beacon_index = true
        end
    end

    for chunk in surface.get_chunks() do
        if need_spawn_beacon_index and AttackGroupBeaconProcessor.create_spawn_beacon_from_trunk(surface, chunk.area) then
            spawn_chunk = spawn_chunk + 1
        end

        if need_attack_entity_beacon_index and AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk(surface, chunk.area) then
            attack_chunk = attack_chunk + 1
        end

        if AttackGroupBeaconProcessor.create_resource_beacon_from_trunk(surface, chunk.area) then
            resource_chunk = resource_chunk + 1
        end
    end

    attack_chunk = attack_chunk + create_attack_entity_beacon_from_spawn(surface)

    return spawn_chunk, attack_chunk, resource_chunk
end

AttackGroupBeaconProcessor.LAND_BEACON = LAND_BEACON
AttackGroupBeaconProcessor.AERIAL_BEACON = AERIAL_BEACON
AttackGroupBeaconProcessor.ATTACK_ENTITIES_BEACON = ATTACK_ENTITIES_BEACON
AttackGroupBeaconProcessor.SPAWN_BEACON = SPAWN_BEACON
AttackGroupBeaconProcessor.RESOURCE_BEACON = RESOURCE_BEACON

AttackGroupBeaconProcessor.LAND_SCOUT = LAND_SCOUT
AttackGroupBeaconProcessor.AERIAL_SCOUT = AERIAL_SCOUT

--- Set beacon tracker and control data by force
AttackGroupBeaconProcessor.add_new_force = function(force)
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) and ForceHelper.is_enemy_force(force) then
            for _, beacon in pairs(ALL_BEACONS) do
                init_beacon_struct(beacon, surface.index, force.name)
            end

            if global[CONTROL_DATA] then
                global[CONTROL_DATA][surface.index][force.name] = global[CONTROL_DATA][surface.index][force.name] or {}
            end
        end
    end
end

AttackGroupBeaconProcessor.can_attack = function(surface)
    if global[SPAWN_BEACON][surface.index] ~= nil and global[ATTACK_ENTITIES_BEACON][surface.index] ~= nil then
        return true
    end
    return false
end

AttackGroupBeaconProcessor.create_attack_entity_beacon = function(source_entity)
    local surface = source_entity.surface
    local attackable_entity = get_an_attackable_entity(source_entity, ATTACK_ENTITIES_SCAN_RADIUS)

    if attackable_entity and
            attackable_entity.valid and
            has_nearby_attack_entity_beacon(attackable_entity) == false
    then
        --- 128 tile scan radius
        local attackable_entities = count_attackable_entities(attackable_entity, ATTACK_ENTITIES_SCAN_RADIUS)
        if attackable_entities > 0 then
            local beacon = surface.create_entity({
                name = ATTACK_ENTITIES_BEACON,
                position = { attackable_entity.position.x, attackable_entity.position.y },
                force = attackable_entity.force
            })
            beacon.destructible = false;
            beacon.health = attackable_entities;

            init_beacon_struct(ATTACK_ENTITIES_BEACON, surface.index, attackable_entity.force.name)
            global[ATTACK_ENTITIES_BEACON][surface.index][attackable_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)

            return true
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_attack_entity_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        local types = INDEXABLE_ATTACKABLE_ENTITY_TYPES
        if global.attack_beacon_index_all then
            types = ATTACKABLE_ENTITY_TYPES
            global.attack_beacon_index_all = nil
        end

        for _, force in pairs(ForceHelper.get_player_forces()) do
            local attackable_entities = surface.find_entities_filtered({
                type = types,
                force = force,
                area = area,
                limit = 1,
            })
            local entity_key = next(attackable_entities)
            if entity_key then
                return AttackGroupBeaconProcessor.create_attack_entity_beacon(attackable_entities[entity_key])
            end
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_defense_beacon = function(source_entity, beacon_name)
    if source_entity and source_entity.valid then
        if has_nearby_defense_beacon(source_entity) == false then
            local military_entities = count_military_entities(source_entity)
            if military_entities > 0 then
                local surface = source_entity.surface
                local beacon = surface.create_entity({
                    name = beacon_name,
                    position = { source_entity.position.x, source_entity.position.y },
                    force = source_entity.force
                })
                beacon.destructible = false;
                beacon.health = military_entities;

                init_beacon_struct(beacon_name, surface.index, source_entity.force.name)
                global[beacon_name][surface.index][source_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
                return true
            end
        else
            -- Update or destroy beacon
            local surface = source_entity.surface
            local beacons = surface.find_entities_filtered({
                name = {LAND_BEACON, AERIAL_BEACON},
                position = { source_entity.position.x, source_entity.position.y },
                force = source_entity.force,
                radius = BEACON_RADIUS,
                limit = 1
            })
            if next(beacons) then
                local beacon = beacons[1]
                local military_entities = count_military_entities(source_entity)
                if military_entities == 0 then
                    global[beacon_name][surface.index][source_entity.force.name][beacon.unit_number] = nil
                    beacon.destroy()
                else
                    beacon.health = military_entities
                    update_beacon_data(beacon)
                end
            end
        end

        return false
    end
end

AttackGroupBeaconProcessor.create_resource_beacon = function(source_entity)
    if source_entity and source_entity.valid then
        if has_nearby_resource_beacon(source_entity) == false then
            local resource_entities = count_resource_entities(source_entity)
            if source_entity.prototype.infinite_resource or resource_entities > RESOURCE_BEACON_ACCEPTANCE_LIMIT then
                local surface = source_entity.surface
                local beacon = surface.create_entity({
                    name = RESOURCE_BEACON,
                    position = { source_entity.position.x, source_entity.position.y },
                    force = NEUTRAL_FORCE
                })
                beacon.destructible = false;
                beacon.health = resource_entities;

                init_beacon_struct(RESOURCE_BEACON, surface.index, source_entity.force.name)
                global[RESOURCE_BEACON][surface.index][source_entity.force.name][beacon.unit_number] = init_beacon_data(beacon)

                return true
            end
        end

        return false
    end
end

AttackGroupBeaconProcessor.create_resource_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        local resource_entities = surface.find_entities_filtered({
            type = 'resource',
            area = area,
            limit = 1,
        })
        local entity_key = next(resource_entities)
        if entity_key then
            return AttackGroupBeaconProcessor.create_resource_beacon(resource_entities[entity_key])
        end
    end

    return false
end

AttackGroupBeaconProcessor.create_spawn_beacon = function(entity)
    if entity and entity.valid and has_nearby_spawn_entity_beacon(entity) == false then
        local surface_index = entity.surface.index
        local beacon = entity.surface.create_entity({
            name = SPAWN_BEACON,
            position = entity.position,
            force = entity.force
        })
        beacon.destructible = false;

        init_beacon_struct(SPAWN_BEACON, surface_index, entity.force.name)
        global[SPAWN_BEACON][surface_index][entity.force.name][beacon.unit_number] = init_beacon_data(beacon)
        return true
    end

    return false
end

AttackGroupBeaconProcessor.create_spawn_beacon_from_trunk = function(surface, area)
    if surface and surface.valid then
        for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
            local spawners = surface.find_entities_filtered({
                type = 'unit-spawner',
                force = force_name,
                area = area,
                limit = 1,
            })
            local spawner_key = next(spawners)
            if spawner_key then
                AttackGroupBeaconProcessor.create_spawn_beacon(spawners[spawner_key])
                return true
            end
        end
    end

    return false
end

AttackGroupBeaconProcessor.get_selected_attack_beacon = function(surface, source_force, target_force)
    local selected_key = global[CONTROL_DATA][surface.index][source_force.name][ATTACK_ENTITIES_SELECTED_KEY]
    local attack_beacons = global[ATTACK_ENTITIES_BEACON][surface.index][target_force.name]
    if not selected_key or attack_beacons[selected_key] == nil then
        return nil
    end

    return attack_beacons[selected_key];
end

AttackGroupBeaconProcessor.get_control_data = function(surface_index, force_name)
    if force_name then
        return global[CONTROL_DATA][surface_index][force_name]
    end
    return global[CONTROL_DATA][surface_index]
end

AttackGroupBeaconProcessor.get_beacon_data = function(beacon_type, surface_index, force_name)
    if force_name then
        return global[beacon_type][surface_index][force_name]
    end
    return global[beacon_type][surface_index]
end

AttackGroupBeaconProcessor.get_max_tiers = function()
    return MAX_TIERS
end

AttackGroupBeaconProcessor.init_globals = function()
    for _, beacon in pairs(ALL_BEACONS) do
        global[beacon] = global[beacon] or {}
    end
    global[ATTACK_ENTITIES_SPAWN_BEACON] = global[ATTACK_ENTITIES_SPAWN_BEACON] or {}
    global.attack_group_attackable_entity_names = global.attack_group_attackable_entity_names or {}
end

--- This is run in ERM post processor.
AttackGroupBeaconProcessor.init_control_globals = function()
    global[CONTROL_DATA] = global[CONTROL_DATA] or {}
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) then
            global[CONTROL_DATA][surface.index] = global[CONTROL_DATA][surface.index] or {}
            for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
                global[CONTROL_DATA][surface.index][force_name] = global[CONTROL_DATA][surface.index][force_name] or {}
            end
            for _, force_name in pairs(ForceHelper.get_player_forces()) do
                global[CONTROL_DATA][surface.index][force_name] = global[CONTROL_DATA][surface.index][force_name] or {}
            end
        end
    end
end

--- init globals when new surface is made
AttackGroupBeaconProcessor.init_globals_on_surface = function(surface)
    if surface and surface.valid and ForceHelper.can_have_enemy_on(surface) then
        for _, beacon in pairs(ALL_BEACONS) do
            global[beacon][surface.index] = {}
        end

        if ForceHelper.can_have_enemy_on(surface) then
            global[CONTROL_DATA][surface.index] = global[CONTROL_DATA][surface.index] or {}
            for _, force_name in pairs(ForceHelper.get_enemy_forces()) do
                global[CONTROL_DATA][surface.index][force_name] = global[CONTROL_DATA][surface.index][force_name] or {}
            end
        end
    end
end

AttackGroupBeaconProcessor.init_index = function()
    local profiler = game.create_profiler()
    local spawn_beacons = 0
    local attack_entity_beacons = 0
    local resource_beacons = 0
    local total_surfaces = 0
    for _, surface in pairs(game.surfaces) do
        if ForceHelper.can_have_enemy_on(surface) then
            local current_spawn_beacons, current_attack_beacons, current_resource_beacons = reindex_surface(surface)
            spawn_beacons = spawn_beacons + current_spawn_beacons
            attack_entity_beacons = attack_entity_beacons + current_attack_beacons
            resource_beacons = resource_beacons + current_resource_beacons
            total_surfaces = total_surfaces + 1
        end
    end

    profiler.stop()
    print('[ERM] Total Processed Surfaces: ' .. tostring(total_surfaces))
    print('[ERM] Total New Spawnable Beacons: ' .. tostring(spawn_beacons))
    print('[ERM] Total New Attackable Beacons: ' .. tostring(attack_entity_beacons))
    print('[ERM] Total New Resource Beacons: ' .. tostring(resource_beacons))
    game.print({ '', '[ERM] Attack Group Beacons Re-indexed: ', profiler })
end

AttackGroupBeaconProcessor.pick_attack_beacon = function(surface, source_force, target_force, new_beacon)
    local profiler = game.create_profiler()

    local target_beacon

    if new_beacon then
        target_beacon = AttackGroupBeaconProcessor.pick_new_attack_beacon(surface, source_force, target_force)
    else
        target_beacon = AttackGroupBeaconProcessor.get_selected_attack_beacon(surface, source_force, target_force) or
                AttackGroupBeaconProcessor.pick_new_attack_beacon(surface, source_force, target_force)
    end

    profiler.stop()
    log{"",'[ERM] AttackGroupBeaconProcessor.pick_attack_beacon: ', profiler}

    return target_beacon
end

---
--- Starts from north with tier 1 distance.
--- If something found, return the position.
--- When no position found, move to next direction (N,E,S,W)
--- Once all sides are found and no position found, move to next tier.
--- When tier and direction reach max.  Removed target_beacon since nothing matches.
---
AttackGroupBeaconProcessor.pick_spawn_location = function(surface, source_force, target_beacon, from_cron, use_fallback)

    local profiler = game.create_profiler()

    local target_force = target_beacon.force
    if use_fallback == nil then
        use_fallback = true
    end
    from_cron = from_cron or false
    local control_data = global[CONTROL_DATA][surface.index][target_force.name]
    if control_data == nil then
        profiler.stop()
        log{"",'[ERM] AttackGroupBeaconProcessor.pick_spawn_location nil control data: ', profiler}


        return nil, true
    end

    local scan_direction = control_data[SPAWN_BEACON_SCAN_DIRECTION] or 0
    if from_cron == false then
        control_data[INIT_SPAWN_BEACON_SCAN_DIRECTION] = scan_direction
    end
    local tier = control_data[SPAWN_BEACON_SCAN_TIER] or 1
    local rc_entity
    local halt_cron = false

    if target_beacon then
        local entities
        local bounding_box = get_bounding_box_by_direction(target_beacon.position, tier, scan_direction)
        --- @TODO comment out for production
        if DEBUG_MODE then
            local race_name = ForceHelper.extract_race_name_from(source_force.name)
            local color = settings.startup[race_name..'-map-color'].value
            color.a = 0.1
            rendering.draw_rectangle({
                force='player',
                left_top=bounding_box[1],
                right_bottom=bounding_box[2],
                surface=target_beacon.surface,
                filled=true,
                time_to_live=3600,
                draw_on_ground=true,
                color=color
            })
        end
        scan_direction = ((scan_direction + 2) % 8)
        entities = surface.find_entities_filtered({
            name = SPAWN_BEACON,
            area = bounding_box,
            force = source_force,
            limit = 10,
        })

        if next(entities) then
            local distances = get_sorted_distance(entities, target_beacon.position)

            local spawners = surface.find_entities_filtered({
                area = get_spawn_area(distances[1].position),
                force = source_force,
                type = 'unit-spawner',
                limit = 10
            })

            if next(spawners) then
                rc_entity = spawners[math.random(1, #spawners)]
            else
                -- Destroy spawn beacon if spawner is not found within it.
                global[SPAWN_BEACON][surface.index][source_force.name][distances[1].entity.unit_number] = nil
                distances[1].entity.destructible = true
                distances[1].entity.destroy()
            end
        end

        if rc_entity == nil then
            if scan_direction == control_data[INIT_SPAWN_BEACON_SCAN_DIRECTION]
            then
                tier = tier + 1
            end

            if tier > MAX_TIERS then
                tier = 1
                scan_direction = 0
                halt_cron = true
            end
        end
        control_data[SPAWN_BEACON_SCAN_TIER] = tier
        control_data[SPAWN_BEACON_SCAN_DIRECTION] = scan_direction
    end

    -- Last resort
    if rc_entity == nil and use_fallback == true and halt_cron == true then
        local spawners = surface.find_entities_filtered({
            position = target_beacon.position,
            radius = LAST_RESORT_RADIUS,
            force = source_force,
            type = 'unit-spawner',
            limit = 1
        })

        if next(spawners) then
            rc_entity = spawners[next(spawners)]
        end
    end

    profiler.stop()
    log{"",'[ERM] AttackGroupBeaconProcessor.pick_spawn_location Tier:'..tier..' Direction:'..scan_direction..' Target: '..target_beacon.position.x..', '..target_beacon.position.y..' > ', profiler}

    return rc_entity, halt_cron
end

AttackGroupBeaconProcessor.pick_current_selected_attack_beacon = function(surface, source_force, clean_selected_key)
    clean_selected_key = clean_selected_key or false

    local control_data = global[CONTROL_DATA][surface.index][source_force.name]
    local target_force_name = control_data[ATTACK_ENTITIES_TARGET_FORCE]
    local force
    if target_force_name then
        force = game.forces[target_force_name]
    end

    if force == nil then
        return nil
    end

    if control_data[ATTACK_ENTITIES_SELECTED_KEY] == nil then
        AttackGroupBeaconProcessor.pick_attack_beacon(surface, source_force, force)
    end

    local selected_key = control_data[ATTACK_ENTITIES_SELECTED_KEY]
    if selected_key then
        local entity_data = global[ATTACK_ENTITIES_BEACON][surface.index][force.name][selected_key]
        if entity_data then
            if clean_selected_key then
                control_data[ATTACK_ENTITIES_SELECTED_KEY] = nil
            end
            return entity_data
        end
    end

    return nil
end

AttackGroupBeaconProcessor.pick_new_attack_beacon = function(surface, source_force, target_force)
    local surface_data = global[ATTACK_ENTITIES_BEACON][surface.index]
    if surface_data == nil or
        surface_data[target_force.name] == nil
    then
        return nil
    end

    local control_data = global[CONTROL_DATA][surface.index][source_force.name]
    local beacon_data = surface_data[target_force.name]

    local entity_data
    local key, value = next(beacon_data, control_data[ATTACK_ENTITIES_CURRENT_KEY])
    local i = 0
    while i < RETRY do
        if value and
                is_valid_beacon(value.beacon)
        then
            if value.beacon.health > REMOVE_ATTACK_ENTITY_BEACON_COUNTS then
                entity_data = value
                control_data[ATTACK_ENTITIES_TARGET_FORCE] = target_force.name
                control_data[ATTACK_ENTITIES_CURRENT_KEY] = key
                control_data[ATTACK_ENTITIES_SELECTED_KEY] = key
                break
            elseif value.beacon.health == REMOVE_ATTACK_ENTITY_BEACON_COUNTS and
                    value.is_spawn ~= true
            then
                value.beacon.destructible = true
                value.beacon.destroy()
                beacon_data[key] = nil
            end
        elseif value then
            beacon_data[key] = nil
        end
        i = i + 1
        key, value = next(beacon_data, key)
    end

    if entity_data then
        return entity_data
    end

    control_data[ATTACK_ENTITIES_TARGET_FORCE] = nil
    control_data[ATTACK_ENTITIES_SELECTED_KEY] = nil
    control_data[ATTACK_ENTITIES_CURRENT_KEY] = nil
    return nil
end

AttackGroupBeaconProcessor.pick_nearby_attack_location = function(surface, init_position)
    local entities = get_attackable_entity(surface, get_next_attack_area(init_position))
    local position

    local next_index = next(entities)
    if next_index then
        local entity = entities[next_index]
        position = { x = entity.position.x, y = entity.position.y }
    end

    return position
end

AttackGroupBeaconProcessor.pick_resource_location = function(surface, init_position, direction, distance)
    distance = distance or 960
    local target_range = { 0, distance }
    local bounding_box = bounding_box_calc[direction](init_position, target_range)

    local entities = surface.find_entities_filtered({
        name = RESOURCE_BEACON,
        area = bounding_box,
        limit = 10,
    })

    local distances = get_sorted_distance(entities, init_position, true)
    local rc_position

    for _, entity in pairs(entities) do
        if distances[1].position.x == entity.position.x and
                distances[1].position.y == entity.position.y  then
            rc_position = entity.position
            break
        end
    end

    return rc_position
end

--- Reset all beacon data globals
AttackGroupBeaconProcessor.reset_globals = function()
    for _, beacon in pairs(ALL_BEACONS) do
        global[beacon] = {}
    end

    global[CONTROL_DATA] = nil
    AttackGroupBeaconProcessor.init_control_globals()
end

--- Remove beacon data on a surface
AttackGroupBeaconProcessor.remove_beacons_on_surface = function(surface_index)
    for _, beacon in pairs(ALL_BEACONS) do
        global[beacon][surface_index] = nil
        global[CONTROL_DATA][surface_index] = nil
    end
end

--- Remove beacon tracker and control data by force
AttackGroupBeaconProcessor.remove_merged_force = function(force_name)
    for _, surface in pairs(game.surfaces) do
        for _, beacon in pairs(ALL_BEACONS) do
            if global[beacon][surface.index] then
                global[beacon][surface.index][force_name] = nil
            end
        end

        global[CONTROL_DATA][surface.index][force_name] = nil
    end

    AttackGroupBeaconProcessor.init_index()
end

AttackGroupBeaconProcessor.has_attack_entity_beacon = function(surface)
    local surface_data = global[ATTACK_ENTITIES_BEACON][surface.index]
    if surface_data then
        for _, data in pairs(surface_data) do
            if type(data) == 'table' and next(data) then
                return true
            end
        end
    end
    return false
end

AttackGroupBeaconProcessor.get_attackable_spawn_beacon = function(surface, force)
    local surface = global[ATTACK_ENTITIES_SPAWN_BEACON][surface.index]
    if surface then
        local beacon = surface[force.name]
        if beacon then
            return beacon
        end
    end

    return nil
end

AttackGroupBeaconProcessor.get_spawn_beacon = function(surface, force)
    local beacon_surface = global[SPAWN_BEACON][surface.index]
    if beacon_surface == nil or
            beacon_surface[force.name] == nil
    then
        return nil
    end

    local i = 0
    local new_key, node
    local control_data = global[CONTROL_DATA][surface.index][force.name]
    local beacon_data = beacon_surface[force.name]
    repeat
        local control_key = control_data[SCOUT_SPAWN_KEY] or nil
        new_key, node = next(beacon_data, control_key)
        control_data[SCOUT_SPAWN_KEY] = new_key
        i = i + 1
    until node ~= nil or i < RETRY

    if node ~= nil then
        return node.beacon
    end
end

AttackGroupBeaconProcessor.start_scout_scan = function()
    local should_repeat = false
    for race_name, entity_data in pairs(global.scout_tracker) do
        if entity_data.entity.valid then
            should_repeat = true
            Cron.add_quick_queue('AttackGroupBeaconProcessor.scout_scan', race_name, entity_data)
        else
            global.scout_tracker[race_name] = nil
        end
    end

    if should_repeat and
            global.scout_scanner and
            table_size(global.scout_tracker) > 0 then
        Cron.add_15_sec_queue('AttackGroupBeaconProcessor.start_scout_scan')
    else
        global.scout_scanner = false
    end
end

AttackGroupBeaconProcessor.scout_scan = function(race_name, entity_data)
    local entity = entity_data.entity
    if entity.valid then
        AttackGroupBeaconProcessor.create_attack_entity_beacon(entity)

        local tracker = global.scout_tracker[race_name]
        if tracker == nil then
            return
        end

        --- @TODO comment out for production
        if DEBUG_MODE then
            local color = settings.startup[race_name..'-map-color'].value
            color.a = 0.25
            rendering.draw_circle({
                force='player',
                radius=1,
                target=entity.position,
                surface=entity.surface,
                filled=true,
                time_to_live=3600*5,
                color=color,
                draw_on_ground=true
            })
        end

        if game.tick > tracker.update_tick + SCOUT_KEEP_ALIVE and
            (entity.command.type == defines.command.wander or
            entity.command.type == defines.command.stop)
        then
            entity.die('neutral')
            global.scout_tracker[race_name] = nil
        elseif entity.command.type == defines.command.go_to_location then
            tracker.position = entity.position
            tracker.update_tick = game.tick
        end


        if entity.valid and
           tracker.last_resource_position == nil and
           has_nearby_resource_beacon(entity, RESOURCE_SCAN_RADIUS)
        then
            local command = entity.command
            --- Switch to resource path only if it's heading to final_destination
            if command and command.type == defines.command.go_to_location and
                command.destination.x == tracker.final_destination.x and
                command.destination.y == tracker.final_destination.y then
                local beacon = get_nearby_resource_beacon(entity, RESOURCE_SCAN_RADIUS)
                local last_resource_distance = 0
                if tracker.last_resource_position then
                    last_resource_distance = util.distance(beacon.position, tracker.last_resource_position)
                end

                if tracker.last_resource_position == nil or
                    last_resource_distance >= PREVENT_RESOURCE_SCAN_RADIUS
                then
                    entity.set_command({
                        type = defines.command.go_to_location,
                        destination = beacon.position,
                        radius = 16,
                        distraction = defines.distraction.none
                    })

                    tracker.last_resource_position = beacon.position
                end
            end
        elseif entity.valid and
            entity.command.type == defines.command.wander
        then
            local final_distance = util.distance(tracker.final_destination, entity.position)
            if final_distance > (BEACON_RADIUS / 2) then
                entity.set_command({
                    type = defines.command.go_to_location,
                    destination = tracker.final_destination,
                    radius = 16,
                    distraction = defines.distraction.none
                })
            end
        end
    else
        global.scout_tracker[race_name] = nil
    end
end

return AttackGroupBeaconProcessor