---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 8/29/2025 11:39 AM
---

local EmotionProcessor = {}

local Position = require('__erm_libs__/stdlib/position')
local EmotionConstants = require('__enemyracemanager__/lib/emotion_constants')
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local GlobalConfig  = require("__enemyracemanager__/lib/global_config")
local AttackGroupBeaconConstants = require("__enemyracemanager__/lib/attack_group_beacon_constants")
local AttackGroupBeaconProcessor = require("__enemyracemanager__/lib/attack_group_beacon_processor")
local DebugHelper = require("__enemyracemanager__/lib/debug_helper")
local Cron = require("__enemyracemanager__/lib/cron_processor")

local LIMIT_FILTER = 50
local EVOLUTION_FACTOR_START_POINT = 0.66
local DEFAULT_COOLDOWN = 2 * minute
local NEUTRAL_FORCE = "neutral"

local collision_finder = 'big-biter'

--- Collect all resource / land beacons as buildable targets
local collect_resource_and_land_beacons = function(emotion_data)
    local filtered_beacons = {}

    if emotion_data.surface.valid and emotion_data.force.valid then
        local surface = emotion_data.surface
        local force = emotion_data.force
        local buildable_beacons = surface.find_entities_filtered({
            force = {force.name},
            name = {AttackGroupBeaconConstants.LAND_BEACON},
            limit = LIMIT_FILTER
        })
        if not buildable_beacons or #buildable_beacons < 10 then
            local resource_beacon = surface.find_entities_filtered({
                force = {NEUTRAL_FORCE},
                name = {AttackGroupBeaconConstants.RESOURCE_BEACON},
                limit = LIMIT_FILTER
            })
            for _, beacon in pairs(resource_beacon) do
                table.insert(buildable_beacons, beacon)
            end
        end
        
        if buildable_beacons then
            for _, beacon in pairs(buildable_beacons) do
                local count = surface.count_entities_filtered({
                    force = force.name,
                    type = 'unit-spawner',
                    limit = 1,
                    position = beacon.position,
                    radius = AttackGroupBeaconConstants.SPAWNER_BEACON_RADIUS,
                })
                
                if count == 0 then
                    table.insert(filtered_beacons, beacon)
                end
            end
        end
    end

    return filtered_beacons
end


--- find a buildable beacons.  
--- Check whether there is spawner within 5 chunks radius.
--- If not, build a base, 3 chunks behind the beacons
--- else, remove the node from buildable_beacons
--- if no buildable_beacons, change it to siege attack.
local find_buildable_location = function(data)
    local surface = data.surface
    local force = data.force
    local buildable_beacons = data.buildable_beacons
    if buildable_beacons == nil or #buildable_beacons == 0 then
        data.buildable_beacons = collect_resource_and_land_beacons(data)
        buildable_beacons = data.buildable_beacons
    end
    
    if surface.valid and force.valid and buildable_beacons then
        repeat
            local bIndex, beacon = next(buildable_beacons)
            if beacon and beacon.valid then
                table.remove(buildable_beacons, bIndex)
                return Position.calculate_position_x_tiles_further(beacon.position, 64)
            else
                table.remove(buildable_beacons, bIndex)
            end
        until next(buildable_beacons) == nil
    end
end

local valid_data_object = function(data)
    return data.surface.valid and data.force.valid
end

local get_beacon_positions = function(data)
    local surface = data.surface
    local force = data.force
    local target_force = data.target_force or game.forces['player']
    local attack_position = data.attack_position
    local spawn_position = data.spawn_position

    
    if attack_position == nil and spawn_position == nil then
        local attack_beacon = AttackGroupBeaconProcessor.pick_attack_beacon(surface, force, target_force)

        if attack_beacon then
            attack_position = attack_beacon.position
            local spawn_beacon = AttackGroupBeaconProcessor.pick_spawn_location(surface, force, attack_beacon)
            if spawn_beacon then
                spawn_position = spawn_beacon.position
            end                
        end
    end

    if attack_position ~= nil and spawn_position == nil then
        local spawn_beacon = AttackGroupBeaconProcessor.get_spawn_beacon(surface, force)
        if spawn_beacon then
            spawn_position = spawn_beacon.position
        end
    end

    if spawn_position ~= nil and attack_position == nil then
        local attack_beacon = AttackGroupBeaconProcessor.pick_attack_beacon(surface, force, target_force)

        if attack_beacon then
            attack_position = attack_beacon.position
        end
    end
    return attack_position, spawn_position
end

local attack_peaceful = function(data)
    --- Remove the data when it's peaceful.
    storage.emotion[data.force.name] = nil
end

local attack_rapid_expand = function(data)
    if not valid_data_object(data) then
        return
    end      
    
    local surface = data.surface
    local force = data.force
    local position = find_buildable_location(data)
    local group_size_multiplier = data.group_size_multiplier or 0.2
    if position then
        local spawn_beacon = AttackGroupBeaconProcessor.get_spawn_beacon(surface, force)
        if spawn_beacon then
            local spawn_location = spawn_beacon.position
            local selected_units = surface.find_entities_filtered {
                type = 'unit',
                force = force,
                limit = math.floor(GlobalConfig.max_group_size() * group_size_multiplier),
                position = spawn_location,
                radius = AttackGroupBeaconConstants.SPAWNER_BEACON_RADIUS,
                
            }
            if next(selected_units) then
                local group = surface.create_unit_group({position = spawn_location,force = force})
                for _, unit in pairs(selected_units) do
                    group.add_member(unit)
                end
                group.set_command({
                    type = defines.command.build_base,
                    destination	= position,
                    ignore_planner = true,
                })
                group.start_moving()
            end
        end
    end
end

local attack_siege = function(data)
    if not valid_data_object(data) or not data.builder_name then
        return
    end
    
    local surface = data.surface
    local force = data.force
    local target_force = data.target_force or game.forces['player']

    local group_size_multiplier = data.group_size_multiplier or 1

    local attack_position, spawn_position = get_beacon_positions(data)

    if spawn_position and attack_position  then
        local max_group_size = GlobalConfig.max_group_size()
        local builders = {}
        local builder_number = math.floor(max_group_size * 0.2)
        local builder_limit = 50
        local builder_name = force.name..'--'..data.builder_name..'--1'
        if builder_number > builder_limit then
            builder_number = builder_limit
        end
        for i = 0, builder_number, 1 do
            local new_spawn_position = surface.find_non_colliding_position(collision_finder, spawn_position, 32, 2)                    
            local entity = surface.create_entity({
                name = builder_name,
                position = new_spawn_position,
                force = force
            })
        end

        local selected_units = surface.find_entities_filtered {
            type = 'unit',
            force = force,
            limit = math.floor(max_group_size * group_size_multiplier),
            position = spawn_position,
            radius = AttackGroupBeaconConstants.SPAWNER_BEACON_RADIUS,
            
        }

        local group = surface.create_unit_group({position = spawn_position,force = force})
        local group_has_unit = false
        if next(selected_units) then
            for _, unit in pairs(selected_units) do
                group.add_member(unit)
            end
            group_has_unit = true
        end

        if group_has_unit then
            local command = {
                type = defines.command.attack_area,
                destination	= attack_position,
                radius = 16,
            }
            group.set_command(command)
            group.start_moving()
            storage.erm_unit_groups[group.unique_id] = {
                commands = command,
                start_position = group.position,
                group = group,
                always_angry = false,
                nearby_retry = 0,
                attack_force = target_force.name or 'player',
                created = game.tick
            }
        else
            group.destroy()
        end
    end
end

local attack_double_tap = function(data)
    if not valid_data_object(data) then
        return
    end

    local surface = data.surface
    local force = data.force
    local target_force = data.target_force or game.forces['player']
    local group_size_multiplier = data.group_size_multiplier or 1

    local attack_position, spawn_position = get_beacon_positions(data)

    if spawn_position and attack_position  then
        local max_group_size = math.floor(GlobalConfig.max_group_size() * group_size_multiplier)
        local beacon_radius = AttackGroupBeaconConstants.SPAWNER_BEACON_RADIUS
        if data.is_double_tap then
            spawn_position = Position.calculate_position_x_tiles_further(spawn_position, beacon_radius)
            beacon_radius = beacon_radius
        end
        local selected_units = surface.find_entities_filtered {
            type = 'unit',
            force = force,
            limit = max_group_size,
            position = spawn_position,
            radius = beacon_radius,
            
        }

        local new_spawn_position = surface.find_non_colliding_position(collision_finder, spawn_position, 32, 2)
        local group = surface.create_unit_group({position = new_spawn_position,force = force})
        local group_has_unit = false
        if next(selected_units) then
            for _, unit in pairs(selected_units) do
                group.add_member(unit)
            end
            group_has_unit = true
        end

        if group_has_unit then
            local command = {
                type = defines.command.attack_area,
                destination	= attack_position,
                radius = 16,
            }
            group.set_command(command)
            group.start_moving()

            storage.erm_unit_groups[group.unique_id] = {
                commands = command,
                start_position = group.position,
                group = group,
                always_angry = false,
                nearby_retry = 0,
                attack_force = target_force.name or 'player',
                created = game.tick
            }
        else
            group.destroy()
        end

        if data.is_double_tap then
            data.is_double_tap = false 
        else
            data.is_double_tap = true
            Cron.add_15_sec_queue('EmotionProcessor.run', force.name)
        end
    end
    
end

local attack_rush = function(data)
    if not valid_data_object(data) then
        return
    end

    local surface = data.surface
    local force = data.force
    local target_force = data.target_force or game.forces['player']
    local group_size_multiplier = data.group_size_multiplier or 1

    local attack_position, spawn_position = get_beacon_positions(data)

    if spawn_position and attack_position  then
        local max_group_size = math.floor(GlobalConfig.max_group_size() * group_size_multiplier)
        local beacon_radius = AttackGroupBeaconConstants.SPAWNER_BEACON_RADIUS
        local selected_units = surface.find_entities_filtered {
            type = 'unit',
            force = force,
            limit = max_group_size,
            position = spawn_position,
            radius = beacon_radius,
            
        }

        local new_spawn_position = surface.find_non_colliding_position(collision_finder, spawn_position, 32, 2)
        local group = surface.create_unit_group({position = new_spawn_position,force = force})
        local group_has_unit = false
        if next(selected_units) then
            for _, unit in pairs(selected_units) do
                group.add_member(unit)
            end
            group_has_unit = true
        end

        if group_has_unit then
            local command = {
                type = defines.command.attack_area,
                destination	= attack_position,
                radius = 16,
            }
            group.set_command(command)
            group.start_moving()

            storage.erm_unit_groups[group.unique_id] = {
                commands = command,
                start_position = group.position,
                group = group,
                always_angry = false,
                nearby_retry = 0,
                attack_force = target_force.name or 'player',
                created = game.tick
            }
        else
            group.destroy()
        end
    end
end


local attack_functions = {
    attack_peaceful,
    attack_rapid_expand,
    attack_siege,
    attack_double_tap, 
    attack_rush
}

function EmotionProcessor.init_globals()
    storage.emotion = storage.emotion or {}
end

-- Helper function to compare darkness value based on emotion constants
function EmotionProcessor.compare_darkness(comparision_type, surface_darkness, darkness_value)
    if comparision_type == EmotionConstants.DARK then
        return surface_darkness < darkness_value
    elseif comparision_type == EmotionConstants.LIGHT then
        return surface_darkness > darkness_value
    elseif comparision_type == EmotionConstants.ALL_DAY then
        return true
    end
    return false
end

function EmotionProcessor.switch(data)
    
    local surface  = data['surface']
    local force = data['force']
    local is_boss = data['is_boss']
    
    if data['target_force'] == nil then
        data['target_force'] = game.forces['player']
    end
    
    --- Additional data for use by certain attacks.
    --- data['spawn_location']
    --- data['attack_position']
    ---
    if not surface.valid or not force.valid then
        return
    end

    if data.current_emo == EmotionConstants.EMO_PEACEFUL then
        attack_peaceful(data)
        return
    end

    local emotion_data = storage.emotion[force.name] or {}
    emotion_data = data

    -- Get surface darkness value (0-1)
    local surface_darkness = surface.darkness

    -- Select appropriate emotion data based on boss status
    local race_emo_data = nil
    if is_boss then
        race_emo_data = RaceSettingsHelper.get_boss_emotion_data(force.name)
    else
        race_emo_data = RaceSettingsHelper.get_emotion_data(force.name)
    end
    
    if not emotion_data.current_emo then
        for _, emotion_entry in ipairs(race_emo_data) do
            local emo_type, spawn_chance, emo_compare,
            darkness_value, cooldown, group_size_multiplier = table.unpack(emotion_entry)

            -- Check if emotion is valid based on darkness comparison
            if RaceSettingsHelper.can_spawn(spawn_chance) or emo_type == emotion_data.current_emo and
                    EmotionProcessor.compare_darkness(emo_compare, surface_darkness, darkness_value)
            then
                emotion_data.current_emo = emo_type
                emotion_data.cooldown = cooldown
                emotion_data.group_size_multiplier = group_size_multiplier
            else
                emotion_data.current_emo = EmotionConstants.EMO_PEACEFUL
            end
        end
    end


    if emotion_data.current_emo == EmotionConstants.EMO_RAPID_EXPAND then
        emotion_data.buildable_beacons = collect_resource_and_land_beacons(emotion_data)
    end
    emotion_data.switch_tick = game.tick
    emotion_data.last_run = 0
    storage.emotion[force.name] = emotion_data
end

function EmotionProcessor.check_switches()
    for _, force in pairs(ForceHelper.get_enemy_forces()) do
        local home_planet_name = RaceSettingsHelper.get_home_planet(force.name)
        if home_planet_name then
            local surface = game.surfaces[home_planet_name]
            if surface.valid and
               storage.boss.entity == nil and
               force.get_evolution_factor(surface) > EVOLUTION_FACTOR_START_POINT
                -- Accumulated Attack Points check                             
            then
                EmotionProcessor.switch({
                    surface = surface,
                    force = force,
                    is_boss = false,
                })
            end
        end
    end
end

function EmotionProcessor.queue()
    if next(storage.emotion) then
        for force_name, emotion_data in pairs(storage.emotion) do
            local cooldown = emotion_data.cooldown or DEFAULT_COOLDOWN
            if emotion_data.current_emo ~= EmotionConstants.EMO_PEACEFUL and
                game.tick >=  emotion_data.last_run + cooldown
            then
                Cron.add_quick_queue('EmotionProcessor.run', force_name)
            end 
        end
    end
end

function EmotionProcessor.run(force_name)
    if type(force_name) == "table" then
        force_name = force_name[1]
    end
    local data = storage.emotion[force_name]
    if data and attack_functions[data.current_emo] then
        attack_functions[data.current_emo](data)
        data.last_run = game.tick
    end
end

function EmotionProcessor.set_peaceful_on(surface)
    if next(storage.emotion) then
        for force_name, emotion_data in pairs(storage.emotion) do
            if emotion_data.surface.name == surface.name
            then
                storage.emotion[force_name] = nil
            end
        end
    end 
end

function EmotionProcessor.reset_globals()
    storage.emotion = {}
end

EmotionProcessor.on_nth_tick = {
    [897] =  function(event)
        EmotionProcessor.queue()
    end
}

return EmotionProcessor