---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 10/30/2024 10:08 PM
---
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local QualityProcessor = {}

--- When a player reaches higher quality points.  The following will be the spawn rate of each tier
--- normal, uncommon, rare, epic, legendary
local max_difficulties = {
    [QUALITY_CASUAL] = {0, 0.65, 0.35, 0.5, 0},
    [QUALITY_NORMAL] = {0, 0.25, 0.60, 0.15, 0},
    [QUALITY_ADVANCED] = {0, 0, 0.6, 0.35, 0.05},
    [QUALITY_HARDCORE] = {0, 0, 0.25, 0.6, 0.15},
    [QUALITY_FIGHTER] = {0, 0, 0, 0.50, 0.50},
    [QUALITY_CRUSADER] = {0, 0, 0, 0.20, 0.80},
    [QUALITY_THEONE] = {0, 0, 0, 0, 100},
}
local setting_difficulty, setting_advancement

local max_out_target = 10000
local evolution_target = 4000
local evolution_rich_padding = 0.05
local attack_point_target = 6000
local attack_point_divider = 2000000

-- a flag to check whether re-roll is running to prevent firing another re-oll on same unit.
local is_running_roll

local update_storages = function()
    storage.quality_on_planet = storage.quality_on_planet or {}
    setting_difficulty = settings.global['enemyracemanager-difficulty'].value
    setting_advancement = settings.global['enemyracemanager-advancement'].value
end

---- Similar to spawn table, lerp probability
---
---  usage get_interpolated_value({ { 0, 0.7 }, { 0.2, 0.5 }, { 0.4, 0.4 }, { 0.6, 0.2 }, { 0.8, 0.2 }, { 1.0, 0.15 } }, 0.1) => 0.6
local get_interpolated_value = function(data, time)
    if time < data[1][1] then
        --- bypass picking probability if it hasn't reach the start time
        return 0
    end

    for i = 1, #data - 1 do
        local t1, v1 = data[i][1], data[i][2]
        local t2, v2 = data[i + 1][1], data[i + 1][2]

        -- Check if the given time is exactly at a defined point
        if time == t1 then
            return v1
        elseif time == t2 then
            return v2
        end

        -- Check if the given time falls between two points
        if time > t1 and time < t2 then
            -- Perform linear interpolation
            local ratio = (time - t1) / (t2 - t1)
            return v1 + ratio * (v2 - v1)
        end
    end

    -- Return 0 if time is out of bounds, use previous roll.
    return 0
end

--- Table arrange from legendary to normal.  Leg roll first, normal roll last
local build_quality_table = function(difficulties)
    return {
        { { 9000, 0  }, { 10000, difficulties[5] } },
        { { 7500, 0  }, { 10000, difficulties[4] } },
        { { 4000, 0 }, { 6500, math.min(math.max(difficulties[3] * 2, 1), 0.5) }, { 9000, difficulties[3] }, { 10000, difficulties[3] } },
        { { 2000, 0 }, { 4500, math.min(math.max(difficulties[2] * 2, 1), 0.5) }, { 7000, difficulties[2] }, { 10000, difficulties[2] } },
        { { 0, 1 }, { 4000, 1 }, { 5000, difficulties[1] } }
    }
end
----
--- Normal start at 100% from QP = 0 - 5000
--- Uncommon start at QP = 2000 - 7000
--- Rare start at QP = 4000 - 9000
--- Epic start at QP = 7500
--- Legendary start at QP = 9000
local calculate_chance_cache = function(planet_data, time)
    local selected_difficulties = max_difficulties[setting_difficulty]
    local spawn_table = planet_data.spawn_table or {}
    if setting_difficulty ~= planet_data.table_difficulty then
        spawn_table = build_quality_table(selected_difficulties)
    end
    planet_data.spawn_table = spawn_table
    planet_data.difficulty = setting_difficulty
    planet_data.spawn_rates = {}
    for index, value_set in pairs(spawn_table) do
        planet_data.spawn_rates[index] = get_interpolated_value(value_set, time)
    end
    local spawn_rates_size = table_size(planet_data.spawn_rates)
    planet_data.spawn_rates_size = spawn_rates_size

    for index, _ in pairs(planet_data.spawn_rates) do
        local next_rate = planet_data.spawn_rates[index + 1]
        if next_rate and next_rate == 0 then
            planet_data.lowest_allowed_tier = spawn_rates_size - (index - 1)
            if not planet_data.spawn_rates[index + 2] or planet_data.spawn_rates[index + 2] == 0 then
                break
            end                
        end
    end
    return planet_data
end


---
--- Planet evolution takes 40%, accumulated attack point takes 60%
function QualityProcessor.calculate_quality_points()
    update_storages()
    --storage.quality_on_planet = storage.quality_on_planet or {}
    for _, force in pairs(game.forces) do
        if ForceHelper.is_enemy_force(force) then
            local race_name = ForceHelper.extract_race_name_from(force.name)
            local quality_data = storage.quality_on_planet[force.name] or {}
            local accumulated_attack_meter = RaceSettingsHelper.get_accumulated_attack_meter(race_name)
            for _, planet in pairs(game.planets) do
                if planet.surface then
                    local data = quality_data[planet.name] or {}

                    if data.max_out then
                        break;
                    end

                    local quality_points = ( math.min((force.get_evolution_factor(planet.surface.name) + evolution_rich_padding), 1) ) * evolution_target +
                            math.min((accumulated_attack_meter / attack_point_divider) * attack_point_target, attack_point_target)

                    quality_points = quality_points * setting_advancement

                    data.points = quality_points
                    if quality_points >= max_out_target then
                        data.max_out = true
                    else
                        data.max_out = false
                    end

                    quality_data[planet.name] = calculate_chance_cache(data, quality_points)
                end
            end
            storage.quality_on_planet[force.name] = quality_data
        end
    end
end

function QualityProcessor.get_quality_point(force, planet)
    return storage.quality_on_planet[force][planet].points
end

function QualityProcessor.is_maxed_out(force, planet)
    return  storage.quality_on_planet[force][planet].max_out
end

function QualityProcessor.get_spawn_rate(force, planet)
    return storage.quality_on_planet[force][planet].spawn_rates
end    

function QualityProcessor.reset_globals()
    storage.quality_on_planet = {}
end

function QualityProcessor.roll(entity)
    --- Unit from spawner doesn't need to roll.
    if TEST_BY_PASS_QUALITY or is_running_roll then
        is_running_roll = false
        return
    end

    local name_token = ForceHelper.get_name_token(entity.name)
    local unit_tier = tonumber(name_token[3])
    local force = entity.force
    local surface = entity.surface

    if not storage.quality_on_planet[force.name] then
        QualityProcessor.calculate_quality_points()
    end

    local planet_data = storage.quality_on_planet[force.name][surface.name]
    local spawn_rates = planet_data.spawn_rates
    local spawn_rates_size = planet_data.spawn_rates_size
    local lowest_tier = planet_data.lowest_allowed_tier

    --- no need to reroll if unit is already higher than lowest tier or it's attached to spawner.
    if unit_tier >= lowest_tier or (entity.commandable and entity.commandable.spawner) then
        return
    end

    local can_spawn = false
    local selected_tier
    for index, spawn_rate in pairs(spawn_rates) do
        if spawn_rate > 0 then
            selected_tier = spawn_rates_size - (index - 1)
            if selected_tier == lowest_tier then
                can_spawn = true
            else
                can_spawn = RaceSettingsHelper.can_spawn(spawn_rate)                
            end

            if can_spawn then
                break
            end    
        end
    end

    --- no need to swap if unit is already higher than selected.
    if tonumber(name_token[3]) >= selected_tier then
        return
    end 

    if can_spawn then
        local position = entity.position
        is_running_roll = true
        local new_unit = surface.create_entity {
            name = name_token[1]..'--'..name_token[2]..'--'..selected_tier,
            force = entity.force,
            position = position,
            create_build_effect_smoke = false,
        }

        -- Join group if needed
        --if entity.commandable.is_unit_group then
        --    new_unit.add_member(new_unit)
        --end

        -- destroy and doesn't raise any events since it's replacement.
        entity.destroy()
    end
end

--- Register events
QualityProcessor.events =
{
    [defines.events.on_runtime_mod_setting_changed] = update_storages
}

QualityProcessor.on_tick = {
    [301] = QualityProcessor.calculate_quality_points
}

QualityProcessor.on_init = function(event)
    update_storages()
end

QualityProcessor.on_configuration_changed = function(event)
    update_storages()
end

return QualityProcessor
