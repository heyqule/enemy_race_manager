---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/21/2021 10:45 PM
---

require('util')
require('global')
local String = require('__stdlib__/stdlib/utils/string')
local Event = require('__stdlib__/stdlib/event/event')

local ErmConfig = require('__enemyracemanager__/lib/global_config')
local ErmForceHelper = require('__enemyracemanager__/lib/helper/force_helper')
local ErmRaceSettingsHelper = require('__enemyracemanager__/lib/helper/race_settings_helper')
local ErmDebugHelper = require('__enemyracemanager__/lib/debug_helper')

local Cron = require('__enemyracemanager__/lib/cron_processor')

local AttackGroupBeaconProcessor = require('__enemyracemanager__/lib/attack_group_beacon_processor')
local AttackGroupPathingProcessor = require('__enemyracemanager__/lib/attack_group_pathing_processor')
local ErmAttackGroupHeatProcessor = require('__enemyracemanager__/lib/attack_group_heat_processor')
local ErmSurfaceProcessor = require('__enemyracemanager__/lib/surface_processor')

local ErmCron = require('__enemyracemanager__/lib/cron_processor')

local AttackGroupProcessor = {}

AttackGroupProcessor.MIXED_UNIT_POINTS = 25
AttackGroupProcessor.FLYING_UNIT_POINTS = 75
AttackGroupProcessor.DROPSHIP_UNIT_POINTS = 200

AttackGroupProcessor.UNIT_PER_BATCH = 5
AttackGroupProcessor.MAX_GROUP_SIZE = 2000

AttackGroupProcessor.GROUP_AREA = 128
AttackGroupProcessor.ATTACK_RADIUS = 32

AttackGroupProcessor.GROUP_TYPE_MIXED = 1
AttackGroupProcessor.GROUP_TYPE_FLYING = 2
AttackGroupProcessor.GROUP_TYPE_DROPSHIP = 3
AttackGroupProcessor.GROUP_TYPE_FEATURED = 4
AttackGroupProcessor.GROUP_TYPE_FEATURED_FLYING = 5

AttackGroupProcessor.FLYING_GROUPS = {
    [AttackGroupProcessor.GROUP_TYPE_FLYING] = true,
    [AttackGroupProcessor.GROUP_TYPE_DROPSHIP] = true,
    [AttackGroupProcessor.GROUP_TYPE_FEATURED_FLYING] = true,
}

AttackGroupProcessor.GROUP_TIERS = {
    { 1 },
    { 0.7, 0.3 },
    { 0.4, 0.35, 0.25 }
}

---
--- Track unit group, each race should only have 1 active group generator.
--- Units in a group seems considered active units and they have performance penalty.
---
local get_group_tracker = function(race_name)
    if global.group_tracker == nil then
        return nil
    end

    return global.group_tracker[race_name] or nil
end

local set_group_tracker = function(race_name, value, field)
    if field then
        global.group_tracker[race_name][field] = value
    else
        global.group_tracker[race_name] = value
    end
end

local get_unit_level_for_tier = function(race_name)
    local level = ErmRaceSettingsHelper.get_level(race_name) - 1
    if level == 0 then
        level = 1
    end
    return level
end

local get_unit_name_by_group_type = {
    [AttackGroupProcessor.GROUP_TYPE_MIXED] = function(race_name, current_tier, group_tracker)
        return ErmRaceSettingsHelper.pick_an_unit_from_tier(race_name, current_tier), false
    end,
    [AttackGroupProcessor.GROUP_TYPE_FLYING] = function(race_name, current_tier, group_tracker)
        return ErmRaceSettingsHelper.pick_a_flying_unit_from_tier(race_name, current_tier), false
    end,
    [AttackGroupProcessor.GROUP_TYPE_DROPSHIP] = function(race_name, current_tier, group_tracker)
        return ErmRaceSettingsHelper.pick_dropship_unit(race_name, current_tier), false
    end,
    [AttackGroupProcessor.GROUP_TYPE_FEATURED] = function(race_name, current_tier, group_tracker)
        return ErmRaceSettingsHelper.pick_featured_unit(race_name, group_tracker.featured_group_id), true
    end,
    [AttackGroupProcessor.GROUP_TYPE_FEATURED_FLYING] = function(race_name, current_tier, group_tracker)
        return ErmRaceSettingsHelper.pick_featured_flying_unit(race_name, group_tracker.featured_group_id), true
    end,
}

local pick_an_unit = function(race_name)
    local group_tracker = get_group_tracker(race_name)
    local current_tier = group_tracker.current_tier
    local unit_name = nil
    local is_featured_group = false

    unit_name, is_featured_group = get_unit_name_by_group_type[group_tracker.group_type](race_name, current_tier, group_tracker)
    if unit_name == nil then
        unit_name = ErmRaceSettingsHelper.pick_an_unit(race_name)
    end

    if not is_featured_group then
        group_tracker.current_tier_unit = group_tracker.current_tier_unit + 1

        if group_tracker.current_tier_unit == group_tracker.tiers[current_tier] then
            group_tracker.current_tier_unit = 0
            group_tracker.current_tier = math.min(current_tier + 1, ErmConfig.MAX_TIER)
        end
    end

    return unit_name
end

local add_to_group = function(surface, group, force, race_name, unit_batch)
    local group_tracker = get_group_tracker(race_name)
    if group.valid == false or group_tracker == nil then
        set_group_tracker(race_name, nil)
        return
    end
    local i = 0
    repeat
        local unit_name = pick_an_unit(race_name)
        local unit_full_name = nil
        if group_tracker.is_elite_attack then
            unit_full_name = ErmRaceSettingsHelper.get_race_entity_name(race_name, unit_name, ErmRaceSettingsHelper.get_level(race_name) + ErmConfig.elite_squad_level())
        else
            unit_full_name = ErmRaceSettingsHelper.get_race_entity_name(race_name, unit_name, ErmRaceSettingsHelper.get_level(race_name))
        end

        local position = surface.find_non_colliding_position(unit_full_name, group.position,
                AttackGroupProcessor.GROUP_AREA, 2)
        local entity = surface.create_entity({
            name = unit_full_name,
            position = position,
            force = force
        })
        group.add_member(entity)
        group_tracker.current_size = group_tracker.current_size + 1
        i = i + 1
    until i == unit_batch

    if group_tracker.current_size >= group_tracker.size then
        local entity_data = AttackGroupBeaconProcessor.pick_current_selected_attack_beacon(surface, group.force, true)

        if entity_data and entity_data.position then
            local position = entity_data.position

            local command = AttackGroupPathingProcessor.get_command(surface.index, group_tracker.group_spawn_position, group_tracker.attack_beacon_position)

            if command == nil then
                command = {
                    type = defines.command.attack_area,
                    destination = { x = position.x, y = position.y },
                    radius = AttackGroupProcessor.ATTACK_RADIUS
                }
            end

            if group_tracker.is_precision_attack then
                command['distraction'] = defines.distraction.none
                if ErmConfig.precision_strike_warning() then
                    group.surface.print({
                        'description.message-incoming-precision-attack',
                        race_name,
                        ErmSurfaceProcessor.get_gps_message(
                                position.x,
                                position.y,
                                group.surface.name
                        )
                    }, { r = 1, g = 0, b = 0 })
                end
            end
            group.set_command(command)
            global.erm_unit_groups[group.group_number] = {
                group = group,
                start_position = group.position,
                always_angry = false,
                nearby_retry = 0,
                attack_force = group_tracker.attack_force
            }
        else
            group.set_autonomous()
        end

        set_group_tracker(race_name, nil)
    end
end

local generate_unit_queue = function(
        surface, center_location, force, race_name,
        units_number, group_type, featured_group_id, is_elite_attack,
        group_spawn_position, attack_beacon
)
    group_type = group_type or AttackGroupProcessor.GROUP_TYPE_MIXED

    local queue_length = math.ceil(units_number / AttackGroupProcessor.UNIT_PER_BATCH)
    local last_queue = queue_length - 1
    local last_queue_unit = units_number % AttackGroupProcessor.UNIT_PER_BATCH
    if last_queue_unit == 0 then
        last_queue_unit = AttackGroupProcessor.UNIT_PER_BATCH
    end
    local i = 0

    local tiers = nil
    local is_precision_attack = false
    if group_type == AttackGroupProcessor.GROUP_TYPE_FLYING then
        tiers = AttackGroupProcessor.GROUP_TIERS[math.min(get_unit_level_for_tier(race_name), ErmConfig.MAX_TIER)]

        local flying_unit_precision_enabled = ErmConfig.flying_squad_precision_enabled()
        local spawn_as_flying_unit_precision = ErmRaceSettingsHelper.can_spawn(ErmConfig.flying_squad_precision_chance())

        if flying_unit_precision_enabled and spawn_as_flying_unit_precision then
            is_precision_attack = true
        end
    elseif group_type == AttackGroupProcessor.GROUP_TYPE_DROPSHIP then
        tiers = AttackGroupProcessor.GROUP_TIERS[1]
        is_precision_attack = true
    else
        tiers = AttackGroupProcessor.GROUP_TIERS[ErmRaceSettingsHelper.get_tier(race_name)]
    end
    local tiers_units = {}
    for index, tier in pairs(tiers) do
        tiers_units[index] = math.floor((units_number * tier) + 0.5)
    end

    set_group_tracker(race_name, {
        size = units_number,
        current_size = 0,
        group_type = group_type,
        tiers = tiers_units,
        current_tier = 1,
        current_tier_unit = 0,
        is_precision_attack = is_precision_attack,
        is_elite_attack = is_elite_attack,
        featured_group_id = featured_group_id,
        group_spawn_position = group_spawn_position,
        attack_beacon_position = attack_beacon.position,
        attack_force = attack_beacon.force,
        tick = game.tick,
    })

    local unit_group = surface.create_unit_group({ position = center_location, force = force })

    set_group_tracker(race_name, unit_group, 'group')
    set_group_tracker(race_name, unit_group.group_number, 'group_number')

    repeat
        local unit_batch = AttackGroupProcessor.UNIT_PER_BATCH
        if i == last_queue then
            unit_batch = math.ceil(last_queue_unit)
        end
        ErmCron.add_1_sec_queue(
                'AttackGroupProcessor.add_to_group',
                surface,
                unit_group,
                force,
                race_name,
                unit_batch
        )
        i = i + 1
    until i == queue_length
end

function AttackGroupProcessor.init_globals()
    --- Track all custom unit groups created by ERM
    global.erm_unit_groups = global.erm_unit_groups or {}
    ErmConfig.clear_invalid_erm_unit_groups()

    --- Track custom group spawn data, only one active group spawn per enemy race.
    global.group_tracker = global.group_tracker or {}

    --- Track active scout, only one active scout per enemy race.
    global.scout_tracker = global.scout_tracker or {}
    --- Toggle to run periodic scan when a scout spawns.
    global.scout_scanner = false
end

function AttackGroupProcessor.add_to_group_cron(arg)
    add_to_group(arg[1], arg[2], arg[3], arg[4], arg[5])
end

function AttackGroupProcessor.exec(race_name, force, attack_points)
    if get_group_tracker(race_name) then
        return false
    end

    local flying_enabled = ErmConfig.flying_squad_enabled() and ErmRaceSettingsHelper.has_flying_unit(race_name)
    local spawn_as_flying_squad = ErmRaceSettingsHelper.can_spawn(ErmConfig.flying_squad_chance()) and ErmRaceSettingsHelper.get_level(race_name) > 1
    local spawn_as_featured_squad = ErmRaceSettingsHelper.can_spawn(ErmConfig.featured_squad_chance()) and ErmRaceSettingsHelper.get_tier(race_name) == 3

    --- Try flying Squad. starts at level 2 and max tier at level 4
    if flying_enabled and spawn_as_flying_squad then
        local dropship_enabled = ErmConfig.dropship_enabled() and ErmRaceSettingsHelper.has_dropship_unit(race_name)
        local spawn_as_dropship_squad = ErmRaceSettingsHelper.can_spawn(ErmConfig.dropship_chance())

        if spawn_as_featured_squad and ErmRaceSettingsHelper.has_featured_flying_squad(race_name) then
            --- Drop as featured flying group
            local squad_id = ErmRaceSettingsHelper.get_featured_flying_squad_id(race_name);
            local units_number = math.min(math.ceil(attack_points / ErmRaceSettingsHelper.get_featured_unit_cost(race_name, squad_id)), AttackGroupProcessor.MAX_GROUP_SIZE)
            return AttackGroupProcessor.generate_group(race_name, force, units_number, AttackGroupProcessor.GROUP_TYPE_FEATURED_FLYING, squad_id)
        elseif dropship_enabled and spawn_as_dropship_squad then
            --- Dropship Group
            local units_number = math.min(math.ceil(attack_points / AttackGroupProcessor.DROPSHIP_UNIT_POINTS), AttackGroupProcessor.MAX_GROUP_SIZE)
            return AttackGroupProcessor.generate_group(race_name, force, units_number, AttackGroupProcessor.GROUP_TYPE_DROPSHIP)
        else
            --- Regular Flying Group
            local units_number = math.min(math.ceil(attack_points / AttackGroupProcessor.FLYING_UNIT_POINTS), AttackGroupProcessor.MAX_GROUP_SIZE)
            return AttackGroupProcessor.generate_group(race_name, force, units_number, AttackGroupProcessor.GROUP_TYPE_FLYING)
        end
    else
        if spawn_as_featured_squad and ErmRaceSettingsHelper.has_featured_squad(race_name) then
            --- Regular featured Group
            local squad_id = ErmRaceSettingsHelper.get_featured_squad_id(race_name);
            local units_number = math.min(math.ceil(attack_points / ErmRaceSettingsHelper.get_featured_unit_cost(race_name, squad_id)), AttackGroupProcessor.MAX_GROUP_SIZE)
            return AttackGroupProcessor.generate_group(race_name, force, units_number, AttackGroupProcessor.GROUP_TYPE_FEATURED, squad_id)
        else
            --- Mixed Group
            local units_number = math.min(math.ceil(attack_points / AttackGroupProcessor.MIXED_UNIT_POINTS), AttackGroupProcessor.MAX_GROUP_SIZE)
            return AttackGroupProcessor.generate_group(race_name, force, units_number)
        end
    end
end

function AttackGroupProcessor.generate_group(race_name, force, units_number, type, featured_group_id, is_elite_attack, target_force, surface, from_retry)
    if from_retry == false and get_group_tracker(race_name) then
        return false
    end
    target_force = target_force or ErmAttackGroupHeatProcessor.pick_target(race_name)
    surface = surface or ErmAttackGroupHeatProcessor.pick_surface(race_name, target_force, true)

    if surface == nil or not surface.valid then
        set_group_tracker(race_name, nil)
        return false
    end
    from_retry = from_retry or false

    AttackGroupProcessor.UNIT_PER_BATCH = math.ceil(ErmConfig.max_group_size() * ErmConfig.attack_meter_threshold() / AttackGroupProcessor.MIXED_UNIT_POINTS)

    local attack_beacon_data = AttackGroupBeaconProcessor.pick_new_attack_beacon(surface, force, target_force)
    local spawn_beacon = nil
    local halt_cron = false
    if attack_beacon_data == nil then
        halt_cron = true
    else
        spawn_beacon, halt_cron = AttackGroupBeaconProcessor.pick_spawn_location(surface, force, attack_beacon_data, from_retry)
    end

    if spawn_beacon == nil then
        if halt_cron == false then
            -- Retry to find new beacons
            ErmCron.add_quick_queue('AttackGroupProcessor.generate_group',
                    race_name, force, units_number, type, featured_group_id,
                    is_elite_attack, target_force, surface, true)
        else
            -- Drop current group if retry fails
            set_group_tracker(race_name, nil)
        end
        return false
    end

    local scout = AttackGroupBeaconProcessor.get_scout_name(race_name, AttackGroupBeaconProcessor.LAND_SCOUT)
    local center_location = surface.find_non_colliding_position(
            scout, spawn_beacon.position,
            AttackGroupProcessor.GROUP_AREA, 1)

    if center_location then
        generate_unit_queue(
                surface, center_location, force,
                race_name, units_number, type,
                featured_group_id, is_elite_attack,
                center_location, attack_beacon_data.beacon
        )

        if is_elite_attack then
            Event.dispatch({
                name = Event.get_event_name(ErmConfig.ADJUST_ACCUMULATED_ATTACK_METER),
                race_name = race_name
            })
        end
        Event.dispatch({
            name = Event.get_event_name(ErmConfig.ADJUST_ATTACK_METER),
            race_name = race_name
        })
        local is_aerial = AttackGroupProcessor.FLYING_GROUPS[type] or false
        Event.dispatch({
            name = Event.get_event_name(ErmConfig.REQUEST_PATH),
            source_force = force,
            surface = surface,
            start = center_location,
            goal = attack_beacon_data.position,
            is_aerial = is_aerial
        })

        return true
    end

    return false
end

function AttackGroupProcessor.generate_nuked_group(surface, position, radius, source_entity)
    local target_unit = surface.find_entities_filtered({
        type = { "unit-spawner" },
        force = ErmForceHelper.get_enemy_forces(),
        area = {
            { position.x - radius, position.y - radius },
            { position.x + radius, position.y + radius }
        },
        limit = 1
    })
    local units = {}

    if #target_unit == 0 then
        return
    end

    target_unit = target_unit[1]
    units = surface.find_units({
        area = {
            { position.x - radius, position.y - radius },
            { position.x + radius, position.y + radius }
        },
        force = target_unit.force,
        condition = 'same'
    })

    if #units >= 50 then
        local group = surface.create_unit_group({ position = target_unit.position, force = target_unit.force })
        local max_unit = ErmConfig.max_group_size()
        local i = 0
        for _, unit in pairs(units) do
            group.add_member(unit)
            i = i + 1
            if max_unit == i then
                break
            end
        end

        AttackGroupProcessor.process_attack_position(group, defines.distraction.by_anything, source_entity.force.name)

        global.erm_unit_groups[group.group_number] = {
            group = group,
            start_position = group.position,
            always_angry = true,
            nearby_retry = 0,
            attack_force = source_entity.force
        }
    end
end

-- Spawn Elite Group
function AttackGroupProcessor.exec_elite_group(race_name, force, attack_points)
    if get_group_tracker(race_name) then
        return false
    end

    if not ErmRaceSettingsHelper.has_featured_flying_squad(race_name) and
            not ErmRaceSettingsHelper.has_featured_squad(race_name) then
        return false
    end

    local flying_enabled = ErmConfig.flying_squad_enabled() and ErmRaceSettingsHelper.has_flying_unit(race_name)
    local spawn_as_flying_squad = ErmRaceSettingsHelper.can_spawn(ErmConfig.flying_squad_chance())

    if flying_enabled and spawn_as_flying_squad and ErmRaceSettingsHelper.has_featured_flying_squad(race_name) then
        local squad_id = ErmRaceSettingsHelper.get_featured_flying_squad_id(race_name);
        local units_number = math.min(math.ceil(attack_points / ErmRaceSettingsHelper.get_featured_unit_cost(race_name, squad_id)), AttackGroupProcessor.MAX_GROUP_SIZE)
        return AttackGroupProcessor.generate_group(race_name, force, units_number, AttackGroupProcessor.GROUP_TYPE_FEATURED_FLYING, squad_id, true)
    elseif ErmRaceSettingsHelper.has_featured_squad(race_name) then
        local squad_id = ErmRaceSettingsHelper.get_featured_squad_id(race_name);
        local units_number = math.min(math.ceil(attack_points / ErmRaceSettingsHelper.get_featured_unit_cost(race_name, squad_id)), AttackGroupProcessor.MAX_GROUP_SIZE)
        return AttackGroupProcessor.generate_group(race_name, force, units_number, AttackGroupProcessor.GROUP_TYPE_FEATURED, squad_id, true)
    end

    return false
end

function AttackGroupProcessor.process_attack_position(group, distraction, find_nearby, target_force, new_beacon)
    distraction = distraction or defines.distraction.by_enemy
    find_nearby = find_nearby or false
    new_beacon = new_beacon or false
    target_force = target_force or game.forces['player']

    local attack_position = nil

    if find_nearby then
        attack_position = AttackGroupBeaconProcessor.pick_nearby_attack_location(group.surface, group.position)
    end

    if attack_position == nil then
        local beacon = AttackGroupBeaconProcessor.pick_attack_beacon(group.surface, group.force, target_force, new_beacon)
        attack_position = beacon.position
    end

    if attack_position then
        local command = {
            type = defines.command.attack_area,
            destination = { x = attack_position.x, y = attack_position.y },
            radius = AttackGroupProcessor.ATTACK_RADIUS,
            distraction = distraction
        }
        group.set_command(command)
    else
        group.set_autonomous()
    end
end

function AttackGroupProcessor.spawn_scout(race_name, source_force, surface, target_force)
    if global.scout_tracker[race_name] then
        return nil
    end

    local scout_name = AttackGroupBeaconProcessor.LAND_SCOUT
    if ErmRaceSettingsHelper.can_spawn(25) and not TEST_MODE then
        scout_name = AttackGroupBeaconProcessor.AERIAL_SCOUT
    end

    scout_name = AttackGroupBeaconProcessor.get_scout_name(race_name, scout_name)

    local target_beacon = AttackGroupBeaconProcessor.get_attackable_spawn_beacon(surface, target_force)
    local spawn_beacon = AttackGroupBeaconProcessor.get_spawn_beacon(surface, source_force)

    if spawn_beacon == nil or target_beacon == nil then
        return nil
    end

    local spawn_location = surface.find_non_colliding_position(
            scout_name, spawn_beacon.position,
            AttackGroupProcessor.GROUP_AREA, 1)

    local scout = surface.create_entity({
        name = scout_name,
        force = source_force,
        position = spawn_location
    })

    scout.set_command({
        type = defines.command.go_to_location,
        destination = target_beacon.position,
        radius = 16,
        distraction = defines.distraction.none
    })

    global.scout_tracker[race_name] = {
        entity = scout,
        unit_number = scout.unit_number,
        position = scout.position,
        final_destination = target_beacon.position,
        update_tick = game.tick
    }

    if global.scout_scanner == false then
        global.scout_scanner = true
        Cron.add_15_sec_queue('AttackGroupBeaconProcessor.start_scout_scan')
    end

    return scout
end

return AttackGroupProcessor