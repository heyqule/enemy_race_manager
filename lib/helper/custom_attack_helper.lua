---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/24/2021 6:52 PM
---
require("__enemyracemanager__/setting-constants")
require("util")
local String = require('__erm_libs__/stdlib/string')
local Orientation = require('__erm_libs__/stdlib/orientation')
local Direction = require('__erm_libs__/stdlib/direction')
local Position = require('__erm_libs__/stdlib/position')
local Table = require("__erm_libs__/stdlib/table")

local GlobalConfig = require("__enemyracemanager__/lib/global_config")
local UtilHelper = require("__enemyracemanager__/lib/helper/util_helper")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")

local ATTACK_CHUNK_SIZE = 32
local NON_COLLISION_GAP = 4
local MIN_DISTANCE_FROM_PLAYER_BASE = 32 -- Minimum tiles from player entities to allow unit drops

local FEATURE_RACE_NAME = 1
local FEATURE_RACE_SPAWN_DATA = 2
local FEATURE_RACE_SPAWN_CACHE = 4
local FEATURE_RACE_SPAWN_CACHE_SIZE = 5

local rock_names = {
    "big-rock",
    "big-sand-rock",
    "huge-rock",
}
if script.active_mods["space-age"] then
    rock_names = Table.array_combine(rock_names, {
        "big-volcanic-rock",
        "huge-volcanic-rock",
        "big-fulgora-rock"
    })
end

local get_name_token = function(name)
    if storage.force_entity_name_cache and storage.force_entity_name_cache[name] then
        return storage.force_entity_name_cache[name]
    end

    if storage.force_entity_name_cache == nil then
        storage.force_entity_name_cache = {}
    end

    if storage.force_entity_name_cache[name] == nil then
        if string.find(name, "--", 1, true) then
            storage.force_entity_name_cache[name] = String.split(name, "--")
        else
            return nil
        end
    end

    return storage.force_entity_name_cache[name]
end

local get_race_settings = function(force_name, reload)
    if storage.custom_attack_race_settings == nil then
        storage.custom_attack_race_settings = {}
    end

    if storage.custom_attack_race_settings[force_name] == nil or
        storage.custom_attack_race_settings[force_name].tick == nil
    then
        storage.custom_attack_race_settings[force_name] = {
            tick = 0
        }
    end

    if storage.custom_attack_race_settings[force_name] and
        not reload and
        game.tick < storage.custom_attack_race_settings[force_name].tick
    then
        return storage.custom_attack_race_settings[force_name]
    end

    storage.custom_attack_race_settings[force_name] = remote.call("enemyracemanager", "get_race", force_name)
    storage.custom_attack_race_settings[force_name].tick = game.tick + minute * GlobalConfig.RACE_SETTING_UPDATE_INTERVAL + 1
    return storage.custom_attack_race_settings[force_name]
end

local get_low_tier_flying_unit = function(force_name)
    local race_settings = get_race_settings(force_name)
    if type(race_settings["flying_units"][1][1]) ~= nil then
        return race_settings["flying_units"][1][1]
    end

    return nil
end

local is_too_close_to_player_base = function(surface, position, min_distance)
    min_distance = min_distance or MIN_DISTANCE_FROM_PLAYER_BASE
    local player_entities = surface.count_entities_filtered({
        force = ForceHelper.get_player_forces(),
        position = position,
        radius = min_distance,
        limit = 1
    })
    return player_entities > 0
end

local get_drop_position = function(final_unit_name, surface, position, force_name, level)
    local drop_position = {x=position.x + math.random(-4,4), y= position.y + math.random(-4,4)}
    if not surface.can_place_entity({ name = final_unit_name, position = drop_position }) then
        drop_position = surface.find_non_colliding_position(final_unit_name, drop_position, 8, 2, true)

        if drop_position == nil then
            local low_tier_flyer_name = get_low_tier_flying_unit(force_name)
            if low_tier_flyer_name then
                final_unit_name = force_name .. "--" .. low_tier_flyer_name .."--" .. tostring(level)
                drop_position = surface.find_non_colliding_position(final_unit_name, position, 8, 2, true)
            end
        end
    end
    
    -- Check if position is too close to player base
    if drop_position and is_too_close_to_player_base(surface, drop_position) then
        return final_unit_name, nil
    end
    
    return final_unit_name, drop_position
end

local add_member = function(final_unit_name, surface, drop_position, force_name, group, quality)
    if drop_position then
        quality = quality or 'normal'
        remote.call('enemyracemanager','skip_roll_quality')
        local entity = surface.create_entity({ 
            name = final_unit_name, 
            position = drop_position, 
            force = force_name,
            quality = quality
        })
        if entity and entity.type == "unit" then
            if group.valid and group.is_unit_group then
                group.add_member(entity)
            end
        end
    end
end

local drop_unit = function(event, force_name, unit_name, count, position)
    position = position or event.source_position or event.source_entity.position
    count = count or 1
    local source_entity_force_name = force_name
    get_race_settings(force_name)
    local surface = game.surfaces[event.surface_index]
    local level = 1
    local source_entity = event.source_entity
    if source_entity then
        source_entity_force_name = source_entity.force.name
        local name_tokens = get_name_token(source_entity.name)
        level = name_tokens[3]
    elseif surface.name == storage.custom_attack_race_settings[force_name].home_planet then
        level = GlobalConfig.MAX_LEVELS
    end

    position.x = position.x + 2

    local final_unit_name = force_name .. "--" .. unit_name .. "--" .. level

    if not surface.can_place_entity({ name = final_unit_name, position = position }) then
        position = surface.find_non_colliding_position(final_unit_name, position, 8, 2, true)
    end

    -- Check if position is too close to player base - if so, skip spawning
    if position and is_too_close_to_player_base(surface, position) then
        return
    end

    if position then
        local idx = 0;
        while idx < count do
            remote.call('enemyracemanager','skip_roll_quality')
            local entity = surface.create_entity({ name = final_unit_name, position = position, force = source_entity_force_name })
            if entity and entity.type == "unit" then
                entity.commandable.set_command({
                    type = defines.command.attack_area,
                    destination = { x = position.x, y = position.y },
                    radius = ATTACK_CHUNK_SIZE,
                    distraction = defines.distraction.by_anything
                })

                if source_entity and
                        source_entity.type == "unit" and
                        source_entity.commandable and
                        source_entity.commandable.is_unit_group and
                        source_entity.commandable.force == entity.force
                then
                    source_entity.commandable.add_member(entity)
                end
            end
            idx = idx + 1
        end
    end
end

local drop_player_unit = function(event, force_name, unit_name, count, position)
    position = position or event.source_position or event.source_entity.position
    local race_settings = get_race_settings(force_name)
    local force = event.source_entity.force or "player"
    local surface = game.surfaces[event.surface_index]

    local final_unit_name = force_name .. "--" .. unit_name

    if not surface.can_place_entity({ name = final_unit_name, position = position }) then
        position = surface.find_non_colliding_position(final_unit_name, position, 8, 2, true)
    end

    if position then
        local idx = 0;
        while idx < count do
            local entity = surface.create_entity({ name = final_unit_name, position = position, force = force })
            if entity and entity.valid and entity.type == "unit" then
                entity.commandable.set_command({
                    type = defines.command.attack_area,
                    destination = { x = position.x, y = position.y },
                    radius = ATTACK_CHUNK_SIZE,
                    distraction = defines.distraction.by_anything
                })
            end
            idx = idx + 1
        end
    end
end

local CustomAttackHelper = {}

CustomAttackHelper.can_spawn = UtilHelper.can_spawn

function CustomAttackHelper.get_race_settings(force_name, force)
    local settings = get_race_settings(force_name, force)
    return settings
end

function CustomAttackHelper.valid(event, force_name)
    return (event.source_entity and
            string.find(event.source_entity.name, force_name, 1, true) ~= nil) or
            string.find(event.effect_id, "-bs", 1, true) ~= nil
end

function CustomAttackHelper.get_unit(force_name, unit_type)
    local race_settings = get_race_settings(force_name)

    if race_settings == nil or race_settings[unit_type] == nil then
        return
    end

    local unit_data = race_settings[unit_type][race_settings.tier]

    return unit_data[FEATURE_RACE_NAME][unit_data[FEATURE_RACE_SPAWN_CACHE][math.random(unit_data[FEATURE_RACE_SPAWN_CACHE_SIZE])]]
end

---
--- Process single type of unit drops
---
function CustomAttackHelper.drop_player_unit(event, force_name, unit_name, count, position)
    drop_player_unit(event, force_name, unit_name, count, position)
end

---
--- Process single type of unit drops
---
function CustomAttackHelper.drop_unit_at_target(event, force_name, unit_name, count)
    drop_unit(event, force_name, unit_name, count, event.target_position)
end

---
--- Process single type of unit drops
---
function CustomAttackHelper.drop_unit(event, force_name, unit_name, count)
    drop_unit(event, force_name, unit_name, count)
end

---
--- Process batch unit drops
---
function CustomAttackHelper.drop_batch_units(event, force_name, count)
    local race_settings = get_race_settings(force_name)

    if race_settings == nil then
        return
    end

    count = count or 10
    local surface = game.surfaces[event.surface_index]
    local level
    local source_entity = event.source_entity

    local position = event.target_position or event.target_entity.position
    position.x = position.x + 2

    local i = 0
    local group = nil
    local new_group = false

    if source_entity and source_entity.commandable then
        group = source_entity.commandable
        force_name = source_entity.force.name
        local name_tokens = get_name_token(source_entity.name)
        if name_tokens[3] then
            level = name_tokens[3]
        end
    else
        group = surface.create_unit_group {
            position = position, force = force_name
        }
        new_group = true
        remote.call("enemyracemanager", "add_erm_attack_group", group)
    end

    if level == nil then
        level = remote.call("enemyracemanager", "roll_quality", force_name, surface.name)
    end

    repeat
        local final_unit_name = force_name .. "--" .. CustomAttackHelper.get_unit(force_name, "droppable_units") .. "--" .. level
        local drop_position
        final_unit_name, drop_position = get_drop_position(final_unit_name, surface, position, force_name, level)
        add_member(final_unit_name, surface, drop_position, force_name, group)
        i = i + 1
    until i == count

    if group.valid and new_group then
        group.set_command({
            type = defines.command.attack_area,
            destination = { x = position.x, y = position.y },
            radius = ATTACK_CHUNK_SIZE,
            distraction = defines.distraction.by_anything
        })
    end
end

---
--- Process Boss Attack Group
---
function CustomAttackHelper.drop_boss_units(event, force_name, count)
    count = count or 10
    local boss_data = remote.call("enemyracemanager", "get_boss_data")
    if boss_data == nil then
        return
    end

    local surface = game.surfaces[event.surface_index]
    local nameToken = get_name_token(boss_data.entity_name)
    local level = tonumber(nameToken[3])

    local position = event.target_position or event.target_entity.position
    position.x = position.x + 2

    local i = 0
    local group = surface.create_unit_group {
        position = position, force = boss_data.force
    }
    repeat
        local final_unit_name = force_name .. "--" .. CustomAttackHelper.get_unit(force_name, "droppable_units") .. "--6"
        local drop_position
        final_unit_name, drop_position = get_drop_position(final_unit_name, surface, position, force_name, level)
        add_member(final_unit_name, surface, drop_position, boss_data.force, group, boss_data.quality)
        i = i + 1
    until i == count

    local target_position = boss_data.target_position

    if target_position == nil then
        target_position = boss_data.silo_position
    end

    group.set_command({
        type = defines.command.attack_area,
        destination = { x = target_position.x, y = target_position.y },
        radius = ATTACK_CHUNK_SIZE,
        distraction = defines.distraction.by_anything
    })
    remote.call("enemyracemanager", "add_erm_attack_group", group)
    group.start_moving()
end

local break_time_to_live = function(count, max_count, units_total)
    return count == max_count or units_total == 0
end

--- Try target trees and rocks when the parent unit is stuck on pathing and timed unit don"t have targets.
--- @TODO need to fix big rock entities
local try_kill_a_tree_or_rock = function(units)
    local is_enemy_force = false
    local next_idx, value
    for i = 1, 5, 1 do
        next_idx, value = next(units, next_idx)

        local entity
        if value and value.entity then
            entity = value.entity
        end

        if entity and entity.valid then
            if not is_enemy_force then
                is_enemy_force = remote.call("enemyracemanager", "is_enemy_force", entity.force)
            end

            local command = entity.commandable.command
            if is_enemy_force and
                    command and (command.type == nil or command.type == defines.command.wander)
            then
                local surface = entity.surface
                local idx, target_entity
                local entities = surface.find_entities_filtered({
                    position = entity.position,
                    radius = ATTACK_CHUNK_SIZE,
                    name = rock_names,
                    limit = 1,
                })

                idx, target_entity = next(entities)

                if not target_entity then
                    local entities = surface.find_entities_filtered({
                        position = entity.position,
                        radius = ATTACK_CHUNK_SIZE,
                        type = {"tree"},
                        limit = 1,
                    })

                    idx, target_entity = next(entities)
                end

                if target_entity then
                    entity.commandable.set_command({
                        type = defines.command.attack,
                        target = target_entity,
                    })
                end
            end
        end
    end
end

---
--- Clean up time to live units
---
function CustomAttackHelper.clear_time_to_live_units(event, regular_batch, overflow_batch)
    regular_batch = regular_batch or GlobalConfig.TIME_TO_LIVE_UNIT_BATCH
    overflow_batch = overflow_batch or GlobalConfig.OVERFLOW_TIME_TO_LIVE_UNIT_BATCH

    local unit_total = storage.time_to_live_units_total
    local units = storage.time_to_live_units

    if unit_total == nil or unit_total == 0 then
        return
    end

    local count = 0
    local max_count = regular_batch
    if unit_total > GlobalConfig.MAX_TIME_TO_LIVE_UNIT then
        max_count = overflow_batch
    end
    for idx, value in pairs(units) do
        local entity = value.entity
        if entity.valid then
            if value.time < event.tick then
                entity.die()
            end
        else
            units[idx] = nil
            unit_total = unit_total - 1
        end

        count = count + 1
        if break_time_to_live(count, max_count, unit_total) then
            break
        end
    end

    try_kill_a_tree_or_rock(units)

    storage.time_to_live_units_total = unit_total
end

function CustomAttackHelper.time_to_live_unit_died(source_unit)
    if source_unit and source_unit.unit_number and
            storage.time_to_live_units and storage.time_to_live_units[source_unit.unit_number] then
        storage.time_to_live_units[source_unit.unit_number] = nil
        storage.time_to_live_units_total = storage.time_to_live_units_total - 1
    end
end

function CustomAttackHelper.process_self_destruct(event)
    if event.source_entity then
        event.source_entity.die()
    end
end

function CustomAttackHelper.process_time_to_live_unit_created(event)
    if event.source_entity == nil then
        return
    end

    if storage.time_to_live_units == nil then
        storage.time_to_live_units = {}
        storage.time_to_live_units_total = 0
    end

    local entity = event.source_entity
    local nameTokens = get_name_token(entity.name)
    local race_settings = get_race_settings(nameTokens[1])
    local name = nameTokens[2]

    if race_settings.timed_units and race_settings.timed_units[name] and entity.valid then
        storage.time_to_live_units[entity.unit_number] = {
            entity = entity,
            time = event.tick + entity.prototype.min_pursue_time
        }
        storage.time_to_live_units_total = storage.time_to_live_units_total + 1
    end
end

function CustomAttackHelper.process_time_to_live_unit_died(event)
    if event.source_entity then
        CustomAttackHelper.time_to_live_unit_died(event.source_entity)
    end
end

local opposition_position_calculation = {
    [defines.direction.north] = function(target_position, distance, offset)
        return { target_position.x + offset, target_position.y + distance}
    end,
    [defines.direction.south] = function(target_position, distance, offset)
        return { target_position.x + offset, target_position.y - distance}
    end,
    [defines.direction.east] = function(target_position, distance, offset)
        return { target_position.x - distance, target_position.y + offset }
    end,
    [defines.direction.west] = function(target_position, distance, offset)
        return { target_position.x + distance, target_position.y + offset }
    end
}

local rounding_orientation = function(orientation)
    if orientation > 0.625 and orientation <= 0.875 then
        orientation = 0.75
    elseif orientation > 0.375 and orientation <= 0.625 then
        orientation = 0.5
    elseif orientation > 0.125 and orientation <= 0.375 then
        orientation = 0.25
    else
        orientation = 0
    end
    return orientation
end

function CustomAttackHelper.process_guerrilla(event)
    if not event.source_entity or not event.source_entity.valid then
        return
    end

    local unit = event.source_entity
    local commandable = unit.commandable
    
    if not storage.guerrilla_distances[unit.name] then
        local prototype = unit.prototype
        local distance = math.ceil((prototype.vision_distance / 1.25) - prototype.attack_parameters.range)
        storage.guerrilla_distances[unit.name] = distance
    end
    
    local orientation = rounding_orientation(unit.orientation)
    
    local position = opposition_position_calculation[Orientation.to_direction(orientation)](
        unit.position,
        storage.guerrilla_distances[unit.name],
        math.random(-8,8)
    )

    commandable.set_command( {
        type = defines.command.go_to_location,
        distraction = defines.distraction.none,
        destination = position,
    })
end

local get_build_bounding_box = function(orientation)
    local bounding_box = {x=12, y=4}
    if (orientation > 0.625 and orientation <= 0.875) or
       (orientation > 0.125 and orientation <= 0.375) 
    then
        bounding_box = {x=4, y=12}
    end
    return bounding_box
end

local build = function(event, force_name, building_name, position)
    position = position or event.source_position or event.source_entity.position
    local source_entity = event.source_entity
    local source_entity_force_name = force_name
    local orientation
    local level = GlobalConfig.MAX_LEVELS
    if source_entity then
        source_entity_force_name = event.source_entity.force.name
        orientation = source_entity.orientation
        local name_tokens = get_name_token(source_entity.name)
        level = tonumber(name_tokens[3])
    else
        orientation = Direction.to_orientation(
                        Position.direction_to(event.source_position, event.target_position)
                      )
    end

    local surface = game.surfaces[event.surface_index]

    if level > GlobalConfig.MAX_LEVELS then
        level = GlobalConfig.MAX_LEVELS
    end

    position.x = position.x + 2

    local final_unit_name = force_name .. "--" .. building_name .. "--" .. level

    if not surface.can_place_entity({ name = final_unit_name, position = position }) then
        local building_box = get_build_bounding_box(orientation)
        position = surface.find_non_colliding_position_in_box(final_unit_name, 
                {{x=position.x-building_box.x, y=position.y-building_box.y},{x=position.x+building_box.x, y=position.y+building_box.y}},
                NON_COLLISION_GAP, true)
    end

    if position then
        remote.call('enemyracemanager','skip_roll_quality')
        local entity = surface.create_entity({ 
            name = final_unit_name, 
            position = position, 
            force = source_entity_force_name,
            preserve_ghosts_and_corpses = true
        })
    end
end

function CustomAttackHelper.build(event, force_name, unit_name, position)
    build(event, force_name, unit_name, position)
end

local boss_build = function(event, force_name, building_name, position)
    position = position or event.source_position or event.source_entity.position
    local source_entity = event.source_entity
    local source_entity_force_name = event.source_entity.force.name or force_name
    local race_settings = get_race_settings(force_name)
    local surface = game.surfaces[event.surface_index]
    local name_tokens = get_name_token(source_entity.name)
    local level = tonumber(name_tokens[3])

    if level > GlobalConfig.BOSS_MAX_TIERS then
        level = GlobalConfig.BOSS_MAX_TIERS
    end

    position.x = position.x + 2

    local final_unit_name = force_name .. "--" .. building_name .. "--" .. level

    if not surface.can_place_entity({ name = final_unit_name, position = position }) then
        position = surface.find_non_colliding_position(final_unit_name, position, ATTACK_CHUNK_SIZE, NON_COLLISION_GAP, true)
    end

    if position then
        remote.call('enemyracemanager','skip_roll_quality')
        local entity = surface.create_entity({
            name = final_unit_name,
            position = position,
            force = source_entity_force_name,
            preserve_ghosts_and_corpses = true,
            quality = source_entity.quality
        })
    end
end


function CustomAttackHelper.boss_build(event, force_name, unit_name, position)
    boss_build(event, force_name, unit_name, position)
end

return CustomAttackHelper