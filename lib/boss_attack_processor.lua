---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/16/2022 2:58 PM
---
local Table = require("__erm_libs__/stdlib/table")
local Position = require("__erm_libs__/stdlib/position")
local Direction = require("__erm_libs__/stdlib/direction")
local Territory = require("__erm_libs__/stdlib/territory")
local GlobalConfig = require("__enemyracemanager__/lib/global_config")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local RaceSettingsHelper = require("__enemyracemanager__/lib/helper/race_settings_helper")
local AttackGroupBeaconConstants = require("__enemyracemanager__/lib/attack_group_beacon_constants")
local AttackGroupBeaconProcessor = require("__enemyracemanager__/lib/attack_group_beacon_processor")
local EmotionConstants = require("__enemyracemanager__/lib/emotion_constants")
local EmotionProcessor = require("__enemyracemanager__/lib/emotion_processor")
local Cron = require("__enemyracemanager__/lib/cron_processor")

local DebugHelper = require("__enemyracemanager__/lib/debug_helper")

local BossAttackProcessor = {}

BossAttackProcessor.TYPE_PROJECTILE = 1
BossAttackProcessor.TYPE_FALLING_PROJECTILE = 2
BossAttackProcessor.TYPE_BEAM = 3
BossAttackProcessor.TYPE_DIRECT = 4
BossAttackProcessor.TYPE_STRUCT_SPAWN = 5
BossAttackProcessor.TYPE_UNIT_SPAWN = 6
BossAttackProcessor.TYPE_SEGMENTED_UNIT_SPAWN = 7
BossAttackProcessor.TYPE_SELECT_NEARBY_ENEMY = 8

local scanRange = 2000
local scanExtraPadding = 160
local scanAttackEntityLimit = 50
local scanTotalAttackEntityLimit = 200
local bossRadius = 96
local chunksize = 32
local type_name = { "projectile", 'falling_projectile', "beam", "direct" }
local turret_types =  {'artillery-turret','fluid-turret','ammo-turret', 'electric-turret', 'turret'}
local artillery_target_cache_tick = 1 * minute

local acquire_attack_target = function(data)
    local artillery_mode = data.artillery_mode or false
    local only_targets_radar = data.only_targets_radar or false
    local can_aim_attackable_targets = data.can_aim_attackable_targets or true

    local return_position
    local boss = storage.boss
    local surface = boss.surface
    local attackable_entities_cache = boss.close_range_entities_cache or {}
    local attackable_entities_cache_size = boss.close_range_entities_cache_size or 0
    
    ---- 20% targets radar
    if (only_targets_radar or RaceSettingsHelper.can_spawn(20)) then
        local offset = math.random(-8, 8)
        return_position = {x = boss.radar_position.x + offset, y = boss.radar_position.y}
        return return_position, true
    end
    
    ---- 10% targets attackable targets
    if boss.radar and boss.radar.valid and (can_aim_attackable_targets and RaceSettingsHelper.can_spawn(10)) then
        local beacon_data = AttackGroupBeaconProcessor.pick_new_attack_beacon(
            boss.surface, 
            boss.force,
            boss.radar.force
        )
        
        if beacon_data then
            local attackable_entity = AttackGroupBeaconProcessor.get_an_attackable_entity(beacon_data.beacon)
            if attackable_entity then
                return attackable_entity.position, true
            end
        end
    end

    --- Close range combat
    if attackable_entities_cache_size == 0 and not artillery_mode then
        attackable_entities_cache = surface.find_entities_filtered {
            force = ForceHelper.get_player_forces(),
            radius = bossRadius,
            position = boss.entity_position,
            limit = scanAttackEntityLimit,
            is_military_target = true,
            
        }
        attackable_entities_cache_size = #attackable_entities_cache

        if attackable_entities_cache_size > 0 then
            storage.boss.close_range_entities_cache = attackable_entities_cache
            storage.boss.close_range_entities_cache_size = attackable_entities_cache_size
        else
            --- bypass close entity till next heartbeat
            storage.boss.close_range_entities_cache_size = -1
        end
    end

    if attackable_entities_cache_size == 0 and 
       boss.long_range_entities_cache_size and 
       game.tick < (boss.long_range_entities_cache_tick or 0) + artillery_target_cache_tick 
    then
        attackable_entities_cache = boss.long_range_entities_cache
        attackable_entities_cache_size = boss.long_range_entities_cache_size
    end
    
    --- artillery range combat, nuke turrets
    if (attackable_entities_cache_size == 0) and not boss.indexing_artillery_targets
    then
        BossAttackProcessor.create_artillery_targets_index()
    end

    if attackable_entities_cache_size > 0 then
        local retry = 0
        repeat
            local index = math.random(1, attackable_entities_cache_size)
            local entity = attackable_entities_cache[index]
            if entity and entity.valid then
                return_position = entity.position
            else
                table.remove(attackable_entities_cache, index)
                attackable_entities_cache_size = attackable_entities_cache_size - 1
            end
            retry = retry + 1
        until return_position or retry == 5
    end

    if return_position == nil then
        return_position = boss.radar_position or {0, 0}
    end

    if Position.distance(boss.entity_position, return_position) > bossRadius then
        artillery_mode = true 
    end

    return return_position, artillery_mode

end

local queue_attack = function(data)
    for i = 1, data.spread do
        local position, artillery_mode = acquire_attack_target(data)
        data.artillery_mode = artillery_mode
        data.position = position
        Cron.add_boss_queue("BossAttackProcessor.process_attack", table.deepcopy(data))
    end
end

local can_spawn = RaceSettingsHelper.can_spawn

local set_optional_data = function(data, attacks, index, name)
    if attacks[name] then
        data[name] = attacks[name][index]
    end

    return data
end

local select_attack = function(mod_name, attacks, tier)
    local data
    local boss = storage.boss
    for i, value in pairs(attacks.attack_name) do
        if can_spawn(attacks.attack_chance[i][tier]) then
            local entity_name
            if type_name[attacks.attack_type[i]] then
                entity_name = mod_name .. "--" .. value .. "--" .. type_name[attacks.attack_type[i]]
            else
                --- other attack types may require additional name processing when under process_attack().
                entity_name = mod_name .. "--" .. value
            end
            data = {
                entity_name = entity_name,
                count = attacks.attack_count[i],
                spread = attacks.attack_spread[i],
                type = attacks.attack_type[i],
            }

            if attacks.attack_use_multiplier[i] then
                data.count = math.floor(data.count * attacks.attack_count_multiplier[i][tier])
                data.spread = math.floor(data.spread * attacks.attack_spread_multiplier[i][tier])
            end
            
            data = set_optional_data(data, attacks, i, "attack_beam_duration")
            data = set_optional_data(data, attacks, i, "attack_beam_max_length")
            data = set_optional_data(data, attacks, i, "attack_beam_offset")
            
            data = set_optional_data(data, attacks, i, "attack_speed")
            data = set_optional_data(data, attacks, i, "unique_position")
            data = set_optional_data(data, attacks, i, "can_aim_attackable_targets")
            data = set_optional_data(data, attacks, i, "only_targets_radar")
            data = set_optional_data(data, attacks, i, "select_nearby_enemy_count")
            
            break
        end
    end
    data.entity_position = boss.entity_position
    data.surface = boss.surface
    data.entity_force = boss.force
    if boss.boss_tier > 1 then
        data.quality = 'erm-boss-'..GlobalConfig.BOSS_QUALITY_MAPPING[boss.boss_tier]
    end
    
    return data
end

local fetch_attack_data = function(force_name)
    local boss_data = storage.boss
    if not boss_data.attack_cache or boss_data.attack_cache_force_refresh then
        boss_data.attack_cache_force_refresh = false
        boss_data.attack_cache = remote.call(storage.remote_race_name_cache[force_name] .. "_boss_attacks", "get_attack_data")
    end
end

local prepare_attack = function(type)
    if not storage.boss or not storage.boss.entity then
        return
    end
    local force_name = storage.boss.force_name
    local tier = storage.boss.boss_tier
    fetch_attack_data(force_name)
    local data = select_attack(force_name, storage.boss.attack_cache[type], tier)
    queue_attack(data)
end

local get_despawn_attack = function()
    local force_name = storage.boss.force_name
    local tier = storage.boss.boss_tier
    fetch_attack_data(force_name)
    local data = select_attack(force_name, storage.boss.attack_cache.despawn_attacks, tier)
    return data
end

local get_idle_attack = function()
    local force_name = storage.boss.force_name
    local tier = storage.boss.boss_tier
    fetch_attack_data(force_name)
    local data = select_attack(force_name, storage.boss.attack_cache.idle_attacks, tier)
    return data
end


local attack_projectile = function(data)
    local start_position = data.entity_position
    local surface = data.surface
    local entity_name = data.entity_name
    local position = data.position
    start_position = Position.get_offset_position(start_position, position, 8)
    start_position = surface.find_non_colliding_position(entity_name, start_position, 12, 1, true)
    surface.create_entity({
        name = entity_name,
        position = start_position,
        target = position,
        speed = data.speed or 0.2,
        max_range = data.range or 96,
        create_build_effect_smoke = false,
        raise_built = false,
        force = data.entity_force,
        quality = data.quality
    })
end

local attack_falling_projectile = function(data)
    local boss_data = storage.boss
    local surface = data.surface
    local entity_name = data.entity_name
    local position = data.position
    local start_drop_position = {
        x = position.x + chunksize * Direction.multipliers[Direction.opposite(boss_data.target_direction)][1],
        y = position.y - chunksize
    }
    start_drop_position = surface.find_non_colliding_position(entity_name, start_drop_position, 12, 1, true)
    surface.create_entity({
        name = entity_name,
        position = start_drop_position,
        target = position,
        speed = 0.2,
        max_range = 32,
        create_build_effect_smoke = false,
        raise_built = false,
        force = data.entity_force,
        quality = data.quality
    })
end

local attack_direct = function(data)
    data.surface.create_entity({
        name = data.entity_name,
        position = data.position,
        create_build_effect_smoke = false,
        raise_built = false,
        force = data.entity_force,
        quality = data.quality
    })
end

local attack_beam = function(data)
    local start_position = data.entity_position
    local surface = data.surface

    -- Calculate distance between start_position and data.position
    local distance = Position.distance(start_position, data.position)
    
    -- If distance is lower than data.attack_beam_max_length, change data.position to be at data.attack_beam_max_length
    if data.attack_beam_max_length and distance < data.attack_beam_max_length then
        local direction_x = data.position.x - start_position.x
        local direction_y = data.position.y - start_position.y
        local length = math.sqrt(direction_x^2 + direction_y^2)
        if length > 0 then
            local normalized_x = direction_x / length
            local normalized_y = direction_y / length
            data.position = {
                x = start_position.x + normalized_x * data.attack_beam_max_length,
                y = start_position.y + normalized_y * data.attack_beam_max_length
            }
        end
    end

   
    surface.create_entity({
        name = data.entity_name,
        position = start_position,
        source_position = start_position,
        target_position = data.position,
        duration = data.attack_beam_duration or 180,
        max_length = data.attack_beam_max_length or 1000,
        create_build_effect_smoke = false,
        raise_built = false,
        force = data.entity_force,
        quality = data.quality
    })
end


local attack_struct_spawn = function(data)
    local boss_data = storage.boss
    local surface = data.surface
    local new_entity_name = data.entity_name .. '--' .. boss_data.boss_tier
    local position = surface.find_non_colliding_position(new_entity_name, data.entity_position, 64, 12, true)
    storage.skip_quality_rolling = true
    surface.create_entity({
        name = new_entity_name,
        position = position,
        create_build_effect_smoke = false,
        raise_built = false,
        force = data.entity_force,
        quality = data.quality
    })
end

--- Spawn divine tier only.
local attack_unit_spawn = function(data)
    local boss_data = storage.boss
    local surface = data.surface
    local entity_name = data.entity_name
    local position = data.position
    local start_position = data.entity_position
    local entity_force = data.entity_force
    local new_entity_name = entity_name .. '--6'
    local spawn_units = {}
    position = surface.find_non_colliding_position(new_entity_name, start_position, 64, 12, true)
    for i = 0, GlobalConfig.batch_spawn_size do
        storage.skip_quality_rolling = true
        local units = surface.create_entity({
            name = new_entity_name,
            position = position,
            create_build_effect_smoke = false,
            raise_built = false,
            force = entity_force,
            quality = data.quality
        })
        table.insert(spawn_units, units)
    end
    
    if spawn_units and #spawn_units > 0 then
        local group_position = Position.get_offset_position(start_position, data.position, 8)
        local unit_group = surface.create_unit_group({position=group_position, force=entity_force})
        for _, unit in pairs(spawn_units) do
            unit_group.add_member(unit)
        end
        local command = {
            type = defines.command.attack_area,
            destination = data.position,
            radius = chunksize,
            distraction = defines.distraction.by_anything
        }
        storage.erm_unit_groups[unit_group.unique_id] = {
            commands = command,
            start_position = unit_group.position,
            group = unit_group,
            always_angry = false,
            nearby_retry = 0,
            attack_force = boss_data.radar.force or game.forces['player'],
            created = game.tick
        }
        unit_group.set_command(command)
        unit_group.start_moving()
    end
end

local attack_segment_unit_spawn  = function(data)
    local boss_data = storage.boss
    -- process the follow if not boss_data.controlled_segment_unit
    -- first a segmented unit within the boss_data.scan_area
    -- if segmented unit found, assign to seg_unit and do the following code
    local surface = data.surface
    local entity_name = data.entity_name
    local entity_force = data.entity_force 
    local send_alert = false
    -- First, try to find an existing segmented unit in the scan area
    if storage.boss.controlled_segment_unit and
       storage.boss.controlled_segment_unit.entity and
       storage.boss.controlled_segment_unit.entity.valid 
    then
        return
    end

    local segmented_units = surface.find_entities_filtered{
        area = boss_data.scan_area,
        type = "segmented-unit",
        force = entity_force,
        limit = 1,
    }

    local _, seg_unit = next(segmented_units)
    local final_seg_unit
    if seg_unit and seg_unit.valid and seg_unit.segmented_unit then
        send_alert = true
        local territory = seg_unit.segmented_unit.territory
        final_seg_unit = seg_unit.segmented_unit
        local new_territory_chunks = Territory.compute_territory_path(seg_unit.position, boss_data.radar_position)
        if territory then
            surface.set_territory_for_chunks(
                    new_territory_chunks,
                    territory
            )
        end
    else
        -- if segmented unit not found, iterate the chunks in boss_data.scan_area,
        -- and find the first chunk with LuaTerritory
        -- Get its segmented_unit and do the following
        local territories = surface.get_territories()
        for _, territory in pairs(territories) do
            if territory and territory.valid then
                -- Check if territory is in scan area
                local chunk_positions = territory.get_chunks()
                local in_scan_area = false
                for _, chunk_pos in pairs(chunk_positions) do
                    local chunk_center = {
                        x = chunk_pos.x * 32 + 16,
                        y = chunk_pos.y * 32 + 16
                    }
                    if chunk_center.x >= boss_data.scan_area.left_top.x and
                            chunk_center.x <= boss_data.scan_area.right_bottom.x and
                            chunk_center.y >= boss_data.scan_area.left_top.y and
                            chunk_center.y <= boss_data.scan_area.right_bottom.y then
                        in_scan_area = true
                        break
                    end
                end

                if in_scan_area then
                    -- Find a segmented unit in this territory
                    local units = territory.get_segmented_units()

                    for _, unit in pairs(units) do
                        if unit and unit.valid then
                            seg_unit = unit
                            break
                        end
                    end

                    if seg_unit then
                        local territory = seg_unit.territory
                        local unit_position = seg_unit.get_body_nodes()[1]
                        local new_territory_chunks = Territory.compute_territory_path(unit_position, boss_data.radar_position)
                        if territory then
                            surface.set_territory_for_chunks(
                                    new_territory_chunks,
                                    territory
                            )
                        end
                        final_seg_unit = seg_unit
                        send_alert = true
                        break
                    end
                end
            end
        end
    end


    -- if neither territory or segmented_unit found in boss_data.scan_area, do the following
    if not seg_unit then
        --- Spawn at 15% away from boss.
        local spawn_position = Position.lerp(boss_data.entity_position, boss_data.radar_position, 0.15)
        if RaceSettingsHelper.can_spawn(35) then
            spawn_position = Position.random({x = boss_data.radar_position.x, y = spawn_position.y}, -64, 64)
        elseif RaceSettingsHelper.can_spawn(35) then
            spawn_position = Position.random({x = spawn_position.x, y = boss_data.radar_position.y}, -64, 64)
        else
            spawn_position = Position.random(spawn_position, -64, 64)
        end

        storage.skip_quality_rolling = true
        seg_unit = surface.create_entity({
            name = entity_name,
            position = spawn_position,
            create_build_effect_smoke = false,
            raise_built = false,
            force = entity_force,
            quality = data['quality']
        })

        if seg_unit then
            -- Create territory path from spawn position to mid position
            local new_territory_chunks = Territory.compute_territory_path(spawn_position, boss_data.radar_position, 5)

            -- Create territory on surface
            local territory = surface.create_territory{
                chunks = Table.array_combine(new_territory_chunks)
            }

            -- Assign unit to territory
            seg_unit.segmented_unit.territory = territory
            final_seg_unit = seg_unit.segmented_unit
            send_alert = true
        end
    end

    if send_alert and final_seg_unit then
        surface.print('Boss Radar: Detected territory anomalies.')
        final_seg_unit.set_ai_state({
            type = defines.segmented_unit_ai_state.investigating,
            destination = boss_data.radar.position
        })
        storage.boss.controlled_segment_unit = {
            entity = final_seg,
            unit_number = seg_unit.unit_number
        }
        storage.boss.segmented_unit_check_time = game.tick
    end
end

local attack_select_nearby_enemy = function(data)
    local boss_data = storage.boss
    local surface = data.surface
    local start_position = data.entity_position
    local entity_force = data.entity_force
    local target_count = math.floor(data.select_nearby_enemy_count * GlobalConfig.max_group_size())
    local spawn_units = surface.find_entities_filtered({
        position = start_position,
        radius = bossRadius,
        type = "unit",
        force = entity_force,
        limit = target_count,
    })
    
    if not spawn_units or #spawn_units < (target_count / 2) then
        local additional_spawn_units = surface.find_entities_filtered({
            area = boss_data.scan_area_wo_padding,
            type = "unit",
            force = entity_force,
            limit = target_count,
        })    
        
        local start_index = #spawn_units
        for _, unit in pairs(additional_spawn_units) do
            if start_index < target_count then
                table.insert(spawn_units, unit)
                start_index = start_index + 1
            end
        end
    end

    if spawn_units and #spawn_units > 0 then
        local group_position = Position.get_offset_position(start_position, data.position, chunksize)
        local unit_group = surface.create_unit_group({position=group_position, force=entity_force})
        for _, unit in pairs(spawn_units) do
            unit_group.add_member(unit)
        end
        local command = {
            type = defines.command.attack_area,
            destination = data.position,
            radius = chunksize,
            distraction = defines.distraction.by_anything
        }
        storage.erm_unit_groups[unit_group.unique_id] = {
            commands = command,
            start_position = unit_group.position,
            group = unit_group,
            always_angry = false,
            nearby_retry = 0,
            attack_force = boss_data.radar.force or game.forces['player'],
            created = game.tick
        }
        unit_group.set_command(command)
        unit_group.start_moving()
    end
end

local attack_functions = {
    [BossAttackProcessor.TYPE_PROJECTILE] = attack_projectile,
    [BossAttackProcessor.TYPE_FALLING_PROJECTILE] = attack_falling_projectile,
    [BossAttackProcessor.TYPE_DIRECT] = attack_direct,
    [BossAttackProcessor.TYPE_BEAM] = attack_beam,
    [BossAttackProcessor.TYPE_STRUCT_SPAWN] = attack_struct_spawn,
    [BossAttackProcessor.TYPE_UNIT_SPAWN] = attack_unit_spawn,
    [BossAttackProcessor.TYPE_SEGMENTED_UNIT_SPAWN] = attack_segment_unit_spawn,
    [BossAttackProcessor.TYPE_SELECT_NEARBY_ENEMY] = attack_select_nearby_enemy
}

local process_attack = function(data)
    data.unique_position = data.unique_position or false
    data.artillery_mode = data.artillery_mode or false
    local surface = data.surface
    local entity_force = data.entity_force
    if not (surface and surface.valid and entity_force and entity_force.valid) or data.position == nil then
        DebugHelper.print("not valid surface / force / position")
        return
    end
    
    if data.artillery_mode then
        data.speed = 1
        data.range = scanRange
    end
    
    for i = 1, data.count do
        if attack_functions[data.type] then
            -- First shot always accurate, subsequent shot varies
            if i > 1 then
                local position = data.position
                if data.unique_position then
                    DebugHelper.print("Retargeting as unique position")
                    position = acquire_attack_target(data)
                end

                if data.artillery_mode then
                    position = Position.random(position, -16, 16)
                else
                    position = Position.random(position, -8, 8)
                end
                data.position = position
            end
            
            attack_functions[data.type](data)
        end
    end
end

function BossAttackProcessor.unset_close_range_entities_cache()
    storage.boss.close_range_entities_cache = {}
    storage.boss.close_range_entities_cache_size = 0
end

function BossAttackProcessor.unset_attackable_entities_cache()
    storage.boss.close_range_entities_cache = {}
    storage.boss.close_range_entities_cache_size = 0
    storage.boss.long_range_entities_cache = {}
    storage.boss.long_range_entities_cache_size = 0
    storage.boss.long_range_entities_cache_tick = 0
end

function BossAttackProcessor.exec_basic()
    prepare_attack("basic_attacks")
end

function BossAttackProcessor.exec_heavy()
    prepare_attack("heavy_attacks")
end

function BossAttackProcessor.exec_assist()
    prepare_attack("assist_attacks")
end

function BossAttackProcessor.exec_special()
    prepare_attack("special_attacks")
end

function BossAttackProcessor.exec_ultimate()
    prepare_attack("ultimate_attacks")
end

function BossAttackProcessor.exec_phase()
    local boss_data = storage.boss
    local boss_entity = boss_data.entity
    local data = {}
    data['surface'] =  boss_data.surface
    data['force'] = boss_data.force
    data['is_boss'] = true
    data['target_force'] = boss_data.radar.force
    data['attack_position'] = boss_data.radar_position
    data['builder_name'] = RaceSettingsHelper.get_builder(boss_data.force.name)
    
    if boss_entity.get_health_ratio() < 0.1 then
        data['current_emo'] = EmotionConstants.EMO_RUSH
        EmotionProcessor.switch(data)
    else
        EmotionProcessor.switch(data)
    end 
end

function BossAttackProcessor.process_despawn_attack()
    BossAttackProcessor.unset_attackable_entities_cache()
    local data = get_despawn_attack()
    for i = 1, data.spread do
        local position, artillery_mode = acquire_attack_target({})
        data.artillery_mode = artillery_mode
        data.position = position
        Cron.add_quick_queue("BossAttackProcessor.process_attack", table.deepcopy(data), true)
    end
end

function BossAttackProcessor.process_idle_attack()
    local data = get_idle_attack()
    for i = 1, data.spread do
        local position, artillery_mode = acquire_attack_target({})
        data.artillery_mode = artillery_mode
        data.position = position
        Cron.add_quick_queue("BossAttackProcessor.process_attack", table.deepcopy(data), true)
    end
end 

function BossAttackProcessor.process_attack(data, force_to_run)
    local boss_data = storage.boss
    if (force_to_run ~= true and (not boss_data or 
            not boss_data.entity or not boss_data.entity.valid or
            not boss_data.radar or not boss_data.radar.valid or
            not data.position or data == nil)) 
    then
        return
    end

    process_attack(data)
end

function BossAttackProcessor.create_artillery_targets_index()
    if not RaceSettingsHelper.is_in_boss_mode() or (storage.boss.indexing_artillery_targets and storage.boss.indexing_artillery_targets > 0) then
        return
    end

    local boss = storage.boss
    local left_top = boss.scan_area.left_top
    local right_bottom = boss.scan_area.right_bottom
    ---@expansive_call
    local land_beacons =
    AttackGroupBeaconProcessor.get_beacon_data(AttackGroupBeaconConstants.LAND_BEACON,
            boss.surface.index, boss.force.name
    )
    if land_beacons then
        -- Convert to array and reverse it
        local reversed_beacons_array = {}
        for key, beacon in pairs(land_beacons) do
            table.insert(reversed_beacons_array,  beacon)
        end
        
        local search_area = { left_top = left_top, right_bottom = right_bottom}
        local runs = 0
        -- Iterate in reverse order
        for i = #reversed_beacons_array, 1, -1 do
            local beacon = reversed_beacons_array[i]
            if beacon.beacon and beacon.beacon.valid and
                    Position.inside(beacon.beacon.position,search_area)
            then
                Cron.add_quick_queue("BossAttackProcessor.index_artillery_targets", beacon.beacon)
                runs = runs + 1
            end
        end
        storage.boss.indexing_artillery_targets = runs
    end
end

function BossAttackProcessor.index_artillery_targets(beacon)
    if not RaceSettingsHelper.is_in_boss_mode() or (storage.boss.long_range_entities_cache_size or 0) >= scanTotalAttackEntityLimit then
        return
    end
    local entities_cache = storage.boss.long_range_entities_cache or {}
    local boss = storage.boss
    local surface = boss.surface
    local entities = surface.find_entities_filtered {
        force = ForceHelper.get_player_forces(),
        radius = AttackGroupBeaconConstants.BEACON_RADIUS,
        position = beacon.position,
        limit = scanAttackEntityLimit,
        type = turret_types
    }
    for i, entity in pairs(entities) do
        if i % 5 == 0 and entity.valid then
            table.insert(entities_cache, entity)
        end
    end
    storage.boss.long_range_entities_cache = entities_cache
    storage.boss.long_range_entities_cache_size = #storage.boss.long_range_entities_cache
    storage.boss.indexing_artillery_targets = storage.boss.indexing_artillery_targets - 1
end

return BossAttackProcessor