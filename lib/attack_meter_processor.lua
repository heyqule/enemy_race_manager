---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 7/17/2021 1:51 PM
---

local String = require('__stdlib__/stdlib/utils/string')

local GlobalConfig = require('__enemyracemanager__/lib/global_config')
local ForceHelper = require('__enemyracemanager__/lib/helper/force_helper')
local RaceSettingsHelper = require('__enemyracemanager__/lib/helper/race_settings_helper')
local DebugHelper = require('__enemyracemanager__/lib/debug_helper')

local AttackGroupProcessor = require('__enemyracemanager__/lib/attack_group_processor')

local Cron = require('__enemyracemanager__/lib/cron_processor')

local AttackMeterProcessor = {}

AttackMeterProcessor.SPAWNER_POINTS = 50;
AttackMeterProcessor.TURRET_POINTS = 10;
AttackMeterProcessor.UNIT_POINTS = 1;

local get_statistic_cache = function(race_name, force)
    if global.kill_count_statistics_cache[race_name] == nil then
        global.kill_count_statistics_cache[race_name] = force.kill_count_statistics
    end
    return global.kill_count_statistics_cache[race_name]
end

local calculatePoints = function(race_name, statistic,
                                 entity_names, level, interval)
    local points = 0
    for _, name in pairs(entity_names) do
        local count = statistic.get_flow_count {
            name = race_name .. '/' .. name .. '/' .. level,
            input = false,
            precision_index = interval
        }
        points = points + count
    end

    return points
end

local calculateNextThreshold = function(race_name)
    local threshold = GlobalConfig.attack_meter_threshold() * GlobalConfig.max_group_size() * AttackGroupProcessor.MIXED_UNIT_POINTS
    local derivative = GlobalConfig.attack_meter_deviation()
    RaceSettingsHelper.set_next_attack_threshold(
            race_name,
            threshold + threshold * (math.random(derivative * -1, derivative) / 100)
    )
end

function AttackMeterProcessor.init_globals()
    global.kill_count_statistics_cache = global.kill_count_statistics_cache or {}
end

function AttackMeterProcessor.exec()
    if GlobalConfig.attack_meter_enabled() == false then
        return
    end

    local force_names = ForceHelper.get_enemy_forces()

    for _, name in pairs(force_names) do
        AttackMeterProcessor.calculate_points(name)
    end
end

function AttackMeterProcessor.add_form_group_cron()
    if GlobalConfig.attack_meter_enabled() == false then
        return
    end

    local force_names = ForceHelper.get_enemy_forces()

    for _, force_name in pairs(force_names) do
        local force = game.forces[force_name]
        local race_name = ForceHelper.extract_race_name_from(force_name)
        if GlobalConfig.race_is_active(race_name) then
            Cron.add_10_sec_queue('AttackMeterProcessor.form_group', race_name, force)
        end
    end
end

function AttackMeterProcessor.calculate_points(force_name)
    local interval = defines.flow_precision_index.one_minute

    local force = game.forces[force_name]
    local race_name = ForceHelper.extract_race_name_from(force_name)
    if not GlobalConfig.race_is_active(race_name) then
        return
    end

    local statistic_cache = get_statistic_cache(race_name, force)
    if statistic_cache == nil then
        return
    end

    local level = RaceSettingsHelper.get_level(race_name)

    local units = RaceSettingsHelper.get_current_unit_tier(race_name)
    local unit_points = calculatePoints(race_name, statistic_cache, units, level, interval)

    local buildings = RaceSettingsHelper.get_current_building_tier(race_name)
    local building_points = calculatePoints(race_name, statistic_cache, buildings, level, interval)

    local turrets = RaceSettingsHelper.get_current_turret_tier(race_name)
    local turret_points = calculatePoints(race_name, statistic_cache, turrets, level, interval)

    local attack_meter_points = unit_points * AttackMeterProcessor.UNIT_POINTS +
            building_points * AttackMeterProcessor.SPAWNER_POINTS +
            turret_points * AttackMeterProcessor.TURRET_POINTS

    RaceSettingsHelper.add_killed_units_count(race_name, unit_points)
    RaceSettingsHelper.add_killed_structure_count(race_name, building_points + turret_points)

    attack_meter_points = attack_meter_points * GlobalConfig.attack_meter_collector_multiplier()

    if GlobalConfig.time_base_attack_enabled() and level > 2 then
        local extra_points = RaceSettingsHelper.get_next_attack_threshold(race_name) * (GlobalConfig.time_base_attack_points() / 100)
        attack_meter_points = attack_meter_points + extra_points
    end

    RaceSettingsHelper.add_to_attack_meter(race_name, math.floor(attack_meter_points))

    local spawner_destroy_factor = game.map_settings.enemy_evolution.destroy_factor
    local unit_evolution_points = unit_points * 0.025 * spawner_destroy_factor
    local turret_evolution_points = turret_points * 0.2 * spawner_destroy_factor
    local spawner_evolution_points = 0

    if GlobalConfig.spawner_kills_deduct_evolution_points() then
        unit_evolution_points = unit_points * 0.05 * spawner_destroy_factor
        turret_evolution_points = turret_evolution_points * -0.5 * spawner_destroy_factor
        spawner_evolution_points = building_points * -1.5 * spawner_destroy_factor
    end

    global.race_settings[race_name].evolution_base_point = global.race_settings[race_name].evolution_base_point + unit_evolution_points + turret_evolution_points + spawner_evolution_points

end

function AttackMeterProcessor.form_group(race_name, force)
    if not GlobalConfig.race_is_active(race_name) then
        return
    end

    local next_attack_threshold = RaceSettingsHelper.get_next_attack_threshold(race_name)
    if next_attack_threshold == 0 then
        calculateNextThreshold(race_name)
        return
    end

    local current_attack_value = RaceSettingsHelper.get_attack_meter(race_name)
    -- Process attack point group
    if current_attack_value > next_attack_threshold then
        local elite_attack_point_threshold = GlobalConfig.elite_squad_attack_points()
        local accumulated_attack_meter = RaceSettingsHelper.get_accumulated_attack_meter(race_name)
        local last_accumulated_attack_meter = RaceSettingsHelper.get_last_accumulated_attack_meter(race_name) or 0
        if GlobalConfig.elite_squad_enable() and RaceSettingsHelper.get_tier(race_name) == 3 and (accumulated_attack_meter - last_accumulated_attack_meter) > elite_attack_point_threshold then
            AttackGroupProcessor.exec_elite_group(race_name, force, next_attack_threshold)
        else
            AttackGroupProcessor.exec(race_name, force, next_attack_threshold)
        end
    end
end

function AttackMeterProcessor.adjust_attack_meter(race_name)
    RaceSettingsHelper.add_to_attack_meter(race_name, RaceSettingsHelper.get_next_attack_threshold(race_name) * -1)
    calculateNextThreshold(race_name)
end

function AttackMeterProcessor.adjust_last_accumulated_attack_meter(race_name)
    RaceSettingsHelper.set_last_accumulated_attack_meter(race_name, RaceSettingsHelper.get_last_accumulated_attack_meter(race_name))
end

function AttackMeterProcessor.transfer_attack_points(race_name, friend_race_name)
    RaceSettingsHelper.add_to_attack_meter(race_name, RaceSettingsHelper.get_next_attack_threshold(friend_race_name))
    RaceSettingsHelper.add_to_attack_meter(race_name, RaceSettingsHelper.get_next_attack_threshold(race_name) * -1)
    calculateNextThreshold(race_name)
end

return AttackMeterProcessor