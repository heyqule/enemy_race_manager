---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 11/5/2022 11:16 AM
---


local GlobalConfig = require("__enemyracemanager__/lib/global_config")
local ForceHelper = require("__enemyracemanager__/lib/helper/force_helper")
local SurfaceProcessor = require("__enemyracemanager__/lib/surface_processor")
local QualityProcessor = require("__enemyracemanager__/lib/quality_processor")

---- Main Window
local MainWindow = {
    require_update_all = false,
    root_name = "erm_races_manager",
    window_width = 680,
    maximal_width = 1024,
    window_height = 400,
    maximal_height = 680,
}

--- Main Windows functions
function MainWindow.show(player)
    local gui = player.gui.screen
    if gui[MainWindow.root_name] then
        return
    end
    local main_window = gui.add {
        type = "frame",
        name = MainWindow.root_name,
        direction = "vertical",
    }
    main_window.force_auto_center()
    player.opened = main_window
    local surface_name = player.surface.name

    --- fallback to nauvis if player is not on a planet.
    local is_planet = true
    if not storage.enemy_surfaces[surface_name] then
        surface_name = 'nauvis'
        is_planet = false
    end

    local admin = player.admin
    main_window.style.maximal_width = MainWindow.maximal_width
    main_window.style.minimal_width = MainWindow.window_width
    main_window.style.maximal_height = MainWindow.window_height * 2
    main_window.style.minimal_height = MainWindow.maximal_height
    -- Race Manager Title
    local title_flow = main_window.add { type = "flow", name = "title_flow", direction = "horizontal" }
    title_flow.style.minimal_width = MainWindow.window_width

    local title = title_flow.add { type = "label", name = "title", caption = { "gui.title" }, style = "caption_label" }

    local pusher = title_flow.add { type = "empty-widget", style = "draggable_space_header" }
    --- not sure why vertically_stretchable = true causes to stretch in height, comparing to other windows.
    pusher.style.height = 24
    pusher.style.horizontally_stretchable = true
    pusher.drag_target = main_window

    local close_button = title_flow.add { type = "sprite-button",
                                          name = "erm_close_button",
                                          sprite = "utility/close",
                                          style = "frame_action_button",
                                          tooltip = { "gui.close-instruction" }
    }
    close_button.style.width = 24
    close_button.style.height = 24
    close_button.style.horizontal_align = "right"

    local scroll = main_window.add { type = "scroll-pane", style = "scroll_pane_in_shallow_frame" }
    scroll.style.margin = 5
    main_window.style.minimal_height = MainWindow.window_height / 1.25

    if is_planet then
        scroll.add { type = "label", name = "surface_name", caption = { "gui.current_planet", SurfaceProcessor.get_planet_icon(surface_name) .. surface_name }, style = "caption_label" }
    else
        scroll.add { type = "label", name = "surface_name", caption = { "gui.not_on_planet" }, style = "caption_label" }
    end

    local item_table = scroll.add { type = "table", column_count = 7, style = "bordered_table" }
    item_table.style.horizontally_stretchable = false

    item_table.add { type = "label", caption = { "gui.race_column" } }
    item_table.add { type = "label", caption = { "gui.tier_column" } }
    item_table.add { type = "label", caption = { "gui.evolution_column" } }
    item_table.add { type = "label", caption = { "gui.progress_column" } }
    item_table.add { type = "label", caption = { "gui.attack_column" } }
    item_table.add { type = "label", caption = { "gui.total_attack_column" } }
    item_table.add { type = "label", caption = { "gui.action_column" } }

    for name, race_setting in pairs(storage.race_settings) do
        if race_setting.label then
            local points = QualityProcessor.get_quality_point(race_setting.race, surface_name) or 0
            item_table.add { type = "label", caption = race_setting.label }
            item_table.add { type = "label", caption = race_setting.tier }
            item_table.add { type = "label", caption = string.format("%.2f", game.forces[race_setting.race].get_evolution_factor(surface_name) * 100) .. '%' }
            item_table.add { type = "label", caption = (points / 100) .. "%" }
            item_table.add { type = "label", caption = race_setting.attack_meter .. "/" .. race_setting.next_attack_threshold }
            item_table.add { type = "label", caption = race_setting.attack_meter_total }
            local action_flow = item_table.add { type = "flow", name = name .. "_flow", direction = "vertical" }
            action_flow.add { type = "button", name = race_setting.race .. "/detail_action", tags={filter_pattern=".*/detail_action"}, caption = { "gui.detail_action" }, tooltip = { "gui.detail_action_tooltip" } }
        end
    end

    if admin then
        local bottom_flow = main_window.add { type = "flow", direction = "horizontal" }
        bottom_flow.add { type = "button", name = "erm_clean_idle_biter", caption = { "gui.clean_idle_biter" }, tooltip = { "gui.clean_idle_biter_tooltip" }, style = "red_button" }
    end
end

function MainWindow.hide(player)
    if player.gui.screen[MainWindow.root_name] then
        player.gui.screen[MainWindow.root_name].destroy()
    end
end

function MainWindow.update(player)
    if MainWindow.is_showing(player) then
        MainWindow.hide(player)
        MainWindow.show(player)
    end
end

function MainWindow.update_all()
    for k, player in pairs(game.connected_players) do
        if player then
            MainWindow.update(player)
        end
    end
end

function MainWindow.is_hidden(player)
    return player.gui.screen[MainWindow.root_name] == nil
end

function MainWindow.is_showing(player)
    return not MainWindow.is_hidden(player)
end

function MainWindow.toggle_main_window(owner)
    if owner then
        if MainWindow.is_hidden(owner) then
            MainWindow.show(owner)
        else
            MainWindow.hide(owner)
        end
    end
end

function MainWindow.toggle_close(owner)
    if owner then
        MainWindow.hide(owner)
    end
end

function MainWindow.kill_idle_units(event)
    SurfaceProcessor.wander_unit_clean_up()
end


return MainWindow